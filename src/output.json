[
  {
    "file": "FLT.lean",
    "output": {
      "messages": [
        {
          "severity": "info",
          "pos": {
            "line": 30,
            "column": 0
          },
          "endPos": {
            "line": 30,
            "column": 6
          },
          "data": "'PNat.pow_add_pow_ne_pow' depends on axioms: [propext, sorryAx, Classical.choice, Quot.sound]"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "lakefile.lean",
    "output": {
      "env": 1
    }
  },
  {
    "file": "FLT/FLT_files.lean",
    "output": {
      "env": 2
    }
  },
  {
    "file": "FLT/DivisionAlgebra/Finiteness.lean",
    "output": {
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 38,
            "column": 87
          },
          "goal": "K : Type u_1\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\nD : Type u_2\ninst\u271d\u00b9 : DivisionRing D\ninst\u271d : Algebra K D\n\u22a2 Module.Finite (FiniteAdeleRing (\ud835\udcde K) K) (D \u2297[K] FiniteAdeleRing (\ud835\udcde K) K)",
          "endPos": {
            "line": 38,
            "column": 92
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 70,
            "column": 2
          },
          "goal": "K : Type u_1\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : NumberField K\nD : Type u_2\ninst\u271d\u00b3 : DivisionRing D\ninst\u271d\u00b2 : Algebra K D\ninst\u271d\u00b9 : FiniteDimensional K D\ninst\u271d : Algebra.IsCentral K D\nU : Subgroup (Dfx K D)\nhU : IsOpen \u2191U\n\u22a2 Finite (Doset.Quotient (Set.range \u21d1(incl\u2081 K D)) \u2191U)",
          "endPos": {
            "line": 70,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 38,
            "column": 0
          },
          "endPos": {
            "line": 38,
            "column": 92
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 67,
            "column": 8
          },
          "endPos": {
            "line": 67,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 3
    }
  },
  {
    "file": "FLT/EllipticCurve/Torsion.lean",
    "output": {
      "sorries": [
        {
          "proofState": 2,
          "pos": {
            "line": 35,
            "column": 26
          },
          "goal": "k : Type u\ninst\u271d\u00b9 : Field k\nE : WeierstrassCurve k\ninst\u271d : E.IsElliptic\nn : \u2115\n\u22a2 \u2200 (x : E.n_torsion n), n \u2022 x = 0",
          "endPos": {
            "line": 35,
            "column": 31
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 39,
            "column": 91
          },
          "goal": "k : Type u\ninst\u271d\u00b9 : Field k\nE : WeierstrassCurve k\ninst\u271d : E.IsElliptic\nn : \u2115\nhn : 0 < n\n\u22a2 Finite (E.n_torsion n)",
          "endPos": {
            "line": 39,
            "column": 96
          }
        },
        {
          "proofState": 4,
          "pos": {
            "line": 44,
            "column": 38
          },
          "goal": "k : Type u\ninst\u271d\u00b2 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b9 : E.IsElliptic\ninst\u271d : IsSepClosed k\nn : \u2115\nhn : \u2191n \u2260 0\n\u22a2 Nat.card (E.n_torsion n) = n ^ 2",
          "endPos": {
            "line": 44,
            "column": 43
          }
        },
        {
          "proofState": 5,
          "pos": {
            "line": 49,
            "column": 66
          },
          "goal": "d : \u2115\nA : Type u_1\ninst\u271d : AddCommGroup A\nn : \u2115\nhn : 0 < n\nr : \u2115\nh : \u2200 (d : \u2115), d \u2223 n \u2192 Nat.card \u21a5(Submodule.torsionBy \u2124 A \u2191d) = d ^ r\n\u22a2 \u2203 \u03c6, True",
          "endPos": {
            "line": 49,
            "column": 71
          }
        },
        {
          "proofState": 6,
          "pos": {
            "line": 55,
            "column": 56
          },
          "goal": "k : Type u\ninst\u271d\u00b2 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b9 : E.IsElliptic\ninst\u271d : IsSepClosed k\nn : \u2115\nhn : \u2191n \u2260 0\n\u22a2 \u2203 \u03c6, True",
          "endPos": {
            "line": 55,
            "column": 61
          }
        },
        {
          "proofState": 7,
          "pos": {
            "line": 61,
            "column": 40
          },
          "goal": "k : Type u\ninst\u271d\u2075 : Field k\nE : WeierstrassCurve k\ninst\u271d\u2074 : E.IsElliptic\nK L : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra k K\ninst\u271d : Algebra k L\nf : K \u2192\u2090[k] L\n\u22a2 E\u27eeK\u27ef \u2192+ E\u27eeL\u27ef",
          "endPos": {
            "line": 61,
            "column": 45
          }
        },
        {
          "proofState": 8,
          "pos": {
            "line": 64,
            "column": 73
          },
          "goal": "k : Type u\ninst\u271d\u00b3 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b2 : E.IsElliptic\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra k K\n\u22a2 map E (AlgHom.id k K) = AddMonoidHom.id E\u27eeK\u27ef",
          "endPos": {
            "line": 64,
            "column": 78
          }
        },
        {
          "proofState": 9,
          "pos": {
            "line": 69,
            "column": 48
          },
          "goal": "k : Type u\ninst\u271d\u2077 : Field k\nE : WeierstrassCurve k\ninst\u271d\u2076 : E.IsElliptic\nK L M : Type u\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Field M\ninst\u271d\u00b2 : Algebra k K\ninst\u271d\u00b9 : Algebra k L\ninst\u271d : Algebra k M\nf : K \u2192\u2090[k] L\ng : L \u2192\u2090[k] M\n\u22a2 (map E g).comp (map E f) = map E (g.comp f)",
          "endPos": {
            "line": 69,
            "column": 53
          }
        },
        {
          "proofState": 10,
          "pos": {
            "line": 73,
            "column": 44
          },
          "goal": "k : Type u\ninst\u271d\u00b3 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b2 : E.IsElliptic\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra k K\n\u22a2 DistribMulAction (K \u2243\u2090[k] K) E\u27eeK\u27ef",
          "endPos": {
            "line": 73,
            "column": 49
          }
        },
        {
          "proofState": 11,
          "pos": {
            "line": 77,
            "column": 59
          },
          "goal": "k : Type u\ninst\u271d\u00b3 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b2 : E.IsElliptic\nn : \u2115\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra k K\n\u22a2 Representation (ZMod n) (K \u2243\u2090[k] K) (E.n_torsion n)",
          "endPos": {
            "line": 77,
            "column": 64
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 34,
            "column": 14
          },
          "endPos": {
            "line": 34,
            "column": 22
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 39,
            "column": 8
          },
          "endPos": {
            "line": 39,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 43,
            "column": 8
          },
          "endPos": {
            "line": 43,
            "column": 39
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 47,
            "column": 8
          },
          "endPos": {
            "line": 47,
            "column": 26
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 54,
            "column": 8
          },
          "endPos": {
            "line": 54,
            "column": 44
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 60,
            "column": 4
          },
          "endPos": {
            "line": 60,
            "column": 31
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 63,
            "column": 6
          },
          "endPos": {
            "line": 63,
            "column": 36
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 66,
            "column": 6
          },
          "endPos": {
            "line": 66,
            "column": 38
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 72,
            "column": 4
          },
          "endPos": {
            "line": 72,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 76,
            "column": 4
          },
          "endPos": {
            "line": 76,
            "column": 48
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 4
    }
  },
  {
    "file": "FLT/GaloisRepresentation/Cyclotomic.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "CompleteLattice.toTop",
            "IsCyclotomicExtension.exists_prim_root",
            "Membership.mem",
            "Top.top",
            "Set.instMembership",
            "Set.instCompleteAtomicBooleanAlgebra",
            "letFun",
            "CompleteAtomicBooleanAlgebra.toCompleteLattice",
            "PNat",
            "Set"
          ],
          "tactic": "obtain \u27e8z, hz\u27e9 : \u2203 z : L, IsPrimitiveRoot z N := IsCyclotomicExtension.exists_prim_root L (show _ \u2208 \u22a4 by simp)",
          "proofState": 12,
          "pos": {
            "line": 10,
            "column": 2
          },
          "goals": "L : Type\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nN : \u2115+\n\u22a2 Fintype.card \u21a5(rootsOfUnity (\u2191N) L) = \u2191N",
          "endPos": {
            "line": 11,
            "column": 65
          }
        },
        {
          "usedConstants": [
            "Set.univ",
            "Membership.mem",
            "of_eq_true",
            "Mathlib.Data.Set.Operations._auxLemma.1",
            "Set.instMembership",
            "PNat",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 13,
          "pos": {
            "line": 11,
            "column": 60
          },
          "goals": "L : Type\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nN : \u2115+\n\u22a2 N \u2208 \u22a4",
          "endPos": {
            "line": 11,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Field.isDomain",
            "IsPrimitiveRoot.card_rootsOfUnity",
            "NeZero.pnat",
            "EuclideanDomain.toCommRing",
            "Field.toEuclideanDomain"
          ],
          "tactic": "exact IsPrimitiveRoot.card_rootsOfUnity hz",
          "proofState": 14,
          "pos": {
            "line": 12,
            "column": 2
          },
          "goals": "case intro\nL : Type\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nN : \u2115+\nz : L\nhz : IsPrimitiveRoot z \u2191N\n\u22a2 Fintype.card \u21a5(rootsOfUnity (\u2191N) L) = \u2191N",
          "endPos": {
            "line": 12,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "OrderedCommMonoid.toCommMonoid",
            "Dvd.dvd",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "instPNatLinearOrderedCancelCommMonoid",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "semigroupDvd",
            "PNat.dvd_iff",
            "Nat.instDvd",
            "CommMonoid.toMonoid",
            "Nat",
            "Monoid.toSemigroup",
            "Iff.symm",
            "PNat"
          ],
          "tactic": "exact Iff.symm dvd_iff",
          "proofState": 15,
          "pos": {
            "line": 15,
            "column": 62
          },
          "goals": "A B : \u2115+\n\u22a2 \u2191A \u2223 \u2191B \u2194 A \u2223 B",
          "endPos": {
            "line": 15,
            "column": 84
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "pow_eq_pow_mod",
            "congrArg",
            "Monoid.toNatPow",
            "id",
            "Nat.instMod",
            "instHMod",
            "DivInvMonoid.toMonoid",
            "Group.toDivInvMonoid",
            "HMod.hMod",
            "HPow.hPow",
            "Nat",
            "instHPow",
            "Eq"
          ],
          "tactic": "rw [pow_eq_pow_mod b h, pow_eq_pow_mod c h]",
          "proofState": 16,
          "pos": {
            "line": 19,
            "column": 2
          },
          "goals": "a b c : \u2115\nG : Type\ninst\u271d : Group G\nt : G\nh : t ^ a = 1\nh2 : b \u2261 c [MOD a]\n\u22a2 t ^ b = t ^ c",
          "endPos": {
            "line": 19,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Monoid.toNatPow",
            "Nat.instMod",
            "instHMod",
            "DivInvMonoid.toMonoid",
            "congr_arg",
            "Group.toDivInvMonoid",
            "HMod.hMod",
            "HPow.hPow",
            "Nat",
            "instHPow"
          ],
          "tactic": "exact congr_arg _ h2",
          "proofState": 17,
          "pos": {
            "line": 20,
            "column": 2
          },
          "goals": "a b c : \u2115\nG : Type\ninst\u271d : Group G\nt : G\nh : t ^ a = 1\nh2 : b \u2261 c [MOD a]\n\u22a2 t ^ (b % a) = t ^ (c % a)",
          "endPos": {
            "line": 20,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "ZMod.cast",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingHom",
            "id",
            "ZMod.castHom_apply",
            "ZMod",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Nat.ModEq",
            "ZMod.charP",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "ZMod.val",
            "ZMod.castHom"
          ],
          "tactic": "rw [ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.val_natCast]",
          "proofState": 18,
          "pos": {
            "line": 24,
            "column": 2
          },
          "goals": "D : \u2115\nN : \u2115+\nh : D \u2223 \u2191N\ne : ZMod \u2191N\n\u22a2 ((ZMod.castHom h (ZMod D)) e).val \u2261 e.val [MOD D]",
          "endPos": {
            "line": 24,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Nat.mod_modEq",
            "ZMod.val"
          ],
          "tactic": "exact Nat.mod_modEq e.val D",
          "proofState": 19,
          "pos": {
            "line": 25,
            "column": 2
          },
          "goals": "D : \u2115\nN : \u2115+\nh : D \u2223 \u2191N\ne : ZMod \u2191N\n\u22a2 e.val % D \u2261 e.val [MOD D]",
          "endPos": {
            "line": 25,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Dvd.dvd",
            "Nat.instDvd",
            "Nat",
            "PNat"
          ],
          "tactic": "intros D M h",
          "proofState": 20,
          "pos": {
            "line": 30,
            "column": 4
          },
          "goals": "K : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\n\u22a2 (fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := @ZHat.proof_2,\n      one_mem' := ZHat.proof_3, add_mem' := @ZHat.proof_4, zero_mem' := ZHat.proof_5, neg_mem' := @ZHat.proof_6 }",
          "endPos": {
            "line": 30,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "ModularCyclotomicCharacter.unique"
          ],
          "tactic": "apply ModularCyclotomicCharacter.unique",
          "proofState": 21,
          "pos": {
            "line": 31,
            "column": 4
          },
          "goals": "K : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\n\u22a2 (ZMod.castHom h (ZMod \u2191D)) ((fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) M) =\n    (fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) D",
          "endPos": {
            "line": 31,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Membership.mem",
            "Units",
            "Subgroup",
            "Units.instGroup",
            "rootsOfUnity",
            "CommMonoid.toMonoid",
            "EuclideanDomain.toCommRing",
            "CommRing.toCommMonoid",
            "SetLike.instMembership",
            "Field.toEuclideanDomain",
            "Subgroup.instSetLike"
          ],
          "tactic": "intros t htD",
          "proofState": 22,
          "pos": {
            "line": 32,
            "column": 4
          },
          "goals": "case hc\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\n\u22a2 \u2200 t \u2208 rootsOfUnity (\u2191D) L,\n    g \u2191t = \u2191t ^ ((ZMod.castHom h (ZMod \u2191D)) ((fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) M)).val",
          "endPos": {
            "line": 32,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "ZHat.proof_1",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Field.isDomain",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingEquiv.instEquivLike",
            "RingHom",
            "Monoid.toNatPow",
            "Units",
            "ModularCyclotomicCharacter",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "ZMod",
            "Group.toDivInvMonoid",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "HPow.hPow",
            "Distrib.toMul",
            "CommMonoid.toMonoid",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "rootsOfUnity_le_of_dvd",
            "instHPow",
            "EuclideanDomain.toCommRing",
            "IsAlgClosed.card_rootsOfUnity",
            "CommRing.toRing",
            "RingEquiv",
            "CommRing.toCommMonoid",
            "RingAut.instGroup",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "ModularCyclotomicCharacter.spec",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid",
            "Units.instMulOneClass",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rw [ModularCyclotomicCharacter.spec L (IsAlgClosed.card_rootsOfUnity L M) g <| rootsOfUnity_le_of_dvd h htD]",
          "proofState": 23,
          "pos": {
            "line": 34,
            "column": 4
          },
          "goals": "case hc\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\nt : L\u02e3\nhtD : t \u2208 rootsOfUnity (\u2191D) L\n\u22a2 g \u2191t = \u2191t ^ ((ZMod.castHom h (ZMod \u2191D)) ((fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) M)).val",
          "endPos": {
            "line": 35,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "ZHat.proof_1",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Field.isDomain",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "CommSemiring.toSemiring",
            "RingHom",
            "Monoid.toNatPow",
            "Units",
            "Mathlib.Algebra.Group.Units.Defs._auxLemma.1",
            "ModularCyclotomicCharacter",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "ZMod",
            "Group.toDivInvMonoid",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "HPow.hPow",
            "Distrib.toMul",
            "CommMonoid.toMonoid",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instHPow",
            "EuclideanDomain.toCommRing",
            "IsAlgClosed.card_rootsOfUnity",
            "CommRing.toRing",
            "RingEquiv",
            "CommRing.toCommMonoid",
            "RingAut.instGroup",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Units.instMonoid",
            "DFunLike.coe",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid",
            "Units.instMulOneClass",
            "Semiring.toMonoidWithZero",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "norm_cast",
          "proofState": 24,
          "pos": {
            "line": 36,
            "column": 4
          },
          "goals": "case hc\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\nt : L\u02e3\nhtD : t \u2208 rootsOfUnity (\u2191D) L\n\u22a2 \u2191t ^ (\u2191((ModularCyclotomicCharacter L \u22ef) g)).val =\n    \u2191t ^ ((ZMod.castHom h (ZMod \u2191D)) ((fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) M)).val",
          "endPos": {
            "line": 36,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "ZHat.proof_1",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Field.isDomain",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "CommSemiring.toSemiring",
            "RingHom",
            "Units",
            "rootsOfUnity.pow_eq_pow",
            "ModularCyclotomicCharacter",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "Units.instGroup",
            "ZMod",
            "Group.toDivInvMonoid",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Distrib.toMul",
            "CommMonoid.toMonoid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "EuclideanDomain.toCommRing",
            "IsAlgClosed.card_rootsOfUnity",
            "CommRing.toRing",
            "RingEquiv",
            "CommRing.toCommMonoid",
            "RingAut.instGroup",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "DFunLike.coe",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid",
            "Units.instMulOneClass",
            "Semiring.toMonoidWithZero",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "apply rootsOfUnity.pow_eq_pow htD",
          "proofState": 25,
          "pos": {
            "line": 37,
            "column": 4
          },
          "goals": "case hc\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\nt : L\u02e3\nhtD : t \u2208 rootsOfUnity (\u2191D) L\n\u22a2 t ^ (\u2191((ModularCyclotomicCharacter L \u22ef) g)).val =\n    t ^ ((ZMod.castHom h (ZMod \u2191D)) ((fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) M)).val",
          "endPos": {
            "line": 37,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "id",
            "Nat.ModEq"
          ],
          "tactic": "dsimp only",
          "proofState": 26,
          "pos": {
            "line": 38,
            "column": 4
          },
          "goals": "case hc\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\nt : L\u02e3\nhtD : t \u2208 rootsOfUnity (\u2191D) L\n\u22a2 (\u2191((ModularCyclotomicCharacter L \u22ef) g)).val \u2261\n    ((ZMod.castHom h (ZMod \u2191D)) ((fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g)) M)).val [MOD \u2191D]",
          "endPos": {
            "line": 38,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Nat.ModEq.symm"
          ],
          "tactic": "symm",
          "proofState": 27,
          "pos": {
            "line": 39,
            "column": 4
          },
          "goals": "case hc\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\nt : L\u02e3\nhtD : t \u2208 rootsOfUnity (\u2191D) L\n\u22a2 (\u2191((ModularCyclotomicCharacter L \u22ef) g)).val \u2261\n    ((ZMod.castHom h (ZMod \u2191D)) \u2191((ModularCyclotomicCharacter L \u22ef) g)).val [MOD \u2191D]",
          "endPos": {
            "line": 39,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "PNat.castHom_val_modEq"
          ],
          "tactic": "apply PNat.castHom_val_modEq",
          "proofState": 28,
          "pos": {
            "line": 40,
            "column": 4
          },
          "goals": "case hc\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\ng : L \u2243+* L\nD M : \u2115+\nh : \u2191D \u2223 \u2191M\nt : L\u02e3\nhtD : t \u2208 rootsOfUnity (\u2191D) L\n\u22a2 ((ZMod.castHom h (ZMod \u2191D)) \u2191((ModularCyclotomicCharacter L \u22ef) g)).val \u2261\n    (\u2191((ModularCyclotomicCharacter L \u22ef) g)).val [MOD \u2191D]",
          "endPos": {
            "line": 40,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "ZHat.ext"
          ],
          "tactic": "ext",
          "proofState": 29,
          "pos": {
            "line": 41,
            "column": 17
          },
          "goals": "K : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\n\u22a2 (fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9) 1 = 1",
          "endPos": {
            "line": 41,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "MonoidHom.instMonoidHomClass",
            "ZHat.proof_1",
            "Dvd.dvd",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Field.isDomain",
            "CommRing.toNonUnitalCommRing",
            "Subring.instSetLike",
            "ZMod.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingEquiv.instEquivLike",
            "ZHat.commRing",
            "setOf",
            "RingHom",
            "Membership.mem",
            "MonoidHomClass.toOneHomClass",
            "Monoid.toNatPow",
            "Units",
            "Eq.rec",
            "Mathlib.Algebra.Group.Units.Defs._auxLemma.1",
            "rootsOfUnity.pow_eq_pow",
            "ModularCyclotomicCharacter",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "NonAssocSemiring.toMulZeroOneClass",
            "ZHat.proof_6",
            "ZHat.proof_2",
            "Units.instGroup",
            "rootsOfUnity",
            "ZMod",
            "Units.instOne",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "Group.toDivInvMonoid",
            "funext",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "Nat.ModEq",
            "HPow.hPow",
            "Nat.instDvd",
            "Distrib.toMul",
            "CommMonoid.toMonoid",
            "Subring",
            "map_one",
            "Nat.ModEq.symm",
            "Nat",
            "Pi.ring",
            "Subsemiring.mk",
            "MulOneClass.toOne",
            "ZHat.proof_3",
            "Eq.ndrec",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "rootsOfUnity_le_of_dvd",
            "Eq.refl",
            "Submonoid.mk",
            "ZHat",
            "instHPow",
            "EuclideanDomain.toCommRing",
            "IsAlgClosed.card_rootsOfUnity",
            "CommRing.toRing",
            "RingEquiv",
            "CommRing.toCommMonoid",
            "RingAut.instGroup",
            "OfNat.ofNat",
            "ZHat.proof_4",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "ZHat.proof_5",
            "Units.instMonoid",
            "DFunLike.coe",
            "PNat.castHom_val_modEq",
            "Subring.mk",
            "SetLike.instMembership",
            "ModularCyclotomicCharacter.spec",
            "ModularCyclotomicCharacter.unique",
            "Field.toEuclideanDomain",
            "Subgroup.instSetLike",
            "MonoidWithZero.toMonoid",
            "Units.instMulOneClass",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "simp only [map_one]",
          "proofState": 30,
          "pos": {
            "line": 41,
            "column": 22
          },
          "goals": "case h\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nn\u271d : \u2115+\n\u22a2 ((fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9) 1) n\u271d = 1 n\u271d",
          "endPos": {
            "line": 41,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "MonoidHom.instMonoidHomClass",
            "ZHat.proof_1",
            "Dvd.dvd",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Field.isDomain",
            "CommRing.toNonUnitalCommRing",
            "Subring.instSetLike",
            "ZMod.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingEquiv.instEquivLike",
            "setOf",
            "RingHom",
            "Membership.mem",
            "MonoidHomClass.toOneHomClass",
            "Monoid.toNatPow",
            "Units",
            "Mathlib.Algebra.Group.Units.Defs._auxLemma.1",
            "rootsOfUnity.pow_eq_pow",
            "ModularCyclotomicCharacter",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "NonAssocSemiring.toMulZeroOneClass",
            "ZHat.proof_6",
            "ZHat.proof_2",
            "Units.instGroup",
            "rootsOfUnity",
            "ZMod",
            "Units.instOne",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "Group.toDivInvMonoid",
            "funext",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "Nat.ModEq",
            "HPow.hPow",
            "Nat.instDvd",
            "Distrib.toMul",
            "CommMonoid.toMonoid",
            "Subring",
            "map_one",
            "Nat.ModEq.symm",
            "Nat",
            "Pi.ring",
            "Subsemiring.mk",
            "MulOneClass.toOne",
            "ZHat.proof_3",
            "Eq.ndrec",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "rootsOfUnity_le_of_dvd",
            "Eq.refl",
            "Submonoid.mk",
            "ZHat",
            "instHPow",
            "EuclideanDomain.toCommRing",
            "IsAlgClosed.card_rootsOfUnity",
            "CommRing.toRing",
            "RingEquiv",
            "CommRing.toCommMonoid",
            "RingAut.instGroup",
            "OfNat.ofNat",
            "ZHat.proof_4",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "ZHat.proof_5",
            "Units.instMonoid",
            "DFunLike.coe",
            "PNat.castHom_val_modEq",
            "Subring.mk",
            "SetLike.instMembership",
            "ModularCyclotomicCharacter.spec",
            "ModularCyclotomicCharacter.unique",
            "Field.toEuclideanDomain",
            "Subgroup.instSetLike",
            "MonoidWithZero.toMonoid",
            "Units.instMulOneClass",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rfl",
          "proofState": 31,
          "pos": {
            "line": 41,
            "column": 43
          },
          "goals": "case h\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nn\u271d : \u2115+\n\u22a2 \u27e8fun N => \u21911, \u22ef\u27e9 n\u271d = 1 n\u271d",
          "endPos": {
            "line": 41,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "ZHat.ext"
          ],
          "tactic": "ext",
          "proofState": 32,
          "pos": {
            "line": 42,
            "column": 21
          },
          "goals": "K : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nx\u271d\u00b9 x\u271d : L \u2243+* L\n\u22a2 { toFun := fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9, map_one' := \u22ef }.toFun (x\u271d\u00b9 * x\u271d) =\n    { toFun := fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9, map_one' := \u22ef }.toFun x\u271d\u00b9 *\n      { toFun := fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9, map_one' := \u22ef }.toFun x\u271d",
          "endPos": {
            "line": 42,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "MonoidHom.instMonoidHomClass",
            "ZHat.proof_1",
            "Dvd.dvd",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Field.isDomain",
            "CommRing.toNonUnitalCommRing",
            "Subring.instSetLike",
            "ZMod.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingEquiv.instEquivLike",
            "ZHat.commRing",
            "setOf",
            "RingHom",
            "Membership.mem",
            "Monoid.toNatPow",
            "Units",
            "Eq.rec",
            "Mathlib.Algebra.Group.Units.Defs._auxLemma.1",
            "rootsOfUnity.pow_eq_pow",
            "ModularCyclotomicCharacter",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "NonAssocSemiring.toMulZeroOneClass",
            "ZHat.proof_6",
            "ZHat.proof_2",
            "Units.instGroup",
            "rootsOfUnity",
            "ZMod",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "Group.toDivInvMonoid",
            "map_mul",
            "funext",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "Nat.ModEq",
            "HPow.hPow",
            "Nat.instDvd",
            "Distrib.toMul",
            "CommMonoid.toMonoid",
            "Subring",
            "Nat.ModEq.symm",
            "Nat",
            "Pi.ring",
            "Subsemiring.mk",
            "MonoidHomClass.toMulHomClass",
            "ZHat.proof_3",
            "Eq.ndrec",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "rootsOfUnity_le_of_dvd",
            "Eq.refl",
            "Units.instMul",
            "Submonoid.mk",
            "ZHat",
            "instHPow",
            "EuclideanDomain.toCommRing",
            "IsAlgClosed.card_rootsOfUnity",
            "CommRing.toRing",
            "RingEquiv",
            "CommRing.toCommMonoid",
            "RingAut.instGroup",
            "ZHat.proof_4",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "ZHat.proof_5",
            "Units.instMonoid",
            "DFunLike.coe",
            "PNat.castHom_val_modEq",
            "Subring.mk",
            "SetLike.instMembership",
            "ModularCyclotomicCharacter.spec",
            "ModularCyclotomicCharacter.unique",
            "Field.toEuclideanDomain",
            "Subgroup.instSetLike",
            "MonoidWithZero.toMonoid",
            "Units.instMulOneClass",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "simp only [map_mul]",
          "proofState": 33,
          "pos": {
            "line": 42,
            "column": 26
          },
          "goals": "case h\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nx\u271d\u00b9 x\u271d : L \u2243+* L\nn\u271d : \u2115+\n\u22a2 ({ toFun := fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9, map_one' := \u22ef }.toFun (x\u271d\u00b9 * x\u271d)) n\u271d =\n    ({ toFun := fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9, map_one' := \u22ef }.toFun x\u271d\u00b9 *\n        { toFun := fun g => \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) g), \u22ef\u27e9, map_one' := \u22ef }.toFun x\u271d)\n      n\u271d",
          "endPos": {
            "line": 42,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "MonoidHom.instMonoidHomClass",
            "ZHat.proof_1",
            "Dvd.dvd",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Field.isDomain",
            "CommRing.toNonUnitalCommRing",
            "Subring.instSetLike",
            "ZMod.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingEquiv.instEquivLike",
            "setOf",
            "RingHom",
            "Membership.mem",
            "Monoid.toNatPow",
            "Units",
            "Mathlib.Algebra.Group.Units.Defs._auxLemma.1",
            "rootsOfUnity.pow_eq_pow",
            "ModularCyclotomicCharacter",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "NonAssocSemiring.toMulZeroOneClass",
            "ZHat.proof_6",
            "ZHat.proof_2",
            "Units.instGroup",
            "rootsOfUnity",
            "ZMod",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "Group.toDivInvMonoid",
            "map_mul",
            "funext",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "Nat.ModEq",
            "HPow.hPow",
            "Nat.instDvd",
            "Distrib.toMul",
            "CommMonoid.toMonoid",
            "Subring",
            "Nat.ModEq.symm",
            "Nat",
            "Pi.ring",
            "Subsemiring.mk",
            "MonoidHomClass.toMulHomClass",
            "ZHat.proof_3",
            "Eq.ndrec",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "rootsOfUnity_le_of_dvd",
            "Eq.refl",
            "Units.instMul",
            "Submonoid.mk",
            "ZHat",
            "instHPow",
            "EuclideanDomain.toCommRing",
            "IsAlgClosed.card_rootsOfUnity",
            "CommRing.toRing",
            "RingEquiv",
            "CommRing.toCommMonoid",
            "RingAut.instGroup",
            "ZHat.proof_4",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "ZHat.proof_5",
            "Units.instMonoid",
            "DFunLike.coe",
            "PNat.castHom_val_modEq",
            "Subring.mk",
            "SetLike.instMembership",
            "ModularCyclotomicCharacter.spec",
            "ModularCyclotomicCharacter.unique",
            "Field.toEuclideanDomain",
            "Subgroup.instSetLike",
            "MonoidWithZero.toMonoid",
            "Units.instMulOneClass",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rfl",
          "proofState": 34,
          "pos": {
            "line": 42,
            "column": 47
          },
          "goals": "case h\nK : Type\ninst\u271d\u2074 : Field K\nL : Type\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : CharZero L\ninst\u271d : IsAlgClosed L\nx\u271d\u00b9 x\u271d : L \u2243+* L\nn\u271d : \u2115+\n\u22a2 \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) x\u271d\u00b9 * (ModularCyclotomicCharacter L \u22ef) x\u271d), \u22ef\u27e9 n\u271d =\n    (\u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) x\u271d\u00b9), \u22ef\u27e9 * \u27e8fun N => \u2191((ModularCyclotomicCharacter L \u22ef) x\u271d), \u22ef\u27e9) n\u271d",
          "endPos": {
            "line": 42,
            "column": 50
          }
        }
      ],
      "env": 5
    }
  },
  {
    "file": "FLT/GaloisRepresentation/HardlyRamified.lean",
    "output": {
      "env": 6
    }
  },
  {
    "file": "FLT/HIMExperiments/flatness.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "Iff.mpr",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "AddGroupWithOne.toAddGroup",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "RingHom",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "injective_iff_map_eq_zero",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "IsSMulRegular",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "Function.Injective",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LinearMap.toSpanSingleton",
            "Ring.toAddGroupWithOne",
            "letFun",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "TensorProduct.instModule",
            "Module.Flat.rTensor_preserves_injective_linearMap",
            "Semiring.toMonoidWithZero",
            "LinearMap.rTensor"
          ],
          "tactic": "have h :=\n  Flat.rTensor_preserves_injective_linearMap (M := M) (toSpanSingleton R R r) <| (injective_iff_map_eq_zero _).mpr hr",
          "proofState": 35,
          "pos": {
            "line": 41,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b3 : CommRing R\nM : Type v\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nr : R\nhr : r \u2208 R\u2070\ninst\u271d : Flat R M\n\u22a2 IsSMulRegular M r",
          "endPos": {
            "line": 42,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearEquiv.symm",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "LinearMap.comp",
            "CommRing.toCommSemiring",
            "LinearEquiv.toLinearMap",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "IsSMulRegular",
            "TensorProduct.lid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "RingHomCompTriple.ids",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LinearMap.toSpanSingleton",
            "letFun",
            "MulZeroClass.toZero",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero",
            "LinearMap.rTensor"
          ],
          "tactic": "have h2 :\n  (fun (x : M) \u21a6 r \u2022 x) =\n    ((TensorProduct.lid R M) \u2218\u2097 (rTensor M (toSpanSingleton R R r)) \u2218\u2097 (TensorProduct.lid R M).symm) :=\n  by ext;\n  simp\n    -- Hence `(r \u2022 \u00b7) : M \u2192 M` is also injective",
          "proofState": 36,
          "pos": {
            "line": 45,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b3 : CommRing R\nM : Type v\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nr : R\nhr : r \u2208 R\u2070\ninst\u271d : Flat R M\nh : Function.Injective \u21d1(rTensor M (toSpanSingleton R R r))\n\u22a2 IsSMulRegular M r",
          "endPos": {
            "line": 47,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext",
          "proofState": 37,
          "pos": {
            "line": 47,
            "column": 48
          },
          "goals": "R : Type u\ninst\u271d\u00b3 : CommRing R\nM : Type v\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nr : R\nhr : r \u2208 R\u2070\ninst\u271d : Flat R M\nh : Function.Injective \u21d1(rTensor M (toSpanSingleton R R r))\n\u22a2 (fun x => r \u2022 x) = \u21d1(\u2191(TensorProduct.lid R M) \u2218\u2097 rTensor M (toSpanSingleton R R r) \u2218\u2097 \u2191(TensorProduct.lid R M).symm)",
          "endPos": {
            "line": 47,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "NonAssocSemiring.toMulZeroOneClass",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "True",
            "LinearEquiv",
            "MulOneClass.toOne",
            "eq_self",
            "TensorProduct.lid",
            "of_eq_true",
            "LinearEquiv.instEquivLike",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "EquivLike.toFunLike",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp\n  -- Hence `(r \u2022 \u00b7) : M \u2192 M` is also injective",
          "proofState": 38,
          "pos": {
            "line": 47,
            "column": 53
          },
          "goals": "case h\nR : Type u\ninst\u271d\u00b3 : CommRing R\nM : Type v\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nr : R\nhr : r \u2208 R\u2070\ninst\u271d : Flat R M\nh : Function.Injective \u21d1(rTensor M (toSpanSingleton R R r))\nx\u271d : M\n\u22a2 r \u2022 x\u271d = (\u2191(TensorProduct.lid R M) \u2218\u2097 rTensor M (toSpanSingleton R R r) \u2218\u2097 \u2191(TensorProduct.lid R M).symm) x\u271d",
          "endPos": {
            "line": 47,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "instHSMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "id",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "AddZeroClass.toZero",
            "IsSMulRegular",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "Function.Injective",
            "MulZeroOneClass.toMulZeroClass",
            "MulActionWithZero.toSMulWithZero",
            "Eq",
            "IsSMulRegular.eq_1",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [IsSMulRegular, h2]",
          "proofState": 39,
          "pos": {
            "line": 49,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b3 : CommRing R\nM : Type v\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nr : R\nhr : r \u2208 R\u2070\ninst\u271d : Flat R M\nh : Function.Injective \u21d1(rTensor M (toSpanSingleton R R r))\nh2 :\n  (fun x => r \u2022 x) = \u21d1(\u2191(TensorProduct.lid R M) \u2218\u2097 rTensor M (toSpanSingleton R R r) \u2218\u2097 \u2191(TensorProduct.lid R M).symm)\n\u22a2 IsSMulRegular M r",
          "endPos": {
            "line": 49,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearEquiv.symm",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "_auxLemma.1",
            "LinearMap.instFunLike",
            "Function.comp",
            "Mathlib.Logic.Function.Basic._auxLemma.4",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "True",
            "LinearEquiv",
            "TensorProduct.lid",
            "of_eq_true",
            "LinearEquiv.instEquivLike",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Function.Injective",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LinearMap.toSpanSingleton",
            "Eq.trans",
            "EquivLike.toFunLike",
            "TensorProduct.instModule",
            "LinearMap.rTensor"
          ],
          "tactic": "simp [h, LinearEquiv.injective]",
          "proofState": 40,
          "pos": {
            "line": 50,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b3 : CommRing R\nM : Type v\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nr : R\nhr : r \u2208 R\u2070\ninst\u271d : Flat R M\nh : Function.Injective \u21d1(rTensor M (toSpanSingleton R R r))\nh2 :\n  (fun x => r \u2022 x) = \u21d1(\u2191(TensorProduct.lid R M) \u2218\u2097 rTensor M (toSpanSingleton R R r) \u2218\u2097 \u2191(TensorProduct.lid R M).symm)\n\u22a2 Function.Injective \u21d1(\u2191(TensorProduct.lid R M) \u2218\u2097 rTensor M (toSpanSingleton R R r) \u2218\u2097 \u2191(TensorProduct.lid R M).symm)",
          "endPos": {
            "line": 50,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "CompleteLattice.instOmegaCompletePartialOrder",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.torsion",
            "OrderBot.toBot",
            "Submodule.completeLattice",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "id",
            "Bot.bot",
            "LE.le",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "OmegaCompletePartialOrder.toPartialOrder",
            "propext",
            "Submodule.instOrderBot",
            "eq_bot_iff",
            "Eq"
          ],
          "tactic": "rw [eq_bot_iff]\n  -- indeed the definition of torsion means \"annihiliated by a nonzerodivisor\"",
          "proofState": 41,
          "pos": {
            "line": 55,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b2 : CommRing R\nM : Type v\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nhflat : Flat R M\n\u22a2 torsion R M = \u22a5",
          "endPos": {
            "line": 55,
            "column": 17
          }
        },
        {
          "usedConstants": [],
          "tactic": "rintro m\n  \u27e8\u27e8r, hr\u27e9, (h : r \u2022 m = 0)\u27e9\n      -- and we just showed that 0 is the only element with this property",
          "proofState": 42,
          "pos": {
            "line": 57,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b2 : CommRing R\nM : Type v\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nhflat : Flat R M\n\u22a2 torsion R M \u2264 \u22a5",
          "endPos": {
            "line": 57,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "instHSMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "smul_zero",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "NegZeroClass.toZero",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero",
            "Module.Flat.isSMulRegular_of_nonZeroDivisors"
          ],
          "tactic": "exact\n  isSMulRegular_of_nonZeroDivisors hr\n    (by simp [h])\n      -- should be elsewhere",
          "proofState": 43,
          "pos": {
            "line": 59,
            "column": 2
          },
          "goals": "case intro.mk\nR : Type u\ninst\u271d\u00b2 : CommRing R\nM : Type v\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nhflat : Flat R M\nm : M\nr : R\nhr : r \u2208 R\u2070\nh : r \u2022 m = 0\n\u22a2 m \u2208 \u22a5",
          "endPos": {
            "line": 59,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "instHSMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "smul_zero",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "NegZeroClass.toZero",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [h]",
          "proofState": 44,
          "pos": {
            "line": 59,
            "column": 48
          },
          "goals": "R : Type u\ninst\u271d\u00b2 : CommRing R\nM : Type v\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nhflat : Flat R M\nm : M\nr : R\nhr : r \u2208 R\u2070\nh : r \u2022 m = 0\n\u22a2 (fun x => r \u2022 x) m = (fun x => r \u2022 x) 0",
          "endPos": {
            "line": 59,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [LinearMap.ker_eq_bot] at h1",
          "proofState": 45,
          "pos": {
            "line": 79,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2076 : AddCommGroup M\u271d\ninst\u271d\u2075 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\nM' : Type u_3\ninst\u271d\u00b9 : AddCommGroup M'\ninst\u271d : Module R M'\n\u03c6 : M' \u2192\u2097[R] M\nh1 : LinearMap.ker \u03c6 = \u22a5\nh2 : Surjective \u21d1\u03c6\nm : M'\n\u22a2 (fun m' => \u22ef.choose) (\u03c6.toFun m) = m",
          "endPos": {
            "line": 79,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Exists.choose_spec",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "LinearMap.instFunLike",
            "LinearMap.toAddHom",
            "LinearMap",
            "CommRing.toCommSemiring",
            "Exists.choose",
            "AddCommSemigroup.toAddCommMagma",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "AddCommMagma.toAdd"
          ],
          "tactic": "exact h1 <| (h2 (\u03c6 m)).choose_spec",
          "proofState": 46,
          "pos": {
            "line": 80,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2077 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2076 : AddCommGroup M\u271d\ninst\u271d\u2075 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\nM' : Type u_3\ninst\u271d\u00b9 : AddCommGroup M'\ninst\u271d : Module R M'\n\u03c6 : M' \u2192\u2097[R] M\nh1 : Function.Injective \u21d1\u03c6\nh2 : Surjective \u21d1\u03c6\nm : M'\n\u22a2 (fun m' => \u22ef.choose) (\u03c6.toFun m) = m",
          "endPos": {
            "line": 80,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "Semiring.toModule",
            "CompleteLattice.instOmegaCompletePartialOrder",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "OrderBot.toBot",
            "Submodule.completeLattice",
            "PartialOrder.toPreorder",
            "LinearMap.ker",
            "LinearMap.instFunLike",
            "Preorder.toLE",
            "Membership.mem",
            "id",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "Bot.bot",
            "Submodule.module",
            "LE.le",
            "Ideal",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "Submodule.addCommGroup",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Submodule.setLike",
            "OmegaCompletePartialOrder.toPartialOrder",
            "propext",
            "Ideal.mulGeneratorOfIsPrincipal",
            "Submodule.instOrderBot",
            "CommRing.toRing",
            "eq_bot_iff",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "SetLike.instMembership"
          ],
          "tactic": "rw [eq_bot_iff]",
          "proofState": 47,
          "pos": {
            "line": 90,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\n\u22a2 LinearMap.ker I.mulGeneratorOfIsPrincipal = \u22a5",
          "endPos": {
            "line": 90,
            "column": 19
          }
        },
        {
          "usedConstants": [],
          "tactic": "intro m h",
          "proofState": 48,
          "pos": {
            "line": 91,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\n\u22a2 LinearMap.ker I.mulGeneratorOfIsPrincipal \u2264 \u22a5",
          "endPos": {
            "line": 91,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Semiring.toModule",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.ker",
            "LinearMap.instFunLike",
            "Membership.mem",
            "Eq.mp",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "Submodule.module",
            "Ideal",
            "LinearMap",
            "LinearMap.mem_ker",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Submodule.addCommGroup",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "propext",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "Ideal.mulGeneratorOfIsPrincipal",
            "CommRing.toRing",
            "OfNat.ofNat",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "SetLike.instMembership"
          ],
          "tactic": "rw [LinearMap.mem_ker] at h",
          "proofState": 49,
          "pos": {
            "line": 92,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\nm : R\nh : m \u2208 LinearMap.ker I.mulGeneratorOfIsPrincipal\n\u22a2 m \u2208 \u22a5",
          "endPos": {
            "line": 92,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Submodule.toAddSubmonoid",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "Membership.mem",
            "Subtype",
            "AddSubmonoid",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "Iff.mp",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Ideal.mulGeneratorOfIsPrincipal.proof_1",
            "AddCommMonoid.toAddMonoid",
            "OfNat.ofNat",
            "AddSubmonoid.mk_eq_zero",
            "AddSubmonoid.instSetLike",
            "AddSubmonoid.zero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "SetLike.instMembership",
            "instHMul"
          ],
          "tactic": "apply(AddSubmonoid.mk_eq_zero _).mp at h",
          "proofState": 50,
          "pos": {
            "line": 93,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\nm : R\nh : I.mulGeneratorOfIsPrincipal m = 0\n\u22a2 m \u2208 \u22a5",
          "endPos": {
            "line": 93,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Ideal.mem_bot",
            "Eq.mpr",
            "Submodule",
            "Semiring.toModule",
            "CompleteLattice.instOmegaCompletePartialOrder",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "OrderBot.toBot",
            "Submodule.completeLattice",
            "PartialOrder.toPreorder",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Membership.mem",
            "id",
            "Bot.bot",
            "Ideal",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Submodule.setLike",
            "OmegaCompletePartialOrder.toPartialOrder",
            "propext",
            "Zero.toOfNat0",
            "Submodule.instOrderBot",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "SetLike.instMembership",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [Ideal.mem_bot]",
          "proofState": 51,
          "pos": {
            "line": 94,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\nm : R\nh : m * Submodule.IsPrincipal.generator I = 0\n\u22a2 m \u2208 \u22a5",
          "endPos": {
            "line": 94,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "IsDomain.to_noZeroDivisors",
            "Semiring.toModule",
            "CommSemiring.toSemiring",
            "mt",
            "Bot.bot",
            "Ideal",
            "eq_zero_of_ne_zero_of_mul_right_eq_zero",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "refine eq_zero_of_ne_zero_of_mul_right_eq_zero (mt (fun h3 \u21a6 ?_) hI) h",
          "proofState": 52,
          "pos": {
            "line": 95,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\nm : R\nh : m * Submodule.IsPrincipal.generator I = 0\n\u22a2 m = 0",
          "endPos": {
            "line": 95,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "Semiring.toModule",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "id",
            "Bot.bot",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "Submodule.IsPrincipal.eq_bot_iff_generator_eq_zero",
            "propext",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq"
          ],
          "tactic": "rwa [Submodule.IsPrincipal.eq_bot_iff_generator_eq_zero I]",
          "proofState": 53,
          "pos": {
            "line": 96,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\nm : R\nh : m * Submodule.IsPrincipal.generator I = 0\nh3 : Submodule.IsPrincipal.generator I = 0\n\u22a2 I = \u22a5",
          "endPos": {
            "line": 96,
            "column": 62
          }
        },
        {
          "usedConstants": [
            "Semiring.toModule",
            "CommSemiring.toSemiring",
            "Membership.mem",
            "Subtype",
            "Ideal",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Submodule.setLike",
            "Semiring.toNonAssocSemiring",
            "SetLike.instMembership"
          ],
          "tactic": "rintro \u27e8i, hi\u27e9",
          "proofState": 54,
          "pos": {
            "line": 98,
            "column": 4
          },
          "goals": "R\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\n\u22a2 Surjective \u21d1I.mulGeneratorOfIsPrincipal",
          "endPos": {
            "line": 98,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "instHSMul",
            "Semiring.toModule",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "Exists",
            "Eq.mp",
            "Submodule.IsPrincipal.mem_iff_eq_smul_generator",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "propext",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "MulActionWithZero.toSMulWithZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "SetLike.instMembership",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [Submodule.IsPrincipal.mem_iff_eq_smul_generator] at hi",
          "proofState": 55,
          "pos": {
            "line": 99,
            "column": 4
          },
          "goals": "case mk\nR\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\ni : R\nhi : i \u2208 I\n\u22a2 \u2203 a, I.mulGeneratorOfIsPrincipal a = \u27e8i, hi\u27e9",
          "endPos": {
            "line": 99,
            "column": 62
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8s, rfl\u27e9 := hi",
          "proofState": 56,
          "pos": {
            "line": 100,
            "column": 4
          },
          "goals": "case mk\nR\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\ni : R\nhi\u271d : i \u2208 I\nhi : \u2203 s, i = s \u2022 Submodule.IsPrincipal.generator I\n\u22a2 \u2203 a, I.mulGeneratorOfIsPrincipal a = \u27e8i, hi\u271d\u27e9",
          "endPos": {
            "line": 100,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "instHSMul",
            "Semiring.toModule",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "Subtype",
            "Submodule.module",
            "Ideal",
            "LinearMap",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Submodule.addCommGroup",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "Exists.intro",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "Ideal.mulGeneratorOfIsPrincipal",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "SetLike.instMembership",
            "rfl",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "exact \u27e8s, rfl\u27e9",
          "proofState": 57,
          "pos": {
            "line": 101,
            "column": 4
          },
          "goals": "case mk.intro\nR\u271d : Type u\ninst\u271d\u2076 : CommRing R\u271d\nM\u271d : Type v\ninst\u271d\u2075 : AddCommGroup M\u271d\ninst\u271d\u2074 : Module R\u271d M\u271d\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\nI : Ideal R\ninst\u271d : IsDomain R\nhprinc : Submodule.IsPrincipal I\nhI : I \u2260 \u22a5\ns : R\nhi : s \u2022 Submodule.IsPrincipal.generator I \u2208 I\n\u22a2 \u2203 a, I.mulGeneratorOfIsPrincipal a = \u27e8s \u2022 Submodule.IsPrincipal.generator I, hi\u27e9",
          "endPos": {
            "line": 101,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "LinearMap.ext_ring"
          ],
          "tactic": "ext",
          "proofState": 58,
          "pos": {
            "line": 111,
            "column": 2
          },
          "goals": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nI : Ideal R\nh : I \u2260 \u22a5\n\u22a2 Submodule.subtype I \u2218\u2097 \u2191(Ideal.isoBaseOfIsPrincipal h) = (LinearMap.mul R R) (Submodule.IsPrincipal.generator I)",
          "endPos": {
            "line": 111,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "Semiring.toModule",
            "HMul.hMul",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "NonAssocSemiring.toMulZeroOneClass",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "mul_one",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "IsPrincipalIdealRing.principal",
            "one_mul",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp [Ideal.isoBaseOfIsPrincipal, LinearMap.EquivOfKerEqBotOfSurjective, Ideal.mulGeneratorOfIsPrincipal]",
          "proofState": 59,
          "pos": {
            "line": 112,
            "column": 2
          },
          "goals": "case h\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nI : Ideal R\nh : I \u2260 \u22a5\n\u22a2 (Submodule.subtype I \u2218\u2097 \u2191(Ideal.isoBaseOfIsPrincipal h)) 1 =\n    ((LinearMap.mul R R) (Submodule.IsPrincipal.generator I)) 1",
          "endPos": {
            "line": 113,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "TensorProduct.AlgebraTensorModule.curry_injective"
          ],
          "tactic": "ext x",
          "proofState": 60,
          "pos": {
            "line": 117,
            "column": 2
          },
          "goals": "R : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsPrincipalIdealRing R\ny : R\n\u22a2 lift (lsmul R M \u2218\u2097 (LinearMap.mul R R) y) = (lsmul R M) y \u2218\u2097 lift (lsmul R M)",
          "endPos": {
            "line": 117,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "instHSMul",
            "Semiring.toModule",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LinearMap.lsmul",
            "NonAssocSemiring.toMulZeroOneClass",
            "MulAction.toSMul",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "one_smul",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "mul_one",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 61,
          "pos": {
            "line": 118,
            "column": 2
          },
          "goals": "case a.h.h\nR : Type u_1\ninst\u271d\u00b3 : CommRing R\nM : Type u_2\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsPrincipalIdealRing R\ny : R\nx : M\n\u22a2 ((AlgebraTensorModule.curry (lift (lsmul R M \u2218\u2097 (LinearMap.mul R R) y))) 1) x =\n    ((AlgebraTensorModule.curry ((lsmul R M) y \u2218\u2097 lift (lsmul R M))) 1) x",
          "endPos": {
            "line": 118,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.torsion",
            "Bot.bot",
            "Module.Flat",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "Iff.intro",
            "Eq"
          ],
          "tactic": "refine\n  \u27e8?_, ?_\u27e9\n    -- one way is true in general",
          "proofState": 62,
          "pos": {
            "line": 124,
            "column": 2
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\n\u22a2 Flat R M \u2194 torsion R M = \u22a5",
          "endPos": {
            "line": 124,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Module.Flat.torsion_eq_bot"
          ],
          "tactic": "apply torsion_eq_bot",
          "proofState": 63,
          "pos": {
            "line": 126,
            "column": 4
          },
          "goals": "case refine_1\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\n\u22a2 Flat R M \u2192 torsion R M = \u22a5",
          "endPos": {
            "line": 126,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.torsion",
            "Bot.bot",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "Eq"
          ],
          "tactic": "intro htors",
          "proofState": 64,
          "pos": {
            "line": 128,
            "column": 4
          },
          "goals": "case refine_2\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\n\u22a2 torsion R M = \u22a5 \u2192 Flat R M",
          "endPos": {
            "line": 128,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "Semiring.toModule",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.addCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "LinearMap.lsmul",
            "id",
            "Subtype",
            "Submodule.module",
            "Ideal",
            "LinearMap.module",
            "LinearMap",
            "Module.Flat",
            "smulCommClass_self",
            "Ideal.FG",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "LinearMap.comp",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "Module.Flat.iff_lift_lsmul_comp_subtype_injective",
            "propext",
            "Submodule.subtype",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "Function.Injective",
            "TensorProduct.lift",
            "RingHom.id",
            "RingHomCompTriple.ids",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "SetLike.instMembership",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [iff_lift_lsmul_comp_subtype_injective]",
          "proofState": 65,
          "pos": {
            "line": 130,
            "column": 4
          },
          "goals": "case refine_2\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\n\u22a2 Flat R M",
          "endPos": {
            "line": 130,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "Ideal",
            "CommRing.toCommSemiring"
          ],
          "tactic": "rintro I\n  -\n      -- If I = 0 this is obvious because I \u2297 M is a subsingleton (i.e. has \u22641 element)",
          "proofState": 66,
          "pos": {
            "line": 131,
            "column": 4
          },
          "goals": "case refine_2\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\n\u22a2 \u2200 \u2983I : Ideal R\u2984, I.FG \u2192 Function.Injective \u21d1(lift (lsmul R M \u2218\u2097 Submodule.subtype I))",
          "endPos": {
            "line": 131,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Bot.bot",
            "eq_or_ne"
          ],
          "tactic": "obtain (rfl | h) := eq_or_ne I \u22a5",
          "proofState": 67,
          "pos": {
            "line": 133,
            "column": 4
          },
          "goals": "case refine_2\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\nI : Ideal R\n\u22a2 Function.Injective \u21d1(lift (lsmul R M \u2218\u2097 Submodule.subtype I))",
          "endPos": {
            "line": 133,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Semiring.toModule",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.addCommMonoid",
            "Membership.mem",
            "Subtype",
            "Bot.bot",
            "Submodule.module",
            "Ideal",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Submodule.setLike",
            "TensorProduct",
            "Semiring.toNonAssocSemiring",
            "SetLike.instMembership"
          ],
          "tactic": "rintro x y -",
          "proofState": 68,
          "pos": {
            "line": 134,
            "column": 6
          },
          "goals": "case refine_2.inl\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\n\u22a2 Function.Injective \u21d1(lift (lsmul R M \u2218\u2097 Submodule.subtype \u22a5))",
          "endPos": {
            "line": 134,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "Subsingleton.elim"
          ],
          "tactic": "apply Subsingleton.elim",
          "proofState": 69,
          "pos": {
            "line": 135,
            "column": 6
          },
          "goals": "case refine_2.inl\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\nx y : \u21a5\u22a5 \u2297[R] M\n\u22a2 x = y",
          "endPos": {
            "line": 135,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Ideal.isoBaseOfIsPrincipal",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Submodule",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.addCommMonoid",
            "TensorProduct.addCommMonoid",
            "LinearEquiv.rTensor",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LinearEquiv.surjective",
            "Membership.mem",
            "LinearMap.lsmul",
            "Subtype",
            "Submodule.module",
            "Ideal",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "LinearMap.comp",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "LinearEquiv",
            "Submodule.subtype",
            "LinearEquiv.instEquivLike",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.lift",
            "RingHom.id",
            "RingHomCompTriple.ids",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "IsPrincipalIdealRing.principal",
            "SetLike.instMembership",
            "Function.Injective.of_comp_right",
            "EquivLike.toFunLike",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "apply Function.Injective.of_comp_right _ (LinearEquiv.rTensor M (Ideal.isoBaseOfIsPrincipal h)).surjective",
          "proofState": 70,
          "pos": {
            "line": 137,
            "column": 6
          },
          "goals": "case refine_2.inr\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\nI : Ideal R\nh : I \u2260 \u22a5\n\u22a2 Function.Injective \u21d1(lift (lsmul R M \u2218\u2097 Submodule.subtype I))",
          "endPos": {
            "line": 138,
            "column": 73
          }
        },
        {
          "usedConstants": [
            "Ideal.isoBaseOfIsPrincipal",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Submodule",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.addCommMonoid",
            "TensorProduct.addCommMonoid",
            "LinearEquiv.rTensor",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "Function.comp",
            "Membership.mem",
            "LinearMap.lsmul",
            "id",
            "Subtype",
            "Submodule.module",
            "Ideal",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "LinearMap.comp",
            "CommRing.toCommSemiring",
            "LinearEquiv.toLinearMap",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "LinearEquiv",
            "Submodule.subtype",
            "LinearEquiv.instEquivLike",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "LinearEquiv.coe_toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Function.Injective",
            "Eq.symm",
            "TensorProduct.lift",
            "RingHom.id",
            "RingHomCompTriple.ids",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "IsPrincipalIdealRing.principal",
            "SetLike.instMembership",
            "EquivLike.toFunLike",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 LinearEquiv.coe_toLinearMap, \u2190 LinearMap.coe_comp, LinearEquiv.coe_rTensor, rTensor, lift_comp_map,\n  LinearMap.compl\u2082_id, LinearMap.comp_assoc, extracted_1, extracted_2, LinearMap.coe_comp]",
          "proofState": 71,
          "pos": {
            "line": 139,
            "column": 6
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\nI : Ideal R\nh : I \u2260 \u22a5\n\u22a2 Function.Injective\n    (\u21d1(lift (lsmul R M \u2218\u2097 Submodule.subtype I)) \u2218 \u21d1(LinearEquiv.rTensor M (Ideal.isoBaseOfIsPrincipal h)))",
          "endPos": {
            "line": 141,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [\u2190 noZeroSMulDivisors_iff_torsion_eq_bot] at htors",
          "proofState": 72,
          "pos": {
            "line": 142,
            "column": 6
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : torsion R M = \u22a5\nI : Ideal R\nh : I \u2260 \u22a5\n\u22a2 Function.Injective (\u21d1((lsmul R M) (IsPrincipal.generator I)) \u2218 \u21d1(lift (lsmul R M)))",
          "endPos": {
            "line": 142,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Function.comp",
            "LinearMap.lsmul",
            "Ne",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "Zero.toOfNat0",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "Function.Injective",
            "OfNat.ofNat",
            "TensorProduct.lift",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "IsPrincipalIdealRing.principal",
            "letFun",
            "MulZeroClass.toZero",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have : IsPrincipal.generator I \u2260 0 := by rwa [ne_eq, \u2190 IsPrincipal.eq_bot_iff_generator_eq_zero]",
          "proofState": 73,
          "pos": {
            "line": 143,
            "column": 6
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : NoZeroSMulDivisors R M\nI : Ideal R\nh : I \u2260 \u22a5\n\u22a2 Function.Injective (\u21d1((lsmul R M) (IsPrincipal.generator I)) \u2218 \u21d1(lift (lsmul R M)))",
          "endPos": {
            "line": 144,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "Ne",
            "ne_eq",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "IsPrincipalIdealRing.principal",
            "Not",
            "MulZeroClass.toZero"
          ],
          "tactic": "rwa [ne_eq, \u2190 IsPrincipal.eq_bot_iff_generator_eq_zero]",
          "proofState": 74,
          "pos": {
            "line": 144,
            "column": 8
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : NoZeroSMulDivisors R M\nI : Ideal R\nh : I \u2260 \u22a5\n\u22a2 IsPrincipal.generator I \u2260 0",
          "endPos": {
            "line": 144,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LinearMap.lsmul",
            "LinearMap.lsmul_injective",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.IsPrincipal.generator",
            "CommRing.toCommSemiring",
            "Function.Injective.comp",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.lift",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "IsPrincipalIdealRing.principal",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "refine Function.Injective.comp (LinearMap.lsmul_injective this) ?_",
          "proofState": 75,
          "pos": {
            "line": 145,
            "column": 6
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : NoZeroSMulDivisors R M\nI : Ideal R\nh : I \u2260 \u22a5\nthis : IsPrincipal.generator I \u2260 0\n\u22a2 Function.Injective (\u21d1((lsmul R M) (IsPrincipal.generator I)) \u2218 \u21d1(lift (lsmul R M)))",
          "endPos": {
            "line": 145,
            "column": 72
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "LinearEquiv.symm",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "LinearMap.instFunLike",
            "Function.comp",
            "LinearMap.lsmul",
            "id",
            "Equiv",
            "Equiv.injective_comp",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "LinearEquiv.toEquiv",
            "propext",
            "TensorProduct.lid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Function.Injective",
            "Eq.symm",
            "TensorProduct.lift",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "TensorProduct.instModule"
          ],
          "tactic": "rw [\u2190 Equiv.injective_comp (TensorProduct.lid R M).symm.toEquiv]",
          "proofState": 76,
          "pos": {
            "line": 146,
            "column": 6
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : NoZeroSMulDivisors R M\nI : Ideal R\nh : I \u2260 \u22a5\nthis : IsPrincipal.generator I \u2260 0\n\u22a2 Function.Injective \u21d1(lift (lsmul R M))",
          "endPos": {
            "line": 146,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "LinearEquiv.symm",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "LinearMap.instFunLike",
            "Function.comp",
            "LinearMap.lsmul",
            "id",
            "Equiv",
            "LinearMap",
            "Function.injective_id",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "LinearEquiv.toEquiv",
            "TensorProduct.lid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Function.Injective",
            "TensorProduct.lift",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "TensorProduct.instModule"
          ],
          "tactic": "convert Function.injective_id",
          "proofState": 77,
          "pos": {
            "line": 147,
            "column": 6
          },
          "goals": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : NoZeroSMulDivisors R M\nI : Ideal R\nh : I \u2260 \u22a5\nthis : IsPrincipal.generator I \u2260 0\n\u22a2 Function.Injective (\u21d1(lift (lsmul R M)) \u2218 \u21d1(TensorProduct.lid R M).symm.toEquiv)",
          "endPos": {
            "line": 147,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext x",
          "proofState": 78,
          "pos": {
            "line": 148,
            "column": 6
          },
          "goals": "case h.e'_3\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : NoZeroSMulDivisors R M\nI : Ideal R\nh : I \u2260 \u22a5\nthis : IsPrincipal.generator I \u2260 0\n\u22a2 \u21d1(lift (lsmul R M)) \u2218 \u21d1(TensorProduct.lid R M).symm.toEquiv = id",
          "endPos": {
            "line": 148,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "instHSMul",
            "Monoid.toMulOneClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "MulAction.toSMul",
            "one_smul",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "AddCommMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Eq",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 79,
          "pos": {
            "line": 149,
            "column": 6
          },
          "goals": "case h.e'_3.h\nR : Type u_1\ninst\u271d\u2074 : CommRing R\nM : Type u_2\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : IsPrincipalIdealRing R\ninst\u271d : IsDomain R\nhtors : NoZeroSMulDivisors R M\nI : Ideal R\nh : I \u2260 \u22a5\nthis : IsPrincipal.generator I \u2260 0\nx : M\n\u22a2 (\u21d1(lift (lsmul R M)) \u2218 \u21d1(TensorProduct.lid R M).symm.toEquiv) x = id x",
          "endPos": {
            "line": 149,
            "column": 10
          }
        }
      ],
      "env": 7
    }
  },
  {
    "file": "FLT/Hard/Results.lean",
    "output": {
      "env": 8
    }
  },
  {
    "file": "FLT/Basic/Reductions.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "FermatLastTheorem"
          ],
          "tactic": "intro h\u2081 a b c n h\u2082",
          "proofState": 82,
          "pos": {
            "line": 49,
            "column": 2
          },
          "goals": "\u22a2 FermatLastTheorem \u2192 \u2200 (a b c : \u2115+), \u2200 n > 2, a ^ n + b ^ n \u2260 c ^ n",
          "endPos": {
            "line": 49,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "specialize h\u2081 n h\u2082 a b c (by simp) (by simp) (by simp)",
          "proofState": 83,
          "pos": {
            "line": 50,
            "column": 2
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 a ^ n + b ^ n \u2260 c ^ n",
          "endPos": {
            "line": 50,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 84,
          "pos": {
            "line": 50,
            "column": 31
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 \u2191a \u2260 0",
          "endPos": {
            "line": 50,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 85,
          "pos": {
            "line": 50,
            "column": 41
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 \u2191b \u2260 0",
          "endPos": {
            "line": 50,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 86,
          "pos": {
            "line": 50,
            "column": 51
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 \u2191c \u2260 0",
          "endPos": {
            "line": 50,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "OrderedCommMonoid.toCommMonoid",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "instPNatLinearOrderedCancelCommMonoid",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "instPNatAdd",
            "Monoid.toNatPow",
            "id",
            "Ne",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "instHPow",
            "PNat"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 87,
          "pos": {
            "line": 51,
            "column": 2
          },
          "goals": "a b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\nh\u2081 : \u2191a ^ n + \u2191b ^ n \u2260 \u2191c ^ n\n\u22a2 a ^ n + b ^ n \u2260 c ^ n",
          "endPos": {
            "line": 51,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "FermatLastTheorem.of_odd_primes"
          ],
          "tactic": "apply FermatLastTheorem.of_odd_primes",
          "proofState": 88,
          "pos": {
            "line": 57,
            "column": 2
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\n\u22a2 FermatLastTheorem",
          "endPos": {
            "line": 57,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Nat"
          ],
          "tactic": "intro p pp p_odd",
          "proofState": 89,
          "pos": {
            "line": 58,
            "column": 2
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\n\u22a2 \u2200 (p : \u2115), Nat.Prime p \u2192 Odd p \u2192 FermatLastTheoremFor p",
          "endPos": {
            "line": 58,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "dite",
            "Nat",
            "FermatLastTheoremFor",
            "OfNat.ofNat",
            "Not",
            "Nat.decLe"
          ],
          "tactic": "if hp5 : 5 \u2264 p then exact H _ hp5 pp\nelse\n  have hp2 := pp.two_le\n  interval_cases p\n  \u00b7 contradiction\n  \u00b7 exact fermatLastTheoremThree\n  \u00b7\n    contradiction\n      /-\n      \n      We continue with the reduction of Fermat's Last Theorem.\n      \n      -/",
          "proofState": 90,
          "pos": {
            "line": 59,
            "column": 2
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 66,
            "column": 19
          }
        },
        {
          "usedConstants": [],
          "tactic": "exact H _ hp5 pp",
          "proofState": 91,
          "pos": {
            "line": 60,
            "column": 4
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\nhp5 : 5 \u2264 p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 60,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "Nat",
            "FermatLastTheoremFor",
            "Nat.Prime.two_le",
            "OfNat.ofNat",
            "letFun"
          ],
          "tactic": "have hp2 := pp.two_le",
          "proofState": 92,
          "pos": {
            "line": 62,
            "column": 4
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\nhp5 : \u00ac5 \u2264 p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 62,
            "column": 25
          }
        },
        {
          "usedConstants": [],
          "tactic": "interval_cases p",
          "proofState": 93,
          "pos": {
            "line": 63,
            "column": 4
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\nhp5 : \u00ac5 \u2264 p\nhp2 : 2 \u2264 p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 63,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "Odd",
            "instOfNatNat",
            "absurd",
            "Nat",
            "FermatLastTheoremFor",
            "Bool",
            "Nat.instSemiring",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Nat.instDecidablePredOdd",
            "of_decide_eq_false"
          ],
          "tactic": "contradiction",
          "proofState": 94,
          "pos": {
            "line": 64,
            "column": 6
          },
          "goals": "case \u00ab2\u00bb\nH : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime 2\np_odd : Odd 2\nhp5 : \u00ac5 \u2264 2\nhp2 : 2 \u2264 2\n\u22a2 FermatLastTheoremFor 2",
          "endPos": {
            "line": 64,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "fermatLastTheoremThree"
          ],
          "tactic": "exact fermatLastTheoremThree",
          "proofState": 95,
          "pos": {
            "line": 65,
            "column": 6
          },
          "goals": "case \u00ab3\u00bb\nH : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime 3\np_odd : Odd 3\nhp5 : \u00ac5 \u2264 3\nhp2 : 2 \u2264 3\n\u22a2 FermatLastTheoremFor 3",
          "endPos": {
            "line": 65,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "Nat.Prime",
            "instOfNatNat",
            "absurd",
            "Nat",
            "FermatLastTheoremFor",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Nat.decidablePrime",
            "of_decide_eq_false"
          ],
          "tactic": "contradiction\n  /-\n  \n  We continue with the reduction of Fermat's Last Theorem.\n  \n  -/",
          "proofState": 96,
          "pos": {
            "line": 66,
            "column": 6
          },
          "goals": "case \u00ab4\u00bb\nH : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime 4\np_odd : Odd 4\nhp5 : \u00ac5 \u2264 4\nhp2 : 2 \u2264 4\n\u22a2 FermatLastTheoremFor 4",
          "endPos": {
            "line": 66,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega",
          "proofState": 97,
          "pos": {
            "line": 98,
            "column": 62
          },
          "goals": "P : FreyPackage\n\u22a2 0 < 5",
          "endPos": {
            "line": 98,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "Int",
            "Int.instDvd",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "Eq",
            "letFun"
          ],
          "tactic": "have foo : gcd a b \u2223 gcd a c := by\n  apply dvd_gcd (gcd_dvd_left a b)\n  rw [\u2190 Int.pow_dvd_pow_iff hp.ne', \u2190 h]\n  apply dvd_add <;> rw [Int.pow_dvd_pow_iff hp.ne']\n  \u00b7 exact gcd_dvd_left a b\n  \u00b7 exact gcd_dvd_right a b",
          "proofState": 98,
          "pos": {
            "line": 103,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 108,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "apply dvd_gcd (gcd_dvd_left a b)",
          "proofState": 99,
          "pos": {
            "line": 104,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 gcd a c",
          "endPos": {
            "line": 104,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 Int.pow_dvd_pow_iff hp.ne', \u2190 h]",
          "proofState": 100,
          "pos": {
            "line": 105,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 c",
          "endPos": {
            "line": 105,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "dvd_add"
          ],
          "tactic": "apply dvd_add",
          "proofState": 101,
          "pos": {
            "line": 106,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b ^ p \u2223 a ^ p + b ^ p",
          "endPos": {
            "line": 106,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 102,
          "pos": {
            "line": 106,
            "column": 22
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b ^ p \u2223 a ^ p",
          "endPos": {
            "line": 106,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 103,
          "pos": {
            "line": 106,
            "column": 22
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b ^ p \u2223 b ^ p",
          "endPos": {
            "line": 106,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "exact gcd_dvd_left a b",
          "proofState": 104,
          "pos": {
            "line": 107,
            "column": 6
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 a",
          "endPos": {
            "line": 107,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_right"
          ],
          "tactic": "exact gcd_dvd_right a b",
          "proofState": 105,
          "pos": {
            "line": 108,
            "column": 6
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 b",
          "endPos": {
            "line": 108,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "Int",
            "Int.instDvd",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "Eq",
            "letFun"
          ],
          "tactic": "have bar : gcd a c \u2223 gcd a b := by\n  apply dvd_gcd (gcd_dvd_left a c)\n  have h2 : b ^ p = c ^ p - a ^ p := eq_sub_of_add_eq' h\n  rw [\u2190 Int.pow_dvd_pow_iff hp.ne', h2]\n  apply dvd_add\n  \u00b7 rw [Int.pow_dvd_pow_iff hp.ne']\n    exact gcd_dvd_right a c\n  \u00b7 rw [dvd_neg, Int.pow_dvd_pow_iff hp.ne']\n    exact gcd_dvd_left a c",
          "proofState": 106,
          "pos": {
            "line": 109,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 117,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "apply dvd_gcd (gcd_dvd_left a c)",
          "proofState": 107,
          "pos": {
            "line": 110,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\n\u22a2 gcd a c \u2223 gcd a b",
          "endPos": {
            "line": 110,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Dvd.dvd",
            "semigroupDvd",
            "HSub.hSub",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "eq_sub_of_add_eq'",
            "Int.instMonoid",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "Int.instCancelCommMonoidWithZero",
            "Int.instSub",
            "instHPow",
            "Eq",
            "letFun"
          ],
          "tactic": "have h2 : b ^ p = c ^ p - a ^ p := eq_sub_of_add_eq' h",
          "proofState": 108,
          "pos": {
            "line": 111,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\n\u22a2 gcd a c \u2223 b",
          "endPos": {
            "line": 111,
            "column": 58
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 Int.pow_dvd_pow_iff hp.ne', h2]",
          "proofState": 109,
          "pos": {
            "line": 112,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c \u2223 b",
          "endPos": {
            "line": 112,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "dvd_add"
          ],
          "tactic": "apply dvd_add",
          "proofState": 110,
          "pos": {
            "line": 113,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c ^ p \u2223 c ^ p - a ^ p",
          "endPos": {
            "line": 113,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 111,
          "pos": {
            "line": 114,
            "column": 6
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c ^ p \u2223 c ^ p",
          "endPos": {
            "line": 114,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_right"
          ],
          "tactic": "exact gcd_dvd_right a c",
          "proofState": 112,
          "pos": {
            "line": 115,
            "column": 6
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c \u2223 c",
          "endPos": {
            "line": 115,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Semigroup.toMul",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Int.instSemigroup",
            "Monoid.toNatPow",
            "id",
            "Int",
            "Int.instMonoid",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "dvd_neg",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "InvolutiveNeg.toNeg",
            "Eq",
            "Neg.neg"
          ],
          "tactic": "rw [dvd_neg, Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 113,
          "pos": {
            "line": 116,
            "column": 6
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c ^ p \u2223 -a ^ p",
          "endPos": {
            "line": 116,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "exact gcd_dvd_left a c",
          "proofState": 114,
          "pos": {
            "line": 117,
            "column": 6
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c \u2223 a",
          "endPos": {
            "line": 117,
            "column": 28
          }
        },
        {
          "usedConstants": [],
          "tactic": "change _ \u2223 (Int.gcd a c : \u2124) at foo",
          "proofState": 115,
          "pos": {
            "line": 118,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nbar : gcd a c \u2223 gcd a b\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 118,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Dvd.dvd",
            "Int.ofNat_dvd",
            "Int",
            "Nat.cast",
            "Int.instDvd",
            "Nat.instDvd",
            "Nat",
            "Iff.mp",
            "instNatCastInt"
          ],
          "tactic": "apply Int.ofNat_dvd.1at bar",
          "proofState": 116,
          "pos": {
            "line": 119,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nbar : gcd a c \u2223 gcd a b\nfoo : gcd a b \u2223 \u2191(a.gcd c)\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 119,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Dvd.dvd",
            "Int.ofNat_dvd",
            "Int",
            "Nat.cast",
            "Int.instDvd",
            "Nat.instDvd",
            "Nat",
            "Iff.mp",
            "instNatCastInt"
          ],
          "tactic": "apply Int.ofNat_dvd.1at foo",
          "proofState": 117,
          "pos": {
            "line": 120,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 \u2191(a.gcd c)\nbar : a.gcd c \u2223 a.gcd b\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 120,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Int",
            "Nat.cast",
            "congr_arg",
            "Nat",
            "instNatCastInt",
            "Nat.dvd_antisymm"
          ],
          "tactic": "exact congr_arg ((\u2191) : \u2115 \u2192 \u2124) <| Nat.dvd_antisymm foo bar",
          "proofState": 118,
          "pos": {
            "line": 121,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nbar : a.gcd c \u2223 a.gcd b\nfoo : a.gcd b \u2223 a.gcd c\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 121,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "congrArg",
            "id",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "instOfNat",
            "FLT.FreyPackage.hFLT",
            "FLT.FreyPackage.hppos",
            "Int.instCancelCommMonoidWithZero",
            "FLT.FreyPackage.a",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 gcdab_eq_gcdac P.hppos P.hFLT, P.hgcdab]",
          "proofState": 119,
          "pos": {
            "line": 124,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 gcd P.a P.c = 1",
          "endPos": {
            "line": 124,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "congrArg",
            "id",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "instOfNat",
            "FLT.FreyPackage.hppos",
            "Int.instCancelCommMonoidWithZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 gcdab_eq_gcdac P.hppos, gcd_comm, P.hgcdab]",
          "proofState": 120,
          "pos": {
            "line": 127,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 gcd P.b P.c = 1",
          "endPos": {
            "line": 127,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "Monoid.toNatPow",
            "id",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "add_comm",
            "Int.instMonoid",
            "FLT.FreyPackage.c",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "Int.instAdd",
            "FLT.FreyPackage.a",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "Eq",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup"
          ],
          "tactic": "rw [add_comm]",
          "proofState": 121,
          "pos": {
            "line": 128,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.b ^ P.p + P.a ^ P.p = P.c ^ P.p",
          "endPos": {
            "line": 128,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "FLT.FreyPackage.hFLT"
          ],
          "tactic": "exact P.hFLT",
          "proofState": 122,
          "pos": {
            "line": 129,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.a ^ P.p + P.b ^ P.p = P.c ^ P.p",
          "endPos": {
            "line": 129,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Lean.Omega.Constraint.not_sat'_of_isImpossible",
            "of_decide_eq_true",
            "le_of_le_of_eq",
            "Lean.Omega.Constraint.mk",
            "Lean.Omega.Constraint.combine_sat'",
            "Odd",
            "HSub.hSub",
            "Lean.Omega.LinearCombo.eval",
            "Option.some",
            "Monoid.toNatPow",
            "id",
            "Nat.Prime.odd_of_ne_two",
            "instDecidableEqBool",
            "Int.instNegInt",
            "Int.sub_nonneg_of_le",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage",
            "Nat.cast",
            "Lean.Omega.Int.sub_congr",
            "List.cons",
            "Int.instMonoid",
            "Lean.Omega.LinearCombo",
            "Bool.true",
            "Option.none",
            "instHSub",
            "HPow.hPow",
            "Lean.Omega.LinearCombo.coordinate_eval_0",
            "instOfNat",
            "Lean.Omega.LinearCombo.mk",
            "Lean.Omega.Coeffs.ofList",
            "Nat",
            "Lean.Omega.Constraint.addEquality_sat",
            "Lean.Omega.LinearCombo.sub_eval",
            "Lean.Omega.LinearCombo.coordinate",
            "Bool",
            "Nonempty",
            "Nat.instSemiring",
            "Eq.refl",
            "Int.instSub",
            "Lean.Omega.Int.ofNat_le_of_le",
            "instNatCastInt",
            "instHPow",
            "Lean.Omega.Int.ofNat_congr",
            "OfNat.ofNat",
            "Eq.symm",
            "Lean.Omega.Constraint.addInequality_sat",
            "Decidable.decide",
            "Eq",
            "Lean.Omega.LinearCombo.instSub",
            "letFun",
            "Neg.neg",
            "Int.instLEInt",
            "Eq.trans",
            "Lean.Omega.Constraint.isImpossible",
            "Int.sub_eq_zero_of_eq",
            "List.nil"
          ],
          "tactic": "have p_odd :=\n  pp.odd_of_ne_two\n    (by omega)\n      -- First, show that we can make a,b coprime by dividing through by gcd a b",
          "proofState": 123,
          "pos": {
            "line": 150,
            "column": 2
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 150,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "Nat",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "omega",
          "proofState": 124,
          "pos": {
            "line": 150,
            "column": 37
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\n\u22a2 p \u2260 2",
          "endPos": {
            "line": 150,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Int.instCommMonoid",
            "add_mul",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CancelCommMonoidWithZero.toIsLeftCancelMulZero",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "cast",
            "Distrib.rightDistribClass",
            "pow_ne_zero",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Eq.mp",
            "right_ne_zero_of_mul",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "CommMagma.toMul",
            "instOfNatNat",
            "Int",
            "mul_left_cancel\u2080",
            "Int.pow_dvd_pow_iff",
            "FLT.FreyPackage",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "And.casesOn",
            "LT.lt.ne'",
            "Int.instNormedCommRing",
            "instHAdd",
            "Int.instDistrib",
            "And",
            "Exists.casesOn",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5.match_1",
            "Nat.instPreorder",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "AddGroup.existsAddOfLE",
            "Nat.Prime.ne_zero",
            "And.intro",
            "congr",
            "AddZeroClass.toZero",
            "LT.lt",
            "left_ne_zero_of_mul",
            "Exists.intro",
            "Iff.mp",
            "mul_comm",
            "Eq.ndrec",
            "Int.instAdd",
            "Int.instAddGroup",
            "Int.instCancelCommMonoidWithZero",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Nonempty",
            "Zero.toOfNat0",
            "Int.exists_gcd_one'",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "instLTNat",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "mul_pow",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.gcd_pos_of_ne_zero_left",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have \u27e8a, b, c, a0, b0, c0, ab, H\u27e9 : \u2203 (a b c : \u2124), a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 Int.gcd a b = 1 \u2227 a ^ p + b ^ p = c ^ p :=\n  by\n  obtain \u27e8d, a', b', d0, cop, a_eq, b_eq\u27e9 := Int.exists_gcd_one' (Int.gcd_pos_of_ne_zero_left b ha)\n  simp only [a_eq, mul_pow, b_eq] at H\n  rw [\u2190 add_mul, mul_comm] at H\n  obtain \u27e8c', rfl\u27e9 := (Int.pow_dvd_pow_iff pp.ne_zero).1 \u27e8_, H.symm\u27e9\n  rw [mul_pow] at H\n  have a0' := left_ne_zero_of_mul (a_eq \u25b8 ha)\n  have b0' := left_ne_zero_of_mul (b_eq \u25b8 hb)\n  have c0' := right_ne_zero_of_mul hc\n  exact\n    \u27e8a', b', c', a0', b0', c0', cop, mul_left_cancel\u2080 (pow_ne_zero _ (mod_cast d0.ne')) H\u27e9\n      -- Then show that WLOG we can take b to be even,\n        -- because at least one of a,b,c is even and we can permute if needed",
          "proofState": 125,
          "pos": {
            "line": 152,
            "column": 2
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\np_odd : Odd p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 163,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "Int.exists_gcd_one'",
            "Int.gcd_pos_of_ne_zero_left"
          ],
          "tactic": "obtain \u27e8d, a', b', d0, cop, a_eq, b_eq\u27e9 := Int.exists_gcd_one' (Int.gcd_pos_of_ne_zero_left b ha)",
          "proofState": 126,
          "pos": {
            "line": 154,
            "column": 4
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\np_odd : Odd p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 155,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "Int.instCommMonoid",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Monoid.toNatPow",
            "Eq.mp",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "congr",
            "Int.instAdd",
            "instNatCastInt",
            "instHPow",
            "mul_pow",
            "Eq",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp only [a_eq, mul_pow, b_eq] at H",
          "proofState": 127,
          "pos": {
            "line": 156,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro\na b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 156,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "Int.instCommMonoid",
            "add_mul",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Distrib.rightDistribClass",
            "Monoid.toNatPow",
            "Eq.mp",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "instHAdd",
            "Int.instDistrib",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "Int.instAdd",
            "instNatCastInt",
            "instHPow",
            "Eq.symm",
            "Eq",
            "instHMul"
          ],
          "tactic": "rw [\u2190 add_mul, mul_comm] at H",
          "proofState": 128,
          "pos": {
            "line": 157,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro\na b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nH : a' ^ p * \u2191d ^ p + b' ^ p * \u2191d ^ p = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 157,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.pow_dvd_pow_iff",
            "Nat.Prime.ne_zero",
            "Exists.intro",
            "Iff.mp",
            "Eq.symm"
          ],
          "tactic": "obtain \u27e8c', rfl\u27e9 := (Int.pow_dvd_pow_iff pp.ne_zero).1 \u27e8_, H.symm\u27e9",
          "proofState": 129,
          "pos": {
            "line": 158,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro\na b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 158,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "Int.instCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Monoid.toNatPow",
            "Eq.mp",
            "CommMagma.toMul",
            "Int",
            "Nat.cast",
            "Int.instNormedCommRing",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "Int.instAdd",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "mul_pow",
            "Eq",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "rw [mul_pow] at H",
          "proofState": 130,
          "pos": {
            "line": 159,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = (\u2191d * c') ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 159,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "left_ne_zero_of_mul",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "have a0' := left_ne_zero_of_mul (a_eq \u25b8 ha)",
          "proofState": 131,
          "pos": {
            "line": 160,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 160,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "left_ne_zero_of_mul",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "have b0' := left_ne_zero_of_mul (b_eq \u25b8 hb)",
          "proofState": 132,
          "pos": {
            "line": 161,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\na0' : a' \u2260 0\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 161,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "right_ne_zero_of_mul",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "have c0' := right_ne_zero_of_mul hc",
          "proofState": 133,
          "pos": {
            "line": 162,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\na0' : a' \u2260 0\nb0' : b' \u2260 0\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 162,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "congrArg",
            "CancelCommMonoidWithZero.toIsLeftCancelMulZero",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "cast",
            "pow_ne_zero",
            "Exists",
            "Monoid.toNatPow",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "CommMagma.toMul",
            "instOfNatNat",
            "Int",
            "mul_left_cancel\u2080",
            "Nat.cast",
            "Int.instMonoid",
            "LT.lt.ne'",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat.instPreorder",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "AddGroup.existsAddOfLE",
            "And.intro",
            "AddZeroClass.toZero",
            "Exists.intro",
            "Int.instAdd",
            "Int.instAddGroup",
            "Int.instCancelCommMonoidWithZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "exact\n  \u27e8a', b', c', a0', b0', c0', cop, mul_left_cancel\u2080 (pow_ne_zero _ (mod_cast d0.ne')) H\u27e9\n    -- Then show that WLOG we can take b to be even,\n      -- because at least one of a,b,c is even and we can permute if needed",
          "proofState": 134,
          "pos": {
            "line": 163,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\na0' : a' \u2260 0\nb0' : b' \u2260 0\nc0' : c' \u2260 0\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 163,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Int.even_pow",
            "Iff.mpr",
            "Monoid",
            "Odd.neg_pow",
            "Int.gcd",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5.match_2",
            "Int.gcd_neg",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Int.instDecidablePredEven",
            "id",
            "Int.instNegInt",
            "Nat.Prime.pos",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "Nat.cast_inj",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.even_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "FLT.FreyPackage",
            "Nat.cast",
            "add_comm",
            "dite",
            "Int.instMonoid",
            "iff_of_false",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "Iff",
            "HPow.hPow",
            "instOfNat",
            "And.left",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "And.intro",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "Even",
            "eq_self",
            "SubNegMonoid.toNeg",
            "Exists.intro",
            "Iff.mp",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "add_neg_cancel_comm_assoc",
            "Nonempty",
            "Zero.toOfNat0",
            "neg_ne_zero",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Int.gcd_comm",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "even_neg",
            "Neg.neg",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "have \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9 :\n  \u2203 (a b c : \u2124), a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 Int.gcd a b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p := by\n  if eb : Even b then exact \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9\n  else\n    if ea : Even a then exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9\n    else\n      refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9\n      \u00b7 refine Int.gcd_neg.trans (.trans (.symm ?_) ab)\n        exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)\n      \u00b7 refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1\n        \u00b7 exact fun h => ea (Int.even_pow.1 h).1\n        \u00b7 exact fun h => eb (Int.even_pow.1 h).1\n      \u00b7\n        simp [p_odd.neg_pow, \u2190 H]\n          -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 135,
          "pos": {
            "line": 166,
            "column": 2
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Int.instDecidablePredEven",
            "Ne",
            "instOfNatNat",
            "Int",
            "dite",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Even",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "Not"
          ],
          "tactic": "if eb : Even b then exact \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9\nelse\n  if ea : Even a then exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9\n  else\n    refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9\n    \u00b7 refine Int.gcd_neg.trans (.trans (.symm ?_) ab)\n      exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)\n    \u00b7 refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1\n      \u00b7 exact fun h => ea (Int.even_pow.1 h).1\n      \u00b7 exact fun h => eb (Int.even_pow.1 h).1\n    \u00b7\n      simp [p_odd.neg_pow, \u2190 H]\n        -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 136,
          "pos": {
            "line": 168,
            "column": 4
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "exact \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9",
          "proofState": 137,
          "pos": {
            "line": 169,
            "column": 6
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : Even b\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 169,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Int.instDecidablePredEven",
            "Ne",
            "instOfNatNat",
            "Int",
            "dite",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Even",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "Not"
          ],
          "tactic": "if ea : Even a then exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9\nelse\n  refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9\n  \u00b7 refine Int.gcd_neg.trans (.trans (.symm ?_) ab)\n    exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)\n  \u00b7 refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1\n    \u00b7 exact fun h => ea (Int.even_pow.1 h).1\n    \u00b7 exact fun h => eb (Int.even_pow.1 h).1\n  \u00b7\n    simp [p_odd.neg_pow, \u2190 H]\n      -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 138,
          "pos": {
            "line": 170,
            "column": 9
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Eq.mpr",
            "congrArg",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "id",
            "Ne",
            "instOfNatNat",
            "Int",
            "add_comm",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "OfNat.ofNat",
            "Int.gcd_comm",
            "Eq",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup"
          ],
          "tactic": "exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9",
          "proofState": 139,
          "pos": {
            "line": 171,
            "column": 6
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : Even a\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 171,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "Monoid.toNatPow",
            "id",
            "Int",
            "add_comm",
            "Int.instMonoid",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "Int.instAdd",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "Eq",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup"
          ],
          "tactic": "rwa [add_comm]",
          "proofState": 140,
          "pos": {
            "line": 171,
            "column": 64
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : Even a\n\u22a2 b ^ p + a ^ p = c ^ p",
          "endPos": {
            "line": 171,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Iff.mpr",
            "Int.gcd",
            "NegZeroClass.toNeg",
            "AddMonoid.toAddZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "Int.instNegInt",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "Zero.toOfNat0",
            "neg_ne_zero",
            "instHPow",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "even_neg",
            "Neg.neg"
          ],
          "tactic": "refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9",
          "proofState": 141,
          "pos": {
            "line": 173,
            "column": 6
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 173,
            "column": 87
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Int.gcd_neg",
            "Int.instNegInt",
            "instOfNatNat",
            "Int",
            "Nat",
            "OfNat.ofNat",
            "Eq.symm",
            "Neg.neg",
            "Eq.trans"
          ],
          "tactic": "refine Int.gcd_neg.trans (.trans (.symm ?_) ab)",
          "proofState": 142,
          "pos": {
            "line": 174,
            "column": 8
          },
          "goals": "case refine_1\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 a.gcd (-c) = 1",
          "endPos": {
            "line": 174,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Nat.Prime.pos",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "Nat.cast_inj",
            "Nat.cast",
            "Int.instRing",
            "Nat",
            "Iff.mp",
            "Int.instCharZero",
            "Eq",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)",
          "proofState": 143,
          "pos": {
            "line": 175,
            "column": 8
          },
          "goals": "case refine_1\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 a.gcd b = a.gcd c",
          "endPos": {
            "line": 175,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Int.even_pow",
            "Iff.mpr",
            "Monoid.toNatPow",
            "Eq.rec",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.even_add",
            "Int.instMonoid",
            "iff_of_false",
            "instHAdd",
            "And",
            "Iff",
            "HPow.hPow",
            "And.left",
            "HAdd.hAdd",
            "Nat",
            "Even",
            "Iff.mp",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1",
          "proofState": 144,
          "pos": {
            "line": 176,
            "column": 8
          },
          "goals": "case refine_2\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 Even c",
          "endPos": {
            "line": 176,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Int.even_pow",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "And",
            "HPow.hPow",
            "And.left",
            "Nat",
            "Even",
            "Iff.mp",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat"
          ],
          "tactic": "exact fun h => ea (Int.even_pow.1 h).1",
          "proofState": 145,
          "pos": {
            "line": 177,
            "column": 10
          },
          "goals": "case refine_2.refine_1\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 \u00acEven (a ^ p)",
          "endPos": {
            "line": 177,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "Int.even_pow",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "And",
            "HPow.hPow",
            "And.left",
            "Nat",
            "Even",
            "Iff.mp",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat"
          ],
          "tactic": "exact fun h => eb (Int.even_pow.1 h).1",
          "proofState": 146,
          "pos": {
            "line": 178,
            "column": 10
          },
          "goals": "case refine_2.refine_2\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 \u00acEven (b ^ p)",
          "endPos": {
            "line": 178,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Monoid",
            "Odd.neg_pow",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Monoid.toNatPow",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "add_neg_cancel_comm_assoc",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp [p_odd.neg_pow, \u2190 H]\n  -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 147,
          "pos": {
            "line": 179,
            "column": 8
          },
          "goals": "case refine_3\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 a ^ p + (-c) ^ p = (-b) ^ p",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Int.decidableDvd",
            "Iff.mpr",
            "Monoid",
            "Odd.neg_pow",
            "Int.gcd",
            "Eq.mpr",
            "Int.modEq_iff_dvd",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "of_decide_eq_true",
            "Nat.ble",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "False.elim",
            "AddMonoid.toAddZeroClass",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "eq_false_of_decide",
            "HSub.hSub",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "AddCommGroup.toAddGroup",
            "Int.gcd_neg",
            "Exists",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "Eq.mp",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_start",
            "id",
            "False.casesOn",
            "Distrib.toAdd",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "GCDMonoid.dvd_gcd",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5.match_3",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "CommMonoidWithZero.toMonoidWithZero",
            "SubtractionMonoid.toSubNegMonoid",
            "NonUnitalSemiring.toSemigroupWithZero",
            "SubNegZeroMonoid.toNegZeroClass",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "FLT.FreyPackage",
            "Nat.cast",
            "add_comm",
            "Int.instDvd",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toSemigroupWithZero",
            "Bool.true",
            "Int.instNormedCommRing",
            "Int.instGCDMonoid",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHAdd",
            "And",
            "instHSub",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Int.ModEq",
            "And.intro",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Int.ModEq.neg",
            "True",
            "Even",
            "eq_self",
            "SubNegMonoid.toNeg",
            "Exists.intro",
            "Iff.mp",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "HasDistribNeg",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_stop",
            "Bool",
            "of_eq_true",
            "Int.instAdd",
            "Even.neg",
            "even_iff_two_dvd",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "NonUnitalRing.toNonUnitalSemiring",
            "Semiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nonempty",
            "Zero.toOfNat0",
            "Eq.refl",
            "neg_ne_zero",
            "Int.instSub",
            "AddCommSemigroup.toAddCommMagma",
            "instNatCastInt",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq.symm",
            "Bool.false",
            "AddZeroClass.toAdd",
            "Decidable.decide",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "Int.neg_gcd",
            "letFun",
            "Neg.neg",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_succ",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instSemiring",
            "Int.instAddCommSemigroup",
            "Dvd.dvd.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "have \u27e8a, b, c, ha0, hb0, hc0, ab, ha3, eb, hFLT\u27e9 :\n  \u2203 (a b c : \u2124), a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 Int.gcd a b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p := by\n  -- Since b is even, a cannot also be even\n  have a_odd' : \u2200 {i}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i := fun ai ei =>\n    by\n    have ea := (dvd_sub_right ei).1 (.trans (by decide) (Int.modEq_iff_dvd.1 ai))\n    simpa (config := { decide := true }) [gcd, ab] using dvd_gcd ea (even_iff_two_dvd.1 eb)\n  mod_cases a_mod:a % 4\n  \u00b7 cases a_odd' a_mod (by decide)\n  \u00b7\n    exact\n      \u27e8-a, -b, -c, neg_ne_zero.2 a0, neg_ne_zero.2 b0, neg_ne_zero.2 c0, by rwa [Int.neg_gcd, Int.gcd_neg], a_mod.neg,\n        eb.neg, by simp [p_odd.neg_pow, \u2190 H, add_comm]\u27e9\n  \u00b7 cases a_odd' a_mod (by decide)\n  \u00b7\n    exact\n      \u27e8a, b, c, a0, b0, c0, ab, a_mod, eb, H\u27e9\n        -- Build the Frey package from the assumptions",
          "proofState": 148,
          "pos": {
            "line": 181,
            "column": 2
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 194,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Int.gcd",
            "Int.modEq_iff_dvd",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "Dvd.dvd",
            "of_decide_eq_true",
            "congrArg",
            "False.elim",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "eq_false_of_decide",
            "HSub.hSub",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "AddCommGroup.toAddGroup",
            "Exists",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "Eq.mp",
            "id",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "GCDMonoid.dvd_gcd",
            "Ne",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "CommMonoidWithZero.toMonoidWithZero",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toSemigroupWithZero",
            "Bool.true",
            "Int.instNormedCommRing",
            "Int.instGCDMonoid",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHAdd",
            "And",
            "instHSub",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Int.ModEq",
            "Even",
            "Iff.mp",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "Bool",
            "Int.instAdd",
            "even_iff_two_dvd",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "NonUnitalRing.toNonUnitalSemiring",
            "Semiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Bool.false",
            "Decidable.decide",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "letFun",
            "Eq.trans",
            "Int.instSemiring",
            "Dvd.dvd.trans"
          ],
          "tactic": "have a_odd' : \u2200 {i}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i := fun ai ei =>\n  by\n  have ea := (dvd_sub_right ei).1 (.trans (by decide) (Int.modEq_iff_dvd.1 ai))\n  simpa (config := { decide := true }) [gcd, ab] using dvd_gcd ea (even_iff_two_dvd.1 eb)",
          "proofState": 149,
          "pos": {
            "line": 185,
            "column": 4
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 187,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Int.modEq_iff_dvd",
            "False",
            "Dvd.dvd",
            "of_decide_eq_true",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "id",
            "Int",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "Int.instDvd",
            "SubNegMonoid.toSub",
            "Bool.true",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "Int.ModEq",
            "Iff.mp",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "Bool",
            "NonUnitalRing.toNonUnitalSemiring",
            "Eq.refl",
            "Int.instSub",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq",
            "letFun",
            "Dvd.dvd.trans"
          ],
          "tactic": "have ea := (dvd_sub_right ei).1 (.trans (by decide) (Int.modEq_iff_dvd.1 ai))",
          "proofState": 150,
          "pos": {
            "line": 186,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\ni\u271d : \u2124\nai : a \u2261 i\u271d [ZMOD 4]\nei : 2 \u2223 i\u271d\n\u22a2 False",
          "endPos": {
            "line": 186,
            "column": 83
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "semigroupDvd",
            "SemigroupWithZero.toSemigroup",
            "id",
            "Int",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "Bool.true",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instOfNat",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "Bool",
            "NonUnitalRing.toNonUnitalSemiring",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "decide",
          "proofState": 151,
          "pos": {
            "line": 186,
            "column": 50
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\ni\u271d : \u2124\nai : a \u2261 i\u271d [ZMOD 4]\nei : 2 \u2223 i\u271d\n\u22a2 2 \u2223 4",
          "endPos": {
            "line": 186,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa (config := { decide := true }) [gcd, ab] using dvd_gcd ea (even_iff_two_dvd.1 eb)",
          "proofState": 152,
          "pos": {
            "line": 187,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\ni\u271d : \u2124\nai : a \u2261 i\u271d [ZMOD 4]\nei : 2 \u2223 i\u271d\nea : 2 \u2223 a\n\u22a2 False",
          "endPos": {
            "line": 187,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Nat.ble",
            "Exists",
            "Monoid.toNatPow",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_start",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.ModEq",
            "Even",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_stop",
            "Bool",
            "Int.instAdd",
            "Eq.refl",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_succ"
          ],
          "tactic": "mod_cases a_mod:a % 4",
          "proofState": 153,
          "pos": {
            "line": 188,
            "column": 4
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 188,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "cases a_odd' a_mod (by decide)",
          "proofState": 154,
          "pos": {
            "line": 189,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 0 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 189,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "decide",
          "proofState": 155,
          "pos": {
            "line": 189,
            "column": 29
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 0 [ZMOD 4]\n\u22a2 2 \u2223 0",
          "endPos": {
            "line": 189,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Iff.mpr",
            "Monoid",
            "Odd.neg_pow",
            "Int.gcd",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Int.gcd_neg",
            "Exists",
            "Monoid.toNatPow",
            "id",
            "Int.instNegInt",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "add_comm",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.ModEq",
            "And.intro",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Int.ModEq.neg",
            "True",
            "Even",
            "eq_self",
            "SubNegMonoid.toNeg",
            "Exists.intro",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "Even.neg",
            "Zero.toOfNat0",
            "neg_ne_zero",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Int.neg_gcd",
            "Neg.neg",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "exact\n  \u27e8-a, -b, -c, neg_ne_zero.2 a0, neg_ne_zero.2 b0, neg_ne_zero.2 c0, by rwa [Int.neg_gcd, Int.gcd_neg], a_mod.neg,\n    eb.neg, by simp [p_odd.neg_pow, \u2190 H, add_comm]\u27e9",
          "proofState": 156,
          "pos": {
            "line": 190,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 1 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 192,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Eq.mpr",
            "congrArg",
            "id",
            "Int.instNegInt",
            "instOfNatNat",
            "Int",
            "Nat",
            "OfNat.ofNat",
            "Eq",
            "Int.neg_gcd",
            "Neg.neg"
          ],
          "tactic": "rwa [Int.neg_gcd, Int.gcd_neg]",
          "proofState": 157,
          "pos": {
            "line": 191,
            "column": 11
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 1 [ZMOD 4]\n\u22a2 (-a).gcd (-b) = 1",
          "endPos": {
            "line": 191,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Monoid",
            "Odd.neg_pow",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Monoid.toNatPow",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "add_comm",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp [p_odd.neg_pow, \u2190 H, add_comm]",
          "proofState": 158,
          "pos": {
            "line": 192,
            "column": 11
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 1 [ZMOD 4]\n\u22a2 (-a) ^ p + (-b) ^ p = (-c) ^ p",
          "endPos": {
            "line": 192,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "cases a_odd' a_mod (by decide)",
          "proofState": 159,
          "pos": {
            "line": 193,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 2 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 193,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "decide",
          "proofState": 160,
          "pos": {
            "line": 193,
            "column": 29
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 2 [ZMOD 4]\n\u22a2 2 \u2223 2",
          "endPos": {
            "line": 193,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.ModEq",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "exact\n  \u27e8a, b, c, a0, b0, c0, ab, a_mod, eb, H\u27e9\n    -- Build the Frey package from the assumptions",
          "proofState": 161,
          "pos": {
            "line": 194,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 3 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 194,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Int.gcd",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SemigroupWithZero.toSemigroup",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "NonUnitalSemiring.toSemigroupWithZero",
            "Nonempty.intro",
            "FLT.FreyPackage",
            "Nat.cast",
            "ZMod",
            "Int.instDvd",
            "ZMod.intCast_zmod_eq_zero_iff_dvd",
            "AddMonoidWithOne.toOne",
            "FLT.FreyPackage.mk",
            "ZMod.intCast_eq_intCast_iff",
            "instNatAtLeastTwo",
            "instOfNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Int.ModEq",
            "True",
            "Even",
            "eq_self",
            "Iff.mp",
            "of_eq_true",
            "even_iff_two_dvd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "instNatCastInt",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring"
          ],
          "tactic": "exact\n  \u27e8{  a, b, c, ha0, hb0, hc0, p, pp, hp5, hFLT\n      hgcdab := by simp [gcd, ab]\n      ha4 := (ZMod.intCast_eq_intCast_iff ..).2 ha3\n      hb2 := (ZMod.intCast_zmod_eq_zero_iff_dvd ..).2 (even_iff_two_dvd.1 eb) }\u27e9",
          "proofState": 162,
          "pos": {
            "line": 196,
            "column": 2
          },
          "goals": "a\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 : \u2124\nha : a\u271d\u00b2 \u2260 0\nhb : b\u271d\u00b2 \u2260 0\nhc : c\u271d\u00b2 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b2 ^ p + b\u271d\u00b2 ^ p = c\u271d\u00b2 ^ p\np_odd : Odd p\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\na0\u271d : a\u271d\u00b9 \u2260 0\nb0\u271d : b\u271d\u00b9 \u2260 0\nc0\u271d : c\u271d\u00b9 \u2260 0\nab\u271d\u00b9 : a\u271d\u00b9.gcd b\u271d\u00b9 = 1\nH\u271d : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\na\u271d b\u271d c\u271d : \u2124\na0 : a\u271d \u2260 0\nb0 : b\u271d \u2260 0\nc0 : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\neb\u271d : Even b\u271d\nH : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhc0 : c \u2260 0\nab : a.gcd b = 1\nha3 : a \u2261 3 [ZMOD 4]\neb : Even b\nhFLT : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 201,
            "column": 4
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "AddMonoidWithOne.toOne",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "True",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "instNatCastInt",
            "OfNat.ofNat",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp [gcd, ab]",
          "proofState": 163,
          "pos": {
            "line": 198,
            "column": 17
          },
          "goals": "a\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 : \u2124\nha : a\u271d\u00b2 \u2260 0\nhb : b\u271d\u00b2 \u2260 0\nhc : c\u271d\u00b2 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b2 ^ p + b\u271d\u00b2 ^ p = c\u271d\u00b2 ^ p\np_odd : Odd p\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\na0\u271d : a\u271d\u00b9 \u2260 0\nb0\u271d : b\u271d\u00b9 \u2260 0\nc0\u271d : c\u271d\u00b9 \u2260 0\nab\u271d\u00b9 : a\u271d\u00b9.gcd b\u271d\u00b9 = 1\nH\u271d : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\na\u271d b\u271d c\u271d : \u2124\na0 : a\u271d \u2260 0\nb0 : b\u271d \u2260 0\nc0 : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\neb\u271d : Even b\u271d\nH : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhc0 : c \u2260 0\nab : a.gcd b = 1\nha3 : a \u2261 3 [ZMOD 4]\neb : Even b\nhFLT : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b = 1",
          "endPos": {
            "line": 198,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "WeierstrassCurve.\u0394",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "Rat",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "instTransEq",
            "FLT.FreyPackage.c",
            "HPow.hPow",
            "Nat",
            "Trans.simple",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "trans (P.a ^ P.p) ^ 2 * (P.b ^ P.p) ^ 2 * (P.c ^ P.p) ^ 2 / 2 ^ 8",
          "proofState": 164,
          "pos": {
            "line": 217,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 = (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) / 2 ^ 8",
          "endPos": {
            "line": 217,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "Int.cast",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "GroupWithZero.toMonoidWithZero",
            "Rat.instMul",
            "instHDiv",
            "NormedRing.toRing",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "MulZeroClass.toMul",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "FLT.FreyPackage.p",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "instNatAtLeastTwo",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Eq.refl",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "Nat.cast_zero",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Rat.instLinearOrderedField",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "field_simp",
          "proofState": 165,
          "pos": {
            "line": 218,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 = (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.c ^ P.p) ^ 2 / 2 ^ 8",
          "endPos": {
            "line": 218,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "Int.cast",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "GroupWithZero.toMonoidWithZero",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "congrArg",
            "Mathlib.Data.Nat.Cast.Basic._auxLemma.2",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Nat.instMonoid",
            "Rat",
            "DivisionSemiring.toGroupWithZero",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Nat",
            "congr",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Rat.monoid",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Rat.commRing",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "norm_cast",
          "proofState": 166,
          "pos": {
            "line": 219,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 * 2 ^ 8 = (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.c ^ P.p) ^ 2",
          "endPos": {
            "line": 219,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "one_pow",
            "AddGroup.toSubtractionMonoid",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "GroupWithZero.toMonoidWithZero",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "sub_self",
            "Monoid.toMulOneClass",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "sub_zero",
            "Nat.instMonoid",
            "MulZeroClass.zero_mul",
            "AddMonoid.toAddZeroClass",
            "WeierstrassCurve.\u0394.proof_1",
            "Rat",
            "WeierstrassCurve.b\u2088.proof_1",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_pow",
            "HSub.hSub",
            "WeierstrassCurve.b\u2086.proof_1",
            "Rat.addMonoid",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.instPowNat",
            "Nat.instCharZero",
            "Monoid.toNatPow",
            "Int.cast_add",
            "WeierstrassCurve.\u0394.proof_2",
            "Rat.instIntCast",
            "neg_neg",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "WeierstrassCurve.a\u2082",
            "WeierstrassCurve.b\u2084.proof_1",
            "AddGroupWithOne.toIntCast",
            "WeierstrassCurve.a\u2083",
            "FLT.FreyPackage.p",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "MulZeroClass.mul_zero",
            "Int.instMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "CommRing.toCommSemiring",
            "Int.cast_mul",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.7",
            "Ring.toAddCommGroup",
            "WeierstrassCurve.a\u2086",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "MulOneClass.toOne",
            "SubNegMonoid.toNeg",
            "FLT.FreyPackage.hFLT",
            "WeierstrassCurve.a\u2084",
            "of_eq_true",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "neg_mul",
            "FLT.FreyPackage.FreyCurve",
            "Rat.addGroup",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "add_zero",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq.symm",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "NegZeroClass.toZero",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "WeierstrassCurve.mk",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "zero_pow",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "zero_sub",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "WeierstrassCurve.a\u2081",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "WeierstrassCurve.\u0394.proof_3",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [\u2190 P.hFLT, WeierstrassCurve.\u0394, FreyCurve, WeierstrassCurve.b\u2082, WeierstrassCurve.b\u2084, WeierstrassCurve.b\u2086,\n  WeierstrassCurve.b\u2088]",
          "proofState": 167,
          "pos": {
            "line": 220,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 * \u2191(2 ^ 8) = \u2191((P.a ^ P.p) ^ 2 * (P.b ^ P.p) ^ 2 * (P.c ^ P.p) ^ 2)",
          "endPos": {
            "line": 221,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Mathlib.Tactic.Ring.pow_one",
            "GroupWithZero.toMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "Mathlib.Tactic.Ring.coeff_one",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Mathlib.Meta.NormNum.intPow_negOfNat_bit1",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Monoid.toMulOneClass",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "WeierstrassCurve.\u0394.proof_1",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.one_natPow",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "Mathlib.Meta.NormNum.IsNatPowT.bit1",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "WeierstrassCurve.b\u2084.proof_1",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "CommRing.toCommSemiring",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "instNatAtLeastTwo",
            "Rat.instCharZero",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "Mathlib.Meta.NormNum.intPow_negOfNat_bit0",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Mathlib.Meta.NormNum.isRat_pow",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Rat.monoid",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Rat.semiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 168,
          "pos": {
            "line": 222,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 ((1 + 4 * ((\u2191P.b ^ P.p - 1 - \u2191P.a ^ P.p) / 4)) ^ 2 * (-(\u2191P.a ^ P.p * \u2191P.b ^ P.p) / 16) ^ 2 -\n        8 * (2 * (-(\u2191P.a ^ P.p * \u2191P.b ^ P.p) / 16)) ^ 3) *\n      256 =\n    (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.a ^ P.p + \u2191P.b ^ P.p) ^ 2",
          "endPos": {
            "line": 222,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Rat",
            "_auxLemma.1",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "CommMagma.toMul",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Rat.commMonoid",
            "FLT.FreyPackage.c",
            "HPow.hPow",
            "CommMonoid.toMonoid",
            "Nat",
            "congr",
            "True",
            "CommSemigroup.toCommMagma",
            "eq_self",
            "mul_comm",
            "of_eq_true",
            "FLT.FreyPackage.a",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "_auxLemma.2",
            "Eq",
            "Rat.instDiv",
            "Nat.instCommSemigroup",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp [\u2190 mul_pow, \u2190 pow_mul, mul_comm 2]",
          "proofState": 169,
          "pos": {
            "line": 223,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.c ^ P.p) ^ 2 / 2 ^ 8 = (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) / 2 ^ 8",
          "endPos": {
            "line": 223,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Rat",
            "IsUnit",
            "FLT.FreyPackage.FreyCurve.\u0394",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw [FreyCurve.\u0394, isUnit_iff_ne_zero]",
          "proofState": 170,
          "pos": {
            "line": 227,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 IsUnit P.FreyCurve.\u0394",
          "endPos": {
            "line": 227,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "div_ne_zero"
          ],
          "tactic": "apply div_ne_zero",
          "proofState": 171,
          "pos": {
            "line": 228,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) / 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 228,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Int.cast_zero",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instMulNat",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "SubNegZeroMonoid.toNegZeroClass",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Distrib.toMul",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Eq.symm",
            "NegZeroClass.toZero",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Rat.instNatCast",
            "MulZeroClass.toZero",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul"
          ],
          "tactic": "norm_cast",
          "proofState": 172,
          "pos": {
            "line": 229,
            "column": 6
          },
          "goals": "case ha\nP : FreyPackage\n\u22a2 (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) \u2260 0",
          "endPos": {
            "line": 229,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "HMul.hMul",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "pow_ne_zero",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "FLT.FreyPackage.ha0",
            "MonoidWithZero.toMulZeroOneClass",
            "FLT.FreyPackage.hc0",
            "Nat",
            "AddGroup.existsAddOfLE",
            "FLT.FreyPackage.hb0",
            "Int.instAddGroup",
            "FLT.FreyPackage.a",
            "LinearOrderedRing.isDomain",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "mul_ne_zero",
            "OfNat.ofNat",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "exact pow_ne_zero _ <| mul_ne_zero (mul_ne_zero P.ha0 P.hb0) P.hc0",
          "proofState": 173,
          "pos": {
            "line": 230,
            "column": 6
          },
          "goals": "case ha\nP : FreyPackage\n\u22a2 \u00ac(P.a * P.b * P.c) ^ (2 * P.p) = 0",
          "endPos": {
            "line": 230,
            "column": 72
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "GroupWithZero.toMonoidWithZero",
            "NormedRing.toRing",
            "LinearOrderedSemifield.toSemifield",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "Monoid.toNatPow",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Nat.instAddMonoidWithOne",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "Zero.toOfNat0",
            "Eq.refl",
            "instHPow",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Rat.instLinearOrderedField",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero"
          ],
          "tactic": "norm_num",
          "proofState": 174,
          "pos": {
            "line": 231,
            "column": 6
          },
          "goals": "case hb\nP : FreyPackage\n\u22a2 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 231,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "one_pow",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "CommRing.toNonUnitalCommRing",
            "Monoid.toMulOneClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "WeierstrassCurve.b\u2082",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "WeierstrassCurve.a\u2082",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "instHAdd",
            "CommRing.toCommSemiring",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "neg_mul",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "NormedField.toNormedCommRing",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "WeierstrassCurve.mk",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "WeierstrassCurve.a\u2081",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve, WeierstrassCurve.b\u2082]",
          "proofState": 175,
          "pos": {
            "line": 235,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.b\u2082 = \u2191P.b ^ P.p - \u2191P.a ^ P.p",
          "endPos": {
            "line": 235,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Monoid.toMulOneClass",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "DivisionRing.toRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "MulOneClass.toOne",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Rat.monoid",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 176,
          "pos": {
            "line": 236,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 1 + 4 * ((\u2191P.b ^ P.p - 1 - \u2191P.a ^ P.p) / 4) = \u2191P.b ^ P.p - \u2191P.a ^ P.p",
          "endPos": {
            "line": 236,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Rat.addMonoid",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.instPowNat",
            "Rat.instIntCast",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "WeierstrassCurve.b\u2084",
            "WeierstrassCurve.b\u2084.proof_1",
            "WeierstrassCurve.a\u2083",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "MulZeroClass.mul_zero",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "instHAdd",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "WeierstrassCurve.a\u2084",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "neg_mul",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "NormedField.toNormedCommRing",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "add_zero",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "WeierstrassCurve.mk",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Rat.instNeg",
            "WeierstrassCurve.a\u2081",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve, WeierstrassCurve.b\u2084]",
          "proofState": 177,
          "pos": {
            "line": 240,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.b\u2084 = -(\u2191P.a * \u2191P.b) ^ P.p / 8",
          "endPos": {
            "line": 240,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "DivisionRing.toRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "WeierstrassCurve.b\u2084.proof_1",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Int.mul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "NormedField.toNormedCommRing",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Rat.instNeg",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 178,
          "pos": {
            "line": 241,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 2 * (-(\u2191P.a ^ P.p * \u2191P.b ^ P.p) / 16) = -(\u2191P.a * \u2191P.b) ^ P.p / 8",
          "endPos": {
            "line": 241,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "WeierstrassCurve.c\u2084.proof_1",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "WeierstrassCurve.c\u2084",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "FLT.FreyPackage.FreyCurve.b\u2084",
            "WeierstrassCurve.b\u2082",
            "FLT.FreyPackage.FreyCurve.b\u2082",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "WeierstrassCurve.b\u2084",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "SubNegMonoid.toSub",
            "instHAdd",
            "CommRing.toCommSemiring",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Rat.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Rat.instNeg",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve.b\u2082, FreyCurve.b\u2084, WeierstrassCurve.c\u2084]",
          "proofState": 179,
          "pos": {
            "line": 245,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.c\u2084 = (\u2191P.a ^ P.p) ^ 2 + \u2191P.a ^ P.p * \u2191P.b ^ P.p + (\u2191P.b ^ P.p) ^ 2",
          "endPos": {
            "line": 245,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.isNat_add",
            "Rat.instMul",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "WeierstrassCurve.c\u2084.proof_1",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "CommRing.toCommSemiring",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Int.mul",
            "Rat.instAdd",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Rat.monoid",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Rat.instNeg",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 180,
          "pos": {
            "line": 246,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.b ^ P.p - \u2191P.a ^ P.p) ^ 2 - 24 * (-(\u2191P.a * \u2191P.b) ^ P.p / 8) =\n    (\u2191P.a ^ P.p) ^ 2 + \u2191P.a ^ P.p * \u2191P.b ^ P.p + (\u2191P.b ^ P.p) ^ 2",
          "endPos": {
            "line": 246,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "HMul.hMul",
            "congrArg",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "WeierstrassCurve.c\u2084",
            "Rat.instIntCast",
            "id",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "instHAdd",
            "instHSub",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "Rat.instAdd",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve.c\u2084",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "rw [FreyCurve.c\u2084]",
          "proofState": 181,
          "pos": {
            "line": 250,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.c\u2084 = \u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p",
          "endPos": {
            "line": 250,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Rat",
            "HSub.hSub",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Rat.instAdd",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instHPow",
            "NormedField.toNormedCommRing",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Rat.monoid",
            "Ring.toSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw_mod_cast [pow_mul', \u2190 hFLT]",
          "proofState": 182,
          "pos": {
            "line": 251,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.a ^ P.p) ^ 2 + \u2191P.a ^ P.p * \u2191P.b ^ P.p + (\u2191P.b ^ P.p) ^ 2 = \u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p",
          "endPos": {
            "line": 251,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMonoid",
            "Int.instMul",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 183,
          "pos": {
            "line": 252,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 (P.a ^ P.p) ^ 2 + P.a ^ P.p * P.b ^ P.p + (P.b ^ P.p) ^ 2 = (P.a ^ P.p + P.b ^ P.p) ^ 2 - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 252,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Units.val",
            "WeierstrassCurve.\u0394",
            "Rat.instMul",
            "DivInvMonoid.toInv",
            "instHDiv",
            "HMul.hMul",
            "DivisionCommMonoid.toDivisionMonoid",
            "congrArg",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "Units.val_inv_eq_inv_val",
            "Rat",
            "FLT.FreyPackage.FreyCurve.\u0394",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Units",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "WeierstrassCurve.\u0394'",
            "DivInvMonoid.toMonoid",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "DivisionMonoid.toDivInvMonoid",
            "FLT.FreyPackage.c",
            "Inv.inv",
            "HPow.hPow",
            "Nat",
            "True",
            "eq_self",
            "DivInvMonoid.toDiv",
            "of_eq_true",
            "FLT.FreyPackage.a",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "inv_div",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Units.instInv",
            "Rat.instDiv",
            "Rat.commRing",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve.\u0394]",
          "proofState": 184,
          "pos": {
            "line": 256,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 \u2191P.FreyCurve.\u0394'\u207b\u00b9 = 2 ^ 8 / (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p)",
          "endPos": {
            "line": 256,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "DivisionCommMonoid.toDivisionMonoid",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "DivisionMonoid.toDivInvMonoid",
            "mul_div_right_comm",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "DivInvMonoid.toDiv",
            "FLT.FreyPackage.a",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "rw [mul_div_right_comm, WeierstrassCurve.j, FreyCurve.\u0394'inv, FreyCurve.c\u2084']",
          "proofState": 185,
          "pos": {
            "line": 260,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.j = 2 ^ 8 * (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 / (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p)",
          "endPos": {
            "line": 260,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.cast_intCast",
            "Rat.instMul",
            "Real",
            "Rat.cast_mul",
            "NormedRing.toRing",
            "HMul.hMul",
            "DivisionRing.toRatCast",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Rify._auxLemma.3",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Int.cast_sub",
            "Int.cast_zero",
            "Real.instRatCast",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_pow",
            "HSub.hSub",
            "Real.instLT",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "DivisionRing.toDivisionSemiring",
            "Int.cast_add",
            "Rat.instIntCast",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Rat.cast",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "Int.instLTInt",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Int.cast_mul",
            "instHSub",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Real.instDivisionRing",
            "LT.lt",
            "Mathlib.Tactic.Qify._auxLemma.4",
            "Rat.instAdd",
            "Rat.cast_zero",
            "DivisionSemiring.toSemiring",
            "Rat.cast_add",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Rat.instLT",
            "Int.instSub",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Ring.toSemiring",
            "Eq",
            "Rat.cast_pow",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Rat.cast_sub",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rify",
          "proofState": 186,
          "pos": {
            "line": 263,
            "column": 2
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 0 < (a + b) ^ 2 - a * b",
          "endPos": {
            "line": 263,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Real.instLinearOrderedField",
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "Iff.mpr",
            "AddGroup.toSubtractionMonoid",
            "StrictOrderedSemiring.toPosMulStrictMono",
            "Int.cast",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Mathlib.Meta.NormNum.isNat_add",
            "Real.partialOrder",
            "Real",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "Trans.trans",
            "IsDomain.to_noZeroDivisors",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "Nat.rawCast",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "OrderedAddCommGroup.toAddLeftMono",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Nat.ble",
            "Real.instZero",
            "Real.instAddMonoid",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "Real.orderedSemiring",
            "Even.pow_nonneg",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "OrderedAddCommMonoid.toPartialOrder",
            "Real.instDivInvMonoid",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "IsCancelAdd.toIsLeftCancelAdd",
            "PartialOrder.toPreorder",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "HSub.hSub",
            "AddCancelMonoid.toIsCancelAdd",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "Real.instLT",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "pow_ne_zero",
            "DivisionMonoid.toDivInvOneMonoid",
            "OrderedSemiring.zeroLEOneClass",
            "LinearOrderedSemiring.toPosMulReflectLT",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "Real.instAddGroup",
            "Ne",
            "DivisionRing.toRing",
            "Real.instRing",
            "OrderedSemiring.toSemiring",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "LinearOrderedRing.toStrictOrderedRing",
            "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
            "SubNegZeroMonoid.toNegZeroClass",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "Real.instMonoid",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "even_two_mul",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Mathlib.Meta.Positivity.pos_of_isNat",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Real.instIsDomain",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Real.orderedAddCommGroup",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "AddGroup.existsAddOfLE",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.nontrivial",
            "Real.instDivisionRing",
            "LT.lt",
            "Real.instIntCast",
            "Int.mul",
            "DivInvMonoid.toDiv",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Bool",
            "lt_add_of_le_of_pos",
            "LinearOrderedSemifield.toLinearOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.cast_ne_zero",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "div_pos",
            "InvOneClass.toInv",
            "instTransEq_1",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddGroup.toAddCancelMonoid",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "RCLike.charZero_rclike",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "calc\n  (0 : \u211d) < (a ^ 2 + (a + b) ^ 2 + b ^ 2) / 2 := by positivity\n  _ = (a + b) ^ 2 - a * b := by ring",
          "proofState": 187,
          "pos": {
            "line": 264,
            "column": 2
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 0 < (\u2191a + \u2191b) ^ 2 - \u2191a * \u2191b",
          "endPos": {
            "line": 266,
            "column": 38
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  (0 : \u211d) < (a ^ 2 + (a + b) ^ 2 + b ^ 2) / 2 := by positivity\n  _ = (a + b) ^ 2 - a * b := by ring",
          "proofState": 188,
          "pos": {
            "line": 265,
            "column": 4
          },
          "goals": "no goals",
          "endPos": {
            "line": 266,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Real.instLinearOrderedField",
            "Iff.mpr",
            "AddGroup.toSubtractionMonoid",
            "StrictOrderedSemiring.toPosMulStrictMono",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.partialOrder",
            "Real",
            "IsDomain.to_noZeroDivisors",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "OrderedAddCommGroup.toAddLeftMono",
            "Nat.ble",
            "Real.instZero",
            "Real.instAddMonoid",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Real.orderedSemiring",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "IsCancelAdd.toIsLeftCancelAdd",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "AddCancelMonoid.toIsCancelAdd",
            "DivisionSemiring.toGroupWithZero",
            "Preorder.toLE",
            "pow_ne_zero",
            "OrderedSemiring.zeroLEOneClass",
            "LinearOrderedSemiring.toPosMulReflectLT",
            "Monoid.toNatPow",
            "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Real.instAddGroup",
            "Ne",
            "Real.instRing",
            "OrderedSemiring.toSemiring",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
            "SubNegZeroMonoid.toNegZeroClass",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "Real.instMonoid",
            "instHAdd",
            "even_two_mul",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Mathlib.Meta.Positivity.pos_of_isNat",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Real.instIsDomain",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Real.orderedAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.nontrivial",
            "Real.instIntCast",
            "Bool",
            "lt_add_of_le_of_pos",
            "LinearOrderedSemifield.toLinearOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "Int.cast_ne_zero",
            "div_pos",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "AddGroup.toAddCancelMonoid",
            "OfNat.ofNat",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "RCLike.charZero_rclike",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "positivity",
          "proofState": 189,
          "pos": {
            "line": 265,
            "column": 54
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 0 < (\u2191a ^ 2 + (\u2191a + \u2191b) ^ 2 + \u2191b ^ 2) / 2",
          "endPos": {
            "line": 265,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "Int.cast",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.isNat_add",
            "Real",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Real.instDivInvMonoid",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "Real.instAdd",
            "Real.instMonoid",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "DivInvMonoid.toDiv",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 190,
          "pos": {
            "line": 266,
            "column": 34
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 (\u2191a ^ 2 + (\u2191a + \u2191b) ^ 2 + \u2191b ^ 2) / 2 = (\u2191a + \u2191b) ^ 2 - \u2191a * \u2191b",
          "endPos": {
            "line": 266,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Nat.Prime",
            "Dvd.dvd",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "Fact",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "Nat.cast",
            "Int.instDvd",
            "Fact.mk",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "letFun",
            "Rat.commRing"
          ],
          "tactic": "have := Fact.mk hqPrime",
          "proofState": 191,
          "pos": {
            "line": 273,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 273,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "Nat.Prime",
            "Dvd.dvd",
            "Nat.prime_iff_prime_int",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "Prime",
            "CommSemiring.toCommMonoidWithZero",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "Nat.cast",
            "Int.instDvd",
            "Iff.mp",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "Int.instCommSemiring",
            "letFun",
            "Rat.commRing"
          ],
          "tactic": "have hqPrime' := Nat.prime_iff_prime_int.mp hqPrime",
          "proofState": 192,
          "pos": {
            "line": 274,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 274,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Rat.instMul",
            "Dvd.dvd",
            "HMul.hMul",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "Ne",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "letFun",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "have h\u2080 : ((P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3 : \u211a) \u2260 0 :=\n  by\n  rw_mod_cast [pow_mul', \u2190 P.hFLT, mul_pow]\n  exact pow_ne_zero _ <| ne_of_gt <| j_pos_aux _ _ (pow_ne_zero _ P.hb0)",
          "proofState": 193,
          "pos": {
            "line": 275,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 277,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Int.cast_zero",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instMulNat",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "SubNegZeroMonoid.toNegZeroClass",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHSub",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Distrib.toMul",
            "Int.instRing",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq.symm",
            "NegZeroClass.toZero",
            "Ring.toSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Rat.instNatCast",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw_mod_cast [pow_mul', \u2190 P.hFLT, mul_pow]",
          "proofState": 194,
          "pos": {
            "line": 276,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\n\u22a2 (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0",
          "endPos": {
            "line": 276,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Int.instCommMonoid",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "HSub.hSub",
            "Preorder.toLE",
            "pow_ne_zero",
            "Monoid.toNatPow",
            "ne_of_gt",
            "instOfNatNat",
            "Int",
            "_private.0.FLT.FreyPackage.j_pos_aux",
            "LinearOrderedRing.toStrictOrderedRing",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Int.instMonoid",
            "instHAdd",
            "instHSub",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "AddGroup.existsAddOfLE",
            "FLT.FreyPackage.hb0",
            "Int.instAdd",
            "Int.instAddGroup",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Int.instSub",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "OrderedAddCommGroup.toPartialOrder",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "exact pow_ne_zero _ <| ne_of_gt <| j_pos_aux _ _ (pow_ne_zero _ P.hb0)",
          "proofState": 195,
          "pos": {
            "line": 277,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\n\u22a2 \u00ac((P.a ^ P.p + P.b ^ P.p) ^ 2 - P.a ^ P.p * P.b ^ P.p) ^ 3 = 0",
          "endPos": {
            "line": 277,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "OrderedAddCommMonoid.toPartialOrder",
            "Rat",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Ne",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "Int.instNormedCommRing",
            "FLT.FreyPackage.ha0",
            "instOfNat",
            "FLT.FreyPackage.hc0",
            "AddGroup.existsAddOfLE",
            "FLT.FreyPackage.hb0",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "mul_ne_zero",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "letFun",
            "Rat.commRing",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "have h\u2081 : P.a * P.b * P.c \u2260 0 := mul_ne_zero (mul_ne_zero P.ha0 P.hb0) P.hc0",
          "proofState": 196,
          "pos": {
            "line": 278,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 278,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "Dvd.dvd",
            "instHDiv",
            "HMul.hMul",
            "congrArg",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "FLT.FreyPackage.FreyCurve.j",
            "WeierstrassCurve.j",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "rw [FreyCurve.j, padicValRat.div (mul_ne_zero (by norm_num) h\u2080) (pow_ne_zero _ (mod_cast h\u2081)),\n  padicValRat.mul (by norm_num) h\u2080, padicValRat.pow two_ne_zero, \u2190 Nat.cast_two, \u2190 padicValRat_of_nat,\n  padicValNat_primes hqodd.ne', Nat.cast_zero, mul_zero, zero_add]",
          "proofState": 197,
          "pos": {
            "line": 279,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 281,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Nat.instAddMonoidWithOne",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "instHPow",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "norm_num",
          "proofState": 198,
          "pos": {
            "line": 279,
            "column": 52
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 279,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NormedRing.toRing",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Monoid.toNatPow",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Nat.instAddMonoidWithOne",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "Eq.refl",
            "instHPow",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "norm_num",
          "proofState": 199,
          "pos": {
            "line": 280,
            "column": 24
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 280,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Rat.instSub",
            "Rat.instMul",
            "Dvd.dvd",
            "HMul.hMul",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Rat.semiring",
            "Not",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have : \u00ac(q : \u2124) \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3 :=\n  by\n  rw [hqPrime'.dvd_pow_iff_dvd three_ne_zero]\n  have hq' : Xor' ((q : \u2124) \u2223 P.a * P.b) ((q : \u2124) \u2223 P.c) :=\n    by\n    rw [xor_iff_not_iff, iff_iff_and_or_not_and_not]\n    rintro (\u27e8hab, hc\u27e9 | \u27e8hab, hc\u27e9)\n    \u00b7 rw [hqPrime'.dvd_mul] at hab\n      apply hqPrime'.not_dvd_one\n      cases hab with\n      | inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n      | inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc\n    \u00b7 rw [hqPrime'.dvd_mul] at hqbad\n      exact hqbad.rec hab hc\n  have h2p0 := mul_ne_zero two_ne_zero P.hp0\n  cases hq' with\n  | inl h =>\n    rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]\n    exact h.2\n  | inr h =>\n    rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]\n    exact h.2",
          "proofState": 200,
          "pos": {
            "line": 282,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u2191P.p \u2223 padicValRat q ((\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3) - padicValRat q ((\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p))",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Nat.instMulZeroClass",
            "Dvd.dvd",
            "HMul.hMul",
            "congrArg",
            "semigroupDvd",
            "HSub.hSub",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "instHSub",
            "HPow.hPow",
            "Prime.dvd_pow_iff_dvd",
            "Nat.instNeZeroSucc",
            "Nat",
            "propext",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "three_ne_zero",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Not",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "rw [hqPrime'.dvd_pow_iff_dvd three_ne_zero]",
          "proofState": 201,
          "pos": {
            "line": 283,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3",
          "endPos": {
            "line": 283,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "HSub.hSub",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "Xor'",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Not",
            "letFun",
            "instHMul"
          ],
          "tactic": "have hq' : Xor' ((q : \u2124) \u2223 P.a * P.b) ((q : \u2124) \u2223 P.c) :=\n  by\n  rw [xor_iff_not_iff, iff_iff_and_or_not_and_not]\n  rintro (\u27e8hab, hc\u27e9 | \u27e8hab, hc\u27e9)\n  \u00b7 rw [hqPrime'.dvd_mul] at hab\n    apply hqPrime'.not_dvd_one\n    cases hab with\n    | inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n    | inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc\n  \u00b7 rw [hqPrime'.dvd_mul] at hqbad\n    exact hqbad.rec hab hc",
          "proofState": 202,
          "pos": {
            "line": 284,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 293,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "HMul.hMul",
            "congrArg",
            "xor_iff_not_iff",
            "id",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "Xor'",
            "FLT.FreyPackage.c",
            "Iff",
            "propext",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Eq",
            "Not",
            "instHMul"
          ],
          "tactic": "rw [xor_iff_not_iff, iff_iff_and_or_not_and_not]",
          "proofState": 203,
          "pos": {
            "line": 285,
            "column": 6
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)",
          "endPos": {
            "line": 285,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "And",
            "FLT.FreyPackage.a",
            "Or",
            "instNatCastInt",
            "Not",
            "instHMul"
          ],
          "tactic": "rintro (\u27e8hab, hc\u27e9 | \u27e8hab, hc\u27e9)",
          "proofState": 204,
          "pos": {
            "line": 286,
            "column": 6
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u00ac(\u2191q \u2223 P.a * P.b \u2227 \u2191q \u2223 P.c \u2228 \u00ac\u2191q \u2223 P.a * P.b \u2227 \u00ac\u2191q \u2223 P.c)",
          "endPos": {
            "line": 286,
            "column": 36
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [hqPrime'.dvd_mul] at hab",
          "proofState": 205,
          "pos": {
            "line": 287,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a * P.b\nhc : \u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 287,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toCommMonoidWithZero",
            "Prime.not_dvd_one",
            "Int",
            "Nat.cast",
            "instNatCastInt",
            "Int.instCommSemiring"
          ],
          "tactic": "apply hqPrime'.not_dvd_one",
          "proofState": 206,
          "pos": {
            "line": 288,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a \u2228 \u2191q \u2223 P.b\nhc : \u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 288,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "MonoidWithZero.toSemigroupWithZero",
            "FLT.FreyPackage.a",
            "Eq.refl",
            "Or",
            "instNatCastInt",
            "Int.instCommSemiring"
          ],
          "tactic": "cases hab with\n| inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n| inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc",
          "proofState": 207,
          "pos": {
            "line": 289,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a \u2228 \u2191q \u2223 P.b\nhc : \u2191q \u2223 P.c\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 291,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases hab with\n| inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n| inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc",
          "proofState": 208,
          "pos": {
            "line": 289,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a \u2228 \u2191q \u2223 P.b\nhc : \u2191q \u2223 P.c\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 291,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "FLT.FreyPackage.hgcdac",
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "id",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Nat.cast",
            "MulZeroOneClass.toMulOneClass",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "MulOneClass.toOne",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 P.hgcdac]",
          "proofState": 209,
          "pos": {
            "line": 290,
            "column": 20
          },
          "goals": "case inl.intro.inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nha : \u2191q \u2223 P.a\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 290,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "Nat.cast",
            "FLT.FreyPackage.c",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "FLT.FreyPackage.a",
            "instNatCastInt"
          ],
          "tactic": "exact dvd_gcd ha hc",
          "proofState": 210,
          "pos": {
            "line": 290,
            "column": 37
          },
          "goals": "case inl.intro.inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nha : \u2191q \u2223 P.a\n\u22a2 \u2191q \u2223 gcd P.a P.c",
          "endPos": {
            "line": 290,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "id",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "MulZeroOneClass.toMulOneClass",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "MulOneClass.toOne",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "instNatCastInt",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "FLT.FreyPackage.hgcdbc"
          ],
          "tactic": "rw [\u2190 P.hgcdbc]",
          "proofState": 211,
          "pos": {
            "line": 291,
            "column": 20
          },
          "goals": "case inl.intro.inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nhb : \u2191q \u2223 P.b\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 291,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "FLT.FreyPackage.c",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "instNatCastInt"
          ],
          "tactic": "exact dvd_gcd hb hc",
          "proofState": 212,
          "pos": {
            "line": 291,
            "column": 37
          },
          "goals": "case inl.intro.inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nhb : \u2191q \u2223 P.b\n\u22a2 \u2191q \u2223 gcd P.b P.c",
          "endPos": {
            "line": 291,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [hqPrime'.dvd_mul] at hqbad",
          "proofState": 213,
          "pos": {
            "line": 292,
            "column": 8
          },
          "goals": "case inr.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u00ac\u2191q \u2223 P.a * P.b\nhc : \u00ac\u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 292,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "False",
            "Dvd.dvd",
            "HMul.hMul",
            "Or.rec",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "FLT.FreyPackage.a",
            "Or",
            "instNatCastInt",
            "Int.instCommSemiring",
            "instHMul"
          ],
          "tactic": "exact hqbad.rec hab hc",
          "proofState": 214,
          "pos": {
            "line": 293,
            "column": 8
          },
          "goals": "case inr.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b \u2228 \u2191q \u2223 P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u00ac\u2191q \u2223 P.a * P.b\nhc : \u00ac\u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 293,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Nat.instMulZeroClass",
            "IsDomain.to_noZeroDivisors",
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "HSub.hSub",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "Nat.instStarOrderedRing",
            "Nat.instStarRing",
            "Ne",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.p",
            "Nat.instNonUnitalSemiring",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "two_ne_zero",
            "instHSub",
            "HPow.hPow",
            "FLT.FreyPackage.hp0",
            "Nat.instNeZeroSucc",
            "Nat",
            "StarOrderedRing.toExistsAddOfLE",
            "Nat.instPartialOrder",
            "FLT.FreyPackage.a",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "mul_ne_zero",
            "Nat.instLinearOrderedSemiring",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Not",
            "letFun",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "have h2p0 := mul_ne_zero two_ne_zero P.hp0",
          "proofState": 215,
          "pos": {
            "line": 294,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhq' : Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 294,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Xor'",
            "FLT.FreyPackage.c",
            "FLT.FreyPackage.a",
            "Eq.refl",
            "instNatCastInt"
          ],
          "tactic": "cases hq' with\n| inl h =>\n  rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]\n  exact h.2\n| inr h =>\n  rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]\n  exact h.2",
          "proofState": 216,
          "pos": {
            "line": 295,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhq' : Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)\nh2p0 : 2 * P.p \u2260 0\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases hq' with\n| inl h =>\n  rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]\n  exact h.2\n| inr h =>\n  rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]\n  exact h.2",
          "proofState": 217,
          "pos": {
            "line": 295,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhq' : Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)\nh2p0 : 2 * P.p \u2260 0\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "HMul.hMul",
            "dvd_sub_left",
            "congrArg",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "NonUnitalSemiring.toSemigroupWithZero",
            "FLT.FreyPackage.p",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "dvd_pow",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "FLT.FreyPackage.hp0",
            "And.left",
            "Nat",
            "propext",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "NonUnitalRing.toNonUnitalSemiring",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Not",
            "instHMul"
          ],
          "tactic": "rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]",
          "proofState": 218,
          "pos": {
            "line": 297,
            "column": 6
          },
          "goals": "case inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.a * P.b \u2227 \u00ac\u2191q \u2223 P.c\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 297,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "And.right",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Not",
            "instHMul"
          ],
          "tactic": "exact h.2",
          "proofState": 219,
          "pos": {
            "line": 298,
            "column": 6
          },
          "goals": "case inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.a * P.b \u2227 \u00ac\u2191q \u2223 P.c\n\u22a2 \u00ac\u2191q \u2223 P.c",
          "endPos": {
            "line": 298,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "HMul.hMul",
            "congrArg",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "CommSemiring.toCommMonoidWithZero",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "NonUnitalSemiring.toSemigroupWithZero",
            "FLT.FreyPackage.p",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "dvd_pow",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "And.left",
            "Nat",
            "propext",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "NonUnitalRing.toNonUnitalSemiring",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Not",
            "instHMul"
          ],
          "tactic": "rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]",
          "proofState": 220,
          "pos": {
            "line": 300,
            "column": 6
          },
          "goals": "case inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.c \u2227 \u00ac\u2191q \u2223 P.a * P.b\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 300,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "And.right",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Not",
            "instHMul"
          ],
          "tactic": "exact h.2",
          "proofState": 221,
          "pos": {
            "line": 301,
            "column": 6
          },
          "goals": "case inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.c \u2227 \u00ac\u2191q \u2223 P.a * P.b\n\u22a2 \u00ac\u2191q \u2223 P.a * P.b",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "Dvd.dvd",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Rat",
            "HSub.hSub",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Distrib.toMul",
            "Nat",
            "congr",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Ring.toSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "norm_cast",
          "proofState": 222,
          "pos": {
            "line": 302,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis\u271d : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nthis : \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3\n\u22a2 \u2191P.p \u2223 padicValRat q ((\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3) - padicValRat q ((\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p))",
          "endPos": {
            "line": 302,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Eq.mpr",
            "Dvd.dvd",
            "NormedRing.toRing",
            "HMul.hMul",
            "congrArg",
            "padicValInt",
            "Rat",
            "HSub.hSub",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "padicValRat.of_int",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "rw [padicValRat.of_int, padicValInt.eq_zero_of_not_dvd this, Nat.cast_zero, zero_sub, Int.cast_pow,\n  padicValRat.pow (mod_cast h\u2081), dvd_neg, Nat.cast_mul]",
          "proofState": 223,
          "pos": {
            "line": 303,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis\u271d : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nthis : \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3\n\u22a2 \u2191P.p \u2223 padicValRat q \u2191((P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3) - padicValRat q \u2191((P.a * P.b * P.c) ^ (2 * P.p))",
          "endPos": {
            "line": 304,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "dvd_mul_of_dvd_left",
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NormedRing.toRing",
            "HMul.hMul",
            "Int.instCommSemigroup",
            "Rat",
            "AddMonoidWithOne.toNatCast",
            "CommMagma.toMul",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "dvd_mul_left",
            "Rat.instNormedField",
            "CommSemigroup.toSemigroup",
            "Nat",
            "CommSemigroup.toCommMagma",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "Int.instSemiring",
            "instHMul"
          ],
          "tactic": "exact dvd_mul_of_dvd_left (dvd_mul_left _ _) _",
          "proofState": 224,
          "pos": {
            "line": 305,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis\u271d : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nthis : \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3\n\u22a2 \u2191P.p \u2223 \u21912 * \u2191P.p * padicValRat q \u2191(P.a * P.b * P.c)",
          "endPos": {
            "line": 305,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "FLT.Wiles_Frey"
          ],
          "tactic": "apply Wiles_Frey P",
          "proofState": 225,
          "pos": {
            "line": 347,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 False",
          "endPos": {
            "line": 347,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "FLT.Mazur_Frey"
          ],
          "tactic": "exact Mazur_Frey P",
          "proofState": 226,
          "pos": {
            "line": 349,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 IsSimpleModule (ZMod P.p) (P.FreyCurve.torsionGaloisRepresentation P.p Qbar).asModule",
          "endPos": {
            "line": 349,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "False",
            "Nat.Prime",
            "Nonempty.elim",
            "FLT.of_p_ge_5",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "GE.ge",
            "Distrib.toAdd",
            "Ne",
            "instOfNatNat",
            "instLENat",
            "FLT.FreyPackage",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "FLT.FreyPackage.false",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "instHPow",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "refine of_p_ge_5 fun p hp5 pp a b c ha hb _ h \u21a6 Nonempty.elim ?_ FreyPackage.false",
          "proofState": 227,
          "pos": {
            "line": 354,
            "column": 2
          },
          "goals": "\u22a2 FermatLastTheorem",
          "endPos": {
            "line": 354,
            "column": 85
          }
        },
        {
          "usedConstants": [
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5",
            "Int",
            "Nat.cast",
            "instNatCastInt"
          ],
          "tactic": "apply FreyPackage.of_not_FermatLastTheorem_p_ge_5 (a := a) (b := b) (c := c)",
          "proofState": 228,
          "pos": {
            "line": 355,
            "column": 2
          },
          "goals": "p : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 355,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 229,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case ha\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191a \u2260 0",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 230,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case hb\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191b \u2260 0",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 231,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case hc\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191c \u2260 0",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption_mod_cast",
          "proofState": 232,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case pp\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 Nat.Prime ?p",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption_mod_cast",
          "proofState": 233,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case hp5\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 5 \u2264 p",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "congrArg",
            "Mathlib.Data.Nat.Cast.Basic._auxLemma.2",
            "Nat.instMonoid",
            "Mathlib.Data.Nat.Cast.Defs._auxLemma.3",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Monoid.toNatPow",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "Int.instMonoid",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "congr",
            "Int.instAdd",
            "instAddNat",
            "instNatCastInt",
            "instHPow",
            "Int.instCharZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 234,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case H\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191a ^ p + \u2191b ^ p = \u2191c ^ p",
          "endPos": {
            "line": 356,
            "column": 27
          }
        }
      ],
      "sorries": [
        {
          "proofState": 80,
          "pos": {
            "line": 324,
            "column": 93
          },
          "goal": "P : FreyPackage\n\u22a2 IsSimpleModule (ZMod P.p) (P.FreyCurve.torsionGaloisRepresentation P.p Qbar).asModule",
          "endPos": {
            "line": 324,
            "column": 98
          }
        },
        {
          "proofState": 81,
          "pos": {
            "line": 334,
            "column": 95
          },
          "goal": "P : FreyPackage\n\u22a2 \u00acIsSimpleModule (ZMod P.p) (P.FreyCurve.torsionGaloisRepresentation P.p Qbar).asModule",
          "endPos": {
            "line": 334,
            "column": 100
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 323,
            "column": 8
          },
          "endPos": {
            "line": 323,
            "column": 18
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 333,
            "column": 8
          },
          "endPos": {
            "line": 333,
            "column": 18
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 9
    }
  },
  {
    "file": "FLT/Junk/Algebra2.lean",
    "output": {
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 1,
            "column": 0
          },
          "endPos": {
            "line": 1,
            "column": 5
          },
          "data": "using 'exit' to interrupt Lean"
        }
      ],
      "env": 10
    }
  },
  {
    "file": "FLT/Junk/Algebra.lean",
    "output": {
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 1,
            "column": 0
          },
          "endPos": {
            "line": 1,
            "column": 5
          },
          "data": "using 'exit' to interrupt Lean"
        }
      ],
      "env": 11
    }
  },
  {
    "file": "FLT/TateCurve/TateCurve.lean",
    "output": {
      "env": 12
    }
  },
  {
    "file": "FLT/MathlibExperiments/IsFrobenius.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "Eq.mpr",
            "AlgEquiv.instEquivLike",
            "RingHom.instRingHomClass",
            "MulEquiv.instEquivLike",
            "AlgEquiv.symm",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingHom",
            "Algebra.IsAlgebraic.of_finite",
            "Field.toDivisionRing",
            "id",
            "Ideal.map",
            "AlgEquivClass.toAlgHomClass",
            "DivInvMonoid.toMonoid",
            "DivisionRing.toRing",
            "Ideal",
            "Field.toSemifield",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "AlgEquiv.instAlgEquivClass",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "AlgEquiv",
            "galRestrict",
            "RingHomClass.toRingHom",
            "Ideal.comap",
            "AlgEquiv.aut",
            "DivisionSemiring.toSemiring",
            "MulEquiv",
            "Semifield.toCommSemiring",
            "AlgHomClass.toRingHomClass",
            "CommRing.toRing",
            "CompatibleFamily.comap_symm",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AlgEquiv.instFunLike",
            "EquivLike.toFunLike"
          ],
          "tactic": "erw [\u2190 comap_symm]",
          "proofState": 236,
          "pos": {
            "line": 63,
            "column": 6
          },
          "goals": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : FiniteDimensional K L\ng : L \u2243\u2090[K] L\nP : Ideal A\ninst\u271d : P.IsMaximal\nQ : Ideal B\nh : IsInvariant ((galRestrict A K L B) g) Q\n\u22a2 Q = Ideal.map (\u2191((galRestrict A K L B) g)) Q",
          "endPos": {
            "line": 63,
            "column": 24
          }
        },
        {
          "usedConstants": [],
          "tactic": "exact h",
          "proofState": 237,
          "pos": {
            "line": 63,
            "column": 26
          },
          "goals": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : FiniteDimensional K L\ng : L \u2243\u2090[K] L\nP : Ideal A\ninst\u271d : P.IsMaximal\nQ : Ideal B\nh : IsInvariant ((galRestrict A K L B) g) Q\n\u22a2 Q = Ideal.comap (\u2191((galRestrict A K L B) g).symm) Q",
          "endPos": {
            "line": 63,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "MonoidHom.ext"
          ],
          "tactic": "ext a l",
          "proofState": 238,
          "pos": {
            "line": 83,
            "column": 2
          },
          "goals": "K L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\n\u22a2 AlgEquiv.restrictNormalHom L = MonoidHom.id (L \u2243\u2090[K] L)",
          "endPos": {
            "line": 83,
            "column": 9
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa only [Algebra.id.map_eq_id, RingHom.id_apply, AlgHom.coe_coe] using\n  AlgHom.restrictNormal_commutes (E := L) (F := K) (K\u2081 := L) (K\u2082 := L) a l",
          "proofState": 239,
          "pos": {
            "line": 84,
            "column": 2
          },
          "goals": "case h.h\nK L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\na : L \u2243\u2090[K] L\nl : L\n\u22a2 ((AlgEquiv.restrictNormalHom L) a) l = ((MonoidHom.id (L \u2243\u2090[K] L)) a) l",
          "endPos": {
            "line": 85,
            "column": 76
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "MonoidHom.instFunLike",
            "IsScalarTower.right",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "congrArg",
            "Algebra.id",
            "id",
            "DivInvMonoid.toMonoid",
            "Field.toSemifield",
            "Group.toDivInvMonoid",
            "AlgEquiv.restrictNormalHom",
            "Semifield.toDivisionSemiring",
            "CompatibleFamily.AlgEquiv_restrict_to_domain_equals_id",
            "AlgEquiv",
            "MonoidHom.id",
            "AlgEquiv.aut",
            "DivisionSemiring.toSemiring",
            "Semifield.toCommSemiring",
            "Eq",
            "DFunLike.coe"
          ],
          "tactic": "rw [AlgEquiv_restrict_to_domain_equals_id K L h1]",
          "proofState": 240,
          "pos": {
            "line": 89,
            "column": 2
          },
          "goals": "K L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\ng : L \u2243\u2090[K] L\n\u22a2 (AlgEquiv.restrictNormalHom L) g = g",
          "endPos": {
            "line": 89,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "MonoidHom.instFunLike",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "DivInvMonoid.toMonoid",
            "Field.toSemifield",
            "Group.toDivInvMonoid",
            "Semifield.toDivisionSemiring",
            "AlgEquiv",
            "MonoidHom.id",
            "AlgEquiv.aut",
            "DivisionSemiring.toSemiring",
            "Eq.refl",
            "Semifield.toCommSemiring",
            "DFunLike.coe"
          ],
          "tactic": "rfl",
          "proofState": 241,
          "pos": {
            "line": 90,
            "column": 2
          },
          "goals": "K L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\ng : L \u2243\u2090[K] L\n\u22a2 (MonoidHom.id (L \u2243\u2090[K] L)) g = g",
          "endPos": {
            "line": 90,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "sorryAx",
            "instOfNatNat",
            "Lean.Name.num",
            "NumberField.RingOfIntegers.instCommRing",
            "Ideal",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "HasQuotient.Quotient",
            "CommRing.toCommSemiring",
            "Fintype",
            "Nat",
            "Lean.Name",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Bool.false",
            "Ideal.instHasQuotient_1"
          ],
          "tactic": "sorry\n  -- all broken from here but no longer sure this is the right level of generality",
          "proofState": 242,
          "pos": {
            "line": 116,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : NumberField K\nP : Ideal (\ud835\udcde K)\ninst\u271d : P.IsMaximal\n\u22a2 Fintype (\ud835\udcde K \u29f8 P)",
          "endPos": {
            "line": 116,
            "column": 7
          }
        }
      ],
      "sorries": [
        {
          "proofState": 235,
          "pos": {
            "line": 116,
            "column": 2
          },
          "goal": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : NumberField K\nP : Ideal (\ud835\udcde K)\ninst\u271d : P.IsMaximal\n\u22a2 Fintype (\ud835\udcde K \u29f8 P)",
          "endPos": {
            "line": 116,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 115,
            "column": 9
          },
          "endPos": {
            "line": 115,
            "column": 34
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 119,
            "column": 0
          },
          "endPos": {
            "line": 119,
            "column": 5
          },
          "data": "using 'exit' to interrupt Lean"
        }
      ],
      "env": 13
    }
  },
  {
    "file": "FLT/MathlibExperiments/IsCentralSimple.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [],
          "tactic": "induction s using Finset.induction_on with\n| empty =>\n  simp only [Finset.sum_empty]\n  exact r.refl 0\n| insert hj ih =>\n  next h' j s' =>\n    simp_rw [Finset.sum_insert hj]\n    apply RingCon.add\n    \u00b7 exact h j (Finset.mem_insert_self j s')\n    \u00b7 exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 243,
          "pos": {
            "line": 39,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\ns : Finset \u03b9\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 s, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 s, a i) (\u2211 i \u2208 s, b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction s using Finset.induction_on with\n| empty =>\n  simp only [Finset.sum_empty]\n  exact r.refl 0\n| insert hj ih =>\n  next h' j s' =>\n    simp_rw [Finset.sum_insert hj]\n    apply RingCon.add\n    \u00b7 exact h j (Finset.mem_insert_self j s')\n    \u00b7 exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 244,
          "pos": {
            "line": 39,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\ns : Finset \u03b9\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 s, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 s, a i) (\u2211 i \u2208 s, b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "RingCon.instFunLikeForallProp",
            "Finset",
            "RingCon",
            "id",
            "Finset.instEmptyCollection",
            "AddCommSemigroup.toAddCommMagma",
            "EmptyCollection.emptyCollection",
            "AddCommMonoid.toAddCommSemigroup",
            "DFunLike.coe",
            "Finset.sum",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp only [Finset.sum_empty]",
          "proofState": 245,
          "pos": {
            "line": 41,
            "column": 4
          },
          "goals": "case empty\nR : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 \u2205, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 \u2205, a i) (\u2211 i \u2208 \u2205, b i)",
          "endPos": {
            "line": 41,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "AddMonoid.toAddZeroClass",
            "RingCon.refl",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "OfNat.ofNat",
            "AddCommMonoid.toAddCommSemigroup",
            "AddCommMagma.toAdd"
          ],
          "tactic": "exact r.refl 0",
          "proofState": 246,
          "pos": {
            "line": 42,
            "column": 4
          },
          "goals": "case empty\nR : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 \u2205, r (a i) (b i)\n\u22a2 r 0 0",
          "endPos": {
            "line": 42,
            "column": 18
          }
        },
        {
          "usedConstants": [],
          "tactic": "next h' j s' =>\n  simp_rw [Finset.sum_insert hj]\n  apply RingCon.add\n  \u00b7 exact h j (Finset.mem_insert_self j s')\n  \u00b7 exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 247,
          "pos": {
            "line": 44,
            "column": 4
          },
          "goals": "case insert\nR : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\na\u271d : \u03b9\ns\u271d : Finset \u03b9\nhj : a\u271d \u2209 s\u271d\nih : (\u2200 i \u2208 s\u271d, r (a i) (b i)) \u2192 r (\u2211 i \u2208 s\u271d, a i) (\u2211 i \u2208 s\u271d, b i)\nh : \u2200 i \u2208 insert a\u271d s\u271d, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 insert a\u271d s\u271d, a i) (\u2211 i \u2208 insert a\u271d s\u271d, b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Finset",
            "AddMonoid.toAddZeroClass",
            "Classical.propDecidable",
            "RingCon",
            "id",
            "Insert.insert",
            "Finset.instInsert",
            "AddCommMonoid",
            "instHAdd",
            "HAdd.hAdd",
            "congr",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "Finset.sum_insert",
            "AddCommMonoid.toAddCommSemigroup",
            "AddZeroClass.toAdd",
            "Eq",
            "DFunLike.coe",
            "Finset.sum",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp_rw [Finset.sum_insert hj]",
          "proofState": 248,
          "pos": {
            "line": 45,
            "column": 6
          },
          "goals": "R : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 insert j s', a i) (\u2211 i \u2208 insert j s', b i)",
          "endPos": {
            "line": 45,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "RingCon.add"
          ],
          "tactic": "apply RingCon.add",
          "proofState": 249,
          "pos": {
            "line": 46,
            "column": 6
          },
          "goals": "R : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (a j + \u2211 i \u2208 s', a i) (b j + \u2211 i \u2208 s', b i)",
          "endPos": {
            "line": 46,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Finset.mem_insert_self",
            "Classical.propDecidable",
            "Eq"
          ],
          "tactic": "exact h j (Finset.mem_insert_self j s')",
          "proofState": 250,
          "pos": {
            "line": 47,
            "column": 8
          },
          "goals": "case a\nR : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (a j) (b j)",
          "endPos": {
            "line": 47,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Finset",
            "Classical.propDecidable",
            "Membership.mem",
            "Finset.instMembership",
            "Finset.mem_insert_of_mem",
            "Eq"
          ],
          "tactic": "exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 251,
          "pos": {
            "line": 48,
            "column": 8
          },
          "goals": "case a\nR : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "Subring.mem_center_iff",
            "HMul.hMul",
            "Subring.instSetLike",
            "Ring.toNonAssocRing",
            "congrArg",
            "Matrix",
            "Subring.center",
            "Matrix.instRing",
            "Membership.mem",
            "Field.toDivisionRing",
            "Eq.mp",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Distrib.toMul",
            "Subring",
            "propext",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq",
            "SetLike.instMembership",
            "instHMul"
          ],
          "tactic": "rw [Subring.mem_center_iff] at hd",
          "proofState": 252,
          "pos": {
            "line": 54,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nd : Matrix \u03b9 \u03b9 K\nhd : d \u2208 Subring.center (Matrix \u03b9 \u03b9 K)\n\u22a2 \u2203 k, d = (algebraMap K (Matrix \u03b9 \u03b9 K)) k",
          "endPos": {
            "line": 54,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Matrix.scalar",
            "CommSemiring.toSemiring",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Matrix.instRing",
            "Membership.mem",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "Matrix.instAlgebra",
            "Algebra.id",
            "Ne",
            "DivisionRing.toRing",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Matrix.stdBasisMatrix",
            "Field.toSemifield",
            "Matrix.nonAssocSemiring",
            "AddMonoidWithOne.toOne",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Matrix.mem_range_scalar_of_commute_stdBasisMatrix",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "Semifield.toCommSemiring",
            "Set.range",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "Set"
          ],
          "tactic": "convert mem_range_scalar_of_commute_stdBasisMatrix (M := d) fun i j _ => hd _",
          "proofState": 253,
          "pos": {
            "line": 55,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nd : Matrix \u03b9 \u03b9 K\nhd : \u2200 (g : Matrix \u03b9 \u03b9 K), g * d = d * g\n\u22a2 \u2203 k, d = (algebraMap K (Matrix \u03b9 \u03b9 K)) k",
          "endPos": {
            "line": 55,
            "column": 81
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Matrix.scalar",
            "congrArg",
            "CommSemiring.toSemiring",
            "Matrix",
            "_auxLemma.1",
            "RingHom",
            "Matrix.instRing",
            "Membership.mem",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "Matrix.instAlgebra",
            "Algebra.id",
            "id",
            "DivisionRing.toRing",
            "Field.toSemifield",
            "Matrix.nonAssocSemiring",
            "Iff",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "DivisionSemiring.toSemiring",
            "Semifield.toCommSemiring",
            "Set.range",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Set"
          ],
          "tactic": "simp_rw [Set.mem_range, eq_comm, algebraMap_eq_diagonal, Pi.algebraMap_def, Algebra.id.map_eq_self, scalar_apply]",
          "proofState": 254,
          "pos": {
            "line": 56,
            "column": 4
          },
          "goals": "case a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nd : Matrix \u03b9 \u03b9 K\nhd : \u2200 (g : Matrix \u03b9 \u03b9 K), g * d = d * g\n\u22a2 (\u2203 k, d = (algebraMap K (Matrix \u03b9 \u03b9 K)) k) \u2194 d \u2208 Set.range \u21d1(scalar \u03b9)",
          "endPos": {
            "line": 57,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Ring.toNonAssocRing",
            "Matrix",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Distrib.toMul",
            "NonUnitalNonAssocSemiring.toDistrib"
          ],
          "tactic": "intro r",
          "proofState": 255,
          "pos": {
            "line": 59,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\n\u22a2 \u2200 (a : RingCon (Matrix \u03b9 \u03b9 K)), a = \u22a5 \u2228 a = \u22a4",
          "endPos": {
            "line": 59,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Iff",
            "Distrib.toMul",
            "forall_or_exists_not",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "obtain h | h := _root_.forall_or_exists_not (fun x \u21a6 r 0 x \u2194 x = 0)",
          "proofState": 256,
          "pos": {
            "line": 60,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\n\u22a2 r = \u22a5 \u2228 r = \u22a4",
          "endPos": {
            "line": 60,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "Or.inl"
          ],
          "tactic": "left",
          "proofState": 257,
          "pos": {
            "line": 61,
            "column": 6
          },
          "goals": "case inl\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\n\u22a2 r = \u22a5 \u2228 r = \u22a4",
          "endPos": {
            "line": 61,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "RingCon.ext"
          ],
          "tactic": "apply RingCon.ext",
          "proofState": 258,
          "pos": {
            "line": 62,
            "column": 6
          },
          "goals": "case inl.h\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\n\u22a2 r = \u22a5",
          "endPos": {
            "line": 62,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Matrix"
          ],
          "tactic": "intro x y",
          "proofState": 259,
          "pos": {
            "line": 63,
            "column": 6
          },
          "goals": "case inl.h.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\n\u22a2 \u2200 (x y : Matrix \u03b9 \u03b9 K), r x y \u2194 \u22a5 x y",
          "endPos": {
            "line": 63,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "Matrix",
            "OrderBot.toBot",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Bot.bot",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "Matrix.sub",
            "BoundedOrder.toOrderBot",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have : r x y \u2194 r 0 (y - x) := by\n  constructor\n  \u00b7 convert RingCon.add r (r.refl (-x)) using 1\n    rw [neg_add_cancel, sub_eq_add_neg, add_comm]\n  \u00b7 convert RingCon.add r (r.refl x) using 1\n    rw [add_sub_cancel, add_zero]",
          "proofState": 260,
          "pos": {
            "line": 64,
            "column": 6
          },
          "goals": "case inl.h.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r x y \u2194 \u22a5 x y",
          "endPos": {
            "line": 69,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Iff.intro"
          ],
          "tactic": "constructor",
          "proofState": 261,
          "pos": {
            "line": 65,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r x y \u2194 r 0 (y - x)",
          "endPos": {
            "line": 65,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "Matrix",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "RingCon.refl",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Matrix.sub",
            "Ring.toAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Matrix.neg",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "RingCon.add"
          ],
          "tactic": "convert RingCon.add r (r.refl (-x)) using 1",
          "proofState": 262,
          "pos": {
            "line": 66,
            "column": 10
          },
          "goals": "case mp\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r x y \u2192 r 0 (y - x)",
          "endPos": {
            "line": 66,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Matrix",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "neg_add_cancel",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Matrix.addGroup",
            "Matrix.sub",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "SubNegMonoid.toNeg",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Matrix.neg",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [neg_add_cancel, sub_eq_add_neg, add_comm]",
          "proofState": 263,
          "pos": {
            "line": 67,
            "column": 10
          },
          "goals": "case h'.a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\na\u271d : r x y\n\u22a2 r 0 (y - x) \u2194 r (-x + x) (-x + y)",
          "endPos": {
            "line": 67,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "Matrix",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "RingCon.refl",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Matrix.sub",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "RingCon.add"
          ],
          "tactic": "convert RingCon.add r (r.refl x) using 1",
          "proofState": 264,
          "pos": {
            "line": 68,
            "column": 10
          },
          "goals": "case mpr\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r 0 (y - x) \u2192 r x y",
          "endPos": {
            "line": 68,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Matrix",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommGroup.toAddGroup",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "add_sub_cancel",
            "HAdd.hAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [add_sub_cancel, add_zero]",
          "proofState": 265,
          "pos": {
            "line": 69,
            "column": 10
          },
          "goals": "case h'.a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\na\u271d : r 0 (y - x)\n\u22a2 r x y \u2194 r (x + 0) (x + (y - x))",
          "endPos": {
            "line": 69,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Matrix",
            "OrderBot.toBot",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Bot.bot",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "Matrix.sub",
            "BoundedOrder.toOrderBot",
            "propext",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [this, h, sub_eq_zero, eq_comm, RingCon.coe_bot]",
          "proofState": 266,
          "pos": {
            "line": 70,
            "column": 6
          },
          "goals": "case inl.h.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\nthis : r x y \u2194 r 0 (y - x)\n\u22a2 r x y \u2194 \u22a5 x y",
          "endPos": {
            "line": 70,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "Or.inr"
          ],
          "tactic": "right",
          "proofState": 267,
          "pos": {
            "line": 71,
            "column": 6
          },
          "goals": "case inr\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2203 a, \u00ac(r 0 a \u2194 a = 0)\n\u22a2 r = \u22a5 \u2228 r = \u22a4",
          "endPos": {
            "line": 71,
            "column": 11
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8x, hx\u27e9 := h",
          "proofState": 268,
          "pos": {
            "line": 72,
            "column": 6
          },
          "goals": "case inr.h\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2203 a, \u00ac(r 0 a \u2194 a = 0)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 72,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have x_ne_zero : x \u2260 0 := by\n  rintro rfl\n  simp [eq_true (r.refl 0)] at hx",
          "proofState": 269,
          "pos": {
            "line": 73,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 75,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rintro rfl",
          "proofState": 270,
          "pos": {
            "line": 74,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\n\u22a2 x \u2260 0",
          "endPos": {
            "line": 74,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "False",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Matrix",
            "False.elim",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Eq.mp",
            "not_true_eq_false",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "RingCon.refl",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "iff_self",
            "Iff",
            "Distrib.toMul",
            "congr",
            "True",
            "eq_self",
            "eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Not",
            "Field.toEuclideanDomain",
            "Eq.trans",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp [eq_true (r.refl 0)] at hx",
          "proofState": 271,
          "pos": {
            "line": 75,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nhx : \u00ac(r 0 0 \u2194 0 = 0)\n\u22a2 False",
          "endPos": {
            "line": 75,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have r_zero_x : r 0 x := by tauto",
          "proofState": 272,
          "pos": {
            "line": 76,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 76,
            "column": 39
          }
        },
        {
          "usedConstants": [],
          "tactic": "tauto",
          "proofState": 273,
          "pos": {
            "line": 76,
            "column": 34
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\n\u22a2 r 0 x",
          "endPos": {
            "line": 76,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Exists",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have : \u2203 i j, x i j \u2260 0 := by simpa using x_ne_zero \u2218 Matrix.ext",
          "proofState": 274,
          "pos": {
            "line": 77,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 77,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "id",
            "Ne",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "simpa using x_ne_zero \u2218 Matrix.ext",
          "proofState": 275,
          "pos": {
            "line": 77,
            "column": 36
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\n\u22a2 \u2203 i j, x i j \u2260 0",
          "endPos": {
            "line": 77,
            "column": 70
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8i, j, hij\u27e9 := this",
          "proofState": 276,
          "pos": {
            "line": 78,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\nthis : \u2203 i j, x i j \u2260 0\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 78,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "Finset",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "Membership.mem",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Finset.instMembership",
            "Matrix.stdBasisMatrix",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "have (k : \u03b9) (_ : k \u2208 Finset.univ) : r 0 ((stdBasisMatrix k i 1) * x * (stdBasisMatrix j k 1)) := by\n  simpa using r.mul (r.mul (r.refl (stdBasisMatrix k i 1)) r_zero_x) (r.refl (stdBasisMatrix j k 1))",
          "proofState": 277,
          "pos": {
            "line": 79,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 82,
            "column": 96
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using r.mul (r.mul (r.refl (stdBasisMatrix k i 1)) r_zero_x) (r.refl (stdBasisMatrix j k 1))",
          "proofState": 278,
          "pos": {
            "line": 81,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nk : \u03b9\nx\u271d : k \u2208 Finset.univ\n\u22a2 r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)",
          "endPos": {
            "line": 82,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "RingCon.sum",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Matrix.addCommMonoid",
            "Matrix.stdBasisMatrix",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "AddCommSemigroup.toAddCommMagma",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "AddCommMonoid.toAddCommSemigroup",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "instHMul"
          ],
          "tactic": "have r_zero_sum := RingCon.sum this",
          "proofState": 279,
          "pos": {
            "line": 83,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 83,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Matrix.scalar",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "Ring.toNonAssocRing",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Matrix.addCommMonoid",
            "Matrix.stdBasisMatrix",
            "Field.toSemifield",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Matrix.nonAssocSemiring",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "have sum_eq_scalar : \u2211 k, (stdBasisMatrix k i 1) * x * (stdBasisMatrix j k 1) = scalar \u03b9 (x i j) :=\n  by\n  ext i' j'\n  simp [diagonal, sum_apply, mul_apply, stdBasisMatrix, ite_and, eq_comm]",
          "proofState": 280,
          "pos": {
            "line": 84,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 87,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Matrix.ext"
          ],
          "tactic": "ext i' j'",
          "proofState": 281,
          "pos": {
            "line": 86,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\n\u22a2 \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)",
          "endPos": {
            "line": 86,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "congrArg",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "Finset",
            "MulZeroClass.zero_mul",
            "Matrix.sum_apply",
            "Matrix.of",
            "AddMonoid.toAddZeroClass",
            "Finset.sum_ite_irrel",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Membership.mem",
            "Field.toDivisionRing",
            "mul_ite",
            "Equiv",
            "DivisionRing.toRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "Matrix.addCommMonoid",
            "Finset.instMembership",
            "ite_cond_eq_true",
            "Matrix.stdBasisMatrix",
            "Field.toSemifield",
            "Finset.sum_const_zero",
            "MulZeroClass.mul_zero",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "funext",
            "And",
            "Semifield.toDivisionSemiring",
            "Distrib.toMul",
            "ite_mul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "AddCommMonoid.toAddMonoid",
            "instDecidableAnd",
            "Mathlib.Data.Fintype.Basic._auxLemma.1",
            "EuclideanDomain.toCommRing",
            "mul_one",
            "ite_and",
            "ite_congr",
            "Finset.decidableMem",
            "OfNat.ofNat",
            "_auxLemma.2",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Not",
            "Finset.sum_congr",
            "Finset.sum",
            "Finset.sum_ite_eq",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "ite"
          ],
          "tactic": "simp [diagonal, sum_apply, mul_apply, stdBasisMatrix, ite_and, eq_comm]",
          "proofState": 282,
          "pos": {
            "line": 87,
            "column": 8
          },
          "goals": "case a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\ni' j' : \u03b9\n\u22a2 (\u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1) i' j' = (scalar \u03b9) (x i j) i' j'",
          "endPos": {
            "line": 87,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "AddMonoidWithOne.toOne",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Matrix.one",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have r_zero_one : r 0 1 := by\n  simpa [hij, Finset.sum_const_zero, sum_eq_scalar] using r.mul r_zero_sum (r.refl (scalar \u03b9 (x i j)\u207b\u00b9))",
          "proofState": 283,
          "pos": {
            "line": 88,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 90,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa [hij, Finset.sum_const_zero, sum_eq_scalar] using r.mul r_zero_sum (r.refl (scalar \u03b9 (x i j)\u207b\u00b9))",
          "proofState": 284,
          "pos": {
            "line": 89,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\n\u22a2 r 0 1",
          "endPos": {
            "line": 90,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have forall_r_zero a : r 0 a := by simpa using r.mul r_zero_one (r.refl a)",
          "proofState": 285,
          "pos": {
            "line": 91,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 91,
            "column": 80
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using r.mul r_zero_one (r.refl a)",
          "proofState": 286,
          "pos": {
            "line": 91,
            "column": 41
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\na : Matrix \u03b9 \u03b9 K\n\u22a2 r 0 a",
          "endPos": {
            "line": 91,
            "column": 80
          }
        },
        {
          "usedConstants": [
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Top.top",
            "Eq",
            "DFunLike.coe",
            "letFun"
          ],
          "tactic": "have forall_forall_r a b : r a b := by simpa using r.add (forall_r_zero (b - a)) (r.refl a)",
          "proofState": 287,
          "pos": {
            "line": 92,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 92,
            "column": 97
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using r.add (forall_r_zero (b - a)) (r.refl a)",
          "proofState": 288,
          "pos": {
            "line": 92,
            "column": 45
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\na b : Matrix \u03b9 \u03b9 K\n\u22a2 r a b",
          "endPos": {
            "line": 92,
            "column": 97
          }
        },
        {
          "usedConstants": [
            "RingCon.ext"
          ],
          "tactic": "apply RingCon.ext",
          "proofState": 289,
          "pos": {
            "line": 93,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\nforall_forall_r : \u2200 (a b : Matrix \u03b9 \u03b9 K), r a b\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 93,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Matrix",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "iff_self",
            "Iff",
            "Distrib.toMul",
            "True",
            "eq_true",
            "of_eq_true",
            "NonUnitalNonAssocSemiring.toDistrib",
            "implies_true",
            "DFunLike.coe",
            "Eq.trans",
            "forall_congr"
          ],
          "tactic": "simp [forall_forall_r]",
          "proofState": 290,
          "pos": {
            "line": 94,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\nforall_forall_r : \u2200 (a b : Matrix \u03b9 \u03b9 K), r a b\n\u22a2 \u2200 (x y : Matrix \u03b9 \u03b9 K), r x y \u2194 \u22a4 x y",
          "endPos": {
            "line": 94,
            "column": 28
          }
        }
      ],
      "env": 14
    }
  },
  {
    "file": "FLT/HaarMeasure/DomMulActMeasure.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "MeasurableEquiv.instEquivLike",
            "DomMulAct",
            "Equiv.instFunLike",
            "instHSMul",
            "MeasureTheory.Measure",
            "MeasurableEquiv.map_apply",
            "DivInvOneMonoid.toInvOneClass",
            "DistribMulAction.toDistribSMul",
            "AddMonoid.toAddZeroClass",
            "Group.toDivisionMonoid",
            "AddCommGroup.toAddGroup",
            "DivisionMonoid.toDivInvOneMonoid",
            "Equiv",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "DomMulAct.mk",
            "Group.toDivInvMonoid",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "Set.preimage",
            "MeasureTheory.Measure.map",
            "AddZeroClass.toZero",
            "ENNReal",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "InvOneClass.toInv",
            "SubNegMonoid.toAddMonoid",
            "Equiv.symm",
            "MeasurableEquiv",
            "Set.smulSet",
            "DFunLike.coe",
            "Eq.trans",
            "EquivLike.toFunLike",
            "DistribMulAction.toMulAction",
            "MeasurableEquiv.smul",
            "MeasureTheory.Measure.instFunLike",
            "Set"
          ],
          "tactic": "refine ((MeasurableEquiv.smul ((DomMulAct.mk.symm g : G)\u207b\u00b9)).map_apply _).trans ?_",
          "proofState": 291,
          "pos": {
            "line": 21,
            "column": 2
          },
          "goals": "G : Type u_1\nA : Type u_2\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : AddCommGroup A\ninst\u271d\u00b3 : DistribMulAction G A\ninst\u271d\u00b2 : MeasurableSpace A\ninst\u271d\u00b9 : MeasurableSpace G\ninst\u271d : MeasurableSMul G A\n\u03bc : Measure A\ng : G\u1d48\u1d50\u1d43\ns : Set A\n\u22a2 (g \u2022 \u03bc) s = \u03bc (DomMulAct.mk.symm g \u2022 s)",
          "endPos": {
            "line": 21,
            "column": 84
          }
        },
        {
          "usedConstants": [
            "eq_of_heq"
          ],
          "tactic": "congr 1",
          "proofState": 292,
          "pos": {
            "line": 22,
            "column": 2
          },
          "goals": "G : Type u_1\nA : Type u_2\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : AddCommGroup A\ninst\u271d\u00b3 : DistribMulAction G A\ninst\u271d\u00b2 : MeasurableSpace A\ninst\u271d\u00b9 : MeasurableSpace G\ninst\u271d : MeasurableSMul G A\n\u03bc : Measure A\ng : G\u1d48\u1d50\u1d43\ns : Set A\n\u22a2 \u03bc (\u21d1(MeasurableEquiv.smul (DomMulAct.mk.symm g)\u207b\u00b9) \u207b\u00b9' s) = \u03bc (DomMulAct.mk.symm g \u2022 s)",
          "endPos": {
            "line": 22,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "DomMulAct",
            "Equiv.instFunLike",
            "AddCommGroup.toAddGroup",
            "Equiv",
            "DivInvMonoid.toMonoid",
            "DomMulAct.mk",
            "Set.preimage_smul_inv",
            "Group.toDivInvMonoid",
            "AddGroup.toSubNegMonoid",
            "SubNegMonoid.toAddMonoid",
            "Equiv.symm",
            "DFunLike.coe",
            "DistribMulAction.toMulAction"
          ],
          "tactic": "exact Set.preimage_smul_inv (DomMulAct.mk.symm g) s",
          "proofState": 293,
          "pos": {
            "line": 23,
            "column": 2
          },
          "goals": "case h.e_6.h\nG : Type u_1\nA : Type u_2\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : AddCommGroup A\ninst\u271d\u00b3 : DistribMulAction G A\ninst\u271d\u00b2 : MeasurableSpace A\ninst\u271d\u00b9 : MeasurableSpace G\ninst\u271d : MeasurableSMul G A\n\u03bc : Measure A\ng : G\u1d48\u1d50\u1d43\ns : Set A\n\u22a2 \u21d1(MeasurableEquiv.smul (DomMulAct.mk.symm g)\u207b\u00b9) \u207b\u00b9' s = DomMulAct.mk.symm g \u2022 s",
          "endPos": {
            "line": 23,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "DomMulAct",
            "MonoidWithZero.toMulActionWithZero",
            "Equiv.instFunLike",
            "instHSMul",
            "MeasureTheory.Measure",
            "IsScalarTower.right",
            "DivInvOneMonoid.toInvOneClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "AddMonoid.toAddZeroClass",
            "ENNReal.instIsScalarTowerNNReal",
            "Group.toDivisionMonoid",
            "AddCommGroup.toAddGroup",
            "Algebra.toSMul",
            "DivisionMonoid.toDivInvOneMonoid",
            "Algebra.id",
            "Equiv",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "MeasureTheory.Measure.instSMul",
            "NNReal",
            "OrderedSemiring.toSemiring",
            "DomMulAct.mk",
            "Group.toDivInvMonoid",
            "OrderedCommSemiring.toCommSemiring",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "OrderedCommSemiring.toOrderedSemiring",
            "MeasureTheory.Measure.map",
            "AddZeroClass.toZero",
            "True",
            "instNNRealCommSemiring",
            "eq_self",
            "ENNReal",
            "of_eq_true",
            "ENNReal.instOrderedCommSemiring",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "InvOneClass.toInv",
            "ENNReal.instAlgebraNNReal",
            "MeasureTheory.Measure.map_smul",
            "MulZeroOneClass.toMulZeroClass",
            "SubNegMonoid.toAddMonoid",
            "Equiv.symm",
            "Eq",
            "DFunLike.coe",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 294,
          "pos": {
            "line": 33,
            "column": 57
          },
          "goals": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc\u271d \u03bd : Measure A\ng\u271d : G\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc\u271d.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\nr : \u211d\u22650\ng : G\u1d48\u1d50\u1d43\n\u03bc : Measure A\n\u22a2 r \u2022 map (fun x => DomMulAct.mk.symm g\u207b\u00b9 \u2022 x) \u03bc = map (fun x => DomMulAct.mk.symm g\u207b\u00b9 \u2022 x) (r \u2022 \u03bc)",
          "endPos": {
            "line": 33,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "exists_continuous_nonneg_pos",
            "OfNat.ofNat"
          ],
          "tactic": "obtain \u27e8\u27e8f, f_cont\u27e9, f_comp, f_nonneg, f_zero\u27e9 : \u2203 f : C(A, \u211d), HasCompactSupport f \u2227 0 \u2264 f \u2227 f 0 \u2260 0 :=\n  exists_continuous_nonneg_pos 0",
          "proofState": 295,
          "pos": {
            "line": 47,
            "column": 2
          },
          "goals": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\n\u22a2 (g \u2022 \u03bc).addHaarScalarFactor (g \u2022 \u03bd) = \u03bc.addHaarScalarFactor \u03bd",
          "endPos": {
            "line": 48,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure.instIsAddHaarMeasureHSMulDomMulAct",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsFiniteMeasureOnCompacts",
            "DomMulAct",
            "InnerProductSpace.toNormedSpace",
            "Real",
            "instHSMul",
            "MeasureTheory.Measure",
            "Real.instZero",
            "Real.instRCLike",
            "DistribMulAction.toDistribSMul",
            "Continuous.integral_pos_of_hasCompactSupport_nonneg_nonzero",
            "AddMonoid.toAddZeroClass",
            "AddCommGroup.toAddGroup",
            "DomMulAct.instMonoidOfMulOpposite",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsAddLeftInvariant",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "NNReal",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Group.toDivInvMonoid",
            "LT.lt.ne'",
            "MeasureTheory.Measure.instAddCommMonoid",
            "BorelSpace.opensMeasurable",
            "MeasureTheory.integral",
            "MeasureTheory.Measure.addHaarScalarFactor",
            "AddZeroClass.toZero",
            "MulOpposite.instMonoid",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "NormedField.toNormedSpace",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "NegZeroClass.toZero",
            "Eq",
            "letFun",
            "MeasureTheory.Measure.instDistribMulActionDomMulAct",
            "Real.instPreorder",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsOpenPosMeasure",
            "RCLike.toInnerProductSpaceReal"
          ],
          "tactic": "have int_f_ne_zero : \u222b x, f x \u2202g \u2022 \u03bd \u2260 0 :=\n  (f_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero f_comp f_nonneg f_zero).ne'",
          "proofState": 296,
          "pos": {
            "line": 49,
            "column": 2
          },
          "goals": "case intro.mk.intro.intro\nG : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\n\u22a2 (g \u2022 \u03bc).addHaarScalarFactor (g \u2022 \u03bd) = \u03bc.addHaarScalarFactor \u03bd",
          "endPos": {
            "line": 50,
            "column": 88
          }
        },
        {
          "usedConstants": [
            "NNReal.coe_injective"
          ],
          "tactic": "apply NNReal.coe_injective",
          "proofState": 297,
          "pos": {
            "line": 51,
            "column": 2
          },
          "goals": "case intro.mk.intro.intro\nG : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\nint_f_ne_zero : \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0\n\u22a2 (g \u2022 \u03bc).addHaarScalarFactor (g \u2022 \u03bd) = \u03bc.addHaarScalarFactor \u03bd",
          "endPos": {
            "line": 51,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure.instIsAddHaarMeasureHSMulDomMulAct",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsFiniteMeasureOnCompacts",
            "Eq.mpr",
            "DomMulAct",
            "InnerProductSpace.toNormedSpace",
            "Real",
            "instHSMul",
            "MeasureTheory.Measure",
            "instHDiv",
            "MeasureTheory.Measure.addHaarScalarFactor_eq_integral_div",
            "Real.instRCLike",
            "congrArg",
            "DistribMulAction.toDistribSMul",
            "Real.instDivInvMonoid",
            "AddMonoid.toAddZeroClass",
            "AddCommGroup.toAddGroup",
            "DomMulAct.instMonoidOfMulOpposite",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsAddLeftInvariant",
            "id",
            "HDiv.hDiv",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "Group.toDivInvMonoid",
            "MeasureTheory.Measure.instAddCommMonoid",
            "MeasureTheory.integral",
            "MeasureTheory.Measure.addHaarScalarFactor",
            "AddZeroClass.toZero",
            "MulOpposite.instMonoid",
            "DivInvMonoid.toDiv",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "Eq",
            "NNReal.toReal",
            "MeasureTheory.Measure.instDistribMulActionDomMulAct",
            "RCLike.toInnerProductSpaceReal"
          ],
          "tactic": "rw [addHaarScalarFactor_eq_integral_div (g \u2022 \u03bc) (g \u2022 \u03bd) f_cont f_comp int_f_ne_zero, integral_domSMul, integral_domSMul]",
          "proofState": 298,
          "pos": {
            "line": 52,
            "column": 2
          },
          "goals": "case intro.mk.intro.intro.a\nG : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\nint_f_ne_zero : \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0\n\u22a2 \u2191((g \u2022 \u03bc).addHaarScalarFactor (g \u2022 \u03bd)) = \u2191(\u03bc.addHaarScalarFactor \u03bd)",
          "endPos": {
            "line": 53,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Continuous.comp'",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsFiniteMeasureOnCompacts",
            "DomMulAct",
            "InnerProductSpace.toNormedSpace",
            "Real",
            "Equiv.instFunLike",
            "instHSMul",
            "instHDiv",
            "MeasureTheory.Measure.addHaarScalarFactor_eq_integral_div",
            "DivInvOneMonoid.toInvOneClass",
            "Real.instRCLike",
            "DistribMulAction.toDistribSMul",
            "Real.instDivInvMonoid",
            "AddMonoid.toAddZeroClass",
            "PseudoMetricSpace.toUniformSpace",
            "continuous_id'",
            "Group.toDivisionMonoid",
            "AddCommGroup.toAddGroup",
            "DivisionMonoid.toDivInvOneMonoid",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsAddLeftInvariant",
            "Equiv",
            "HDiv.hDiv",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "DomMulAct.mk",
            "Group.toDivInvMonoid",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "MeasureTheory.integral",
            "MeasureTheory.Measure.addHaarScalarFactor",
            "AddZeroClass.toZero",
            "DivInvMonoid.toDiv",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "Real.pseudoMetricSpace",
            "InvOneClass.toInv",
            "SubNegMonoid.toAddMonoid",
            "Equiv.symm",
            "Eq.symm",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "Continuous.const_smul",
            "UniformSpace.toTopologicalSpace",
            "DFunLike.coe",
            "NNReal.toReal",
            "RCLike.toInnerProductSpaceReal"
          ],
          "tactic": "refine (addHaarScalarFactor_eq_integral_div _ _ (by fun_prop) ?_ ?_).symm",
          "proofState": 299,
          "pos": {
            "line": 54,
            "column": 2
          },
          "goals": "case intro.mk.intro.intro.a\nG : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\nint_f_ne_zero : \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0\n\u22a2 (\u222b (x : A), f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x) \u2202\u03bc) / \u222b (x : A), f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x) \u2202\u03bd =\n    \u2191(\u03bc.addHaarScalarFactor \u03bd)",
          "endPos": {
            "line": 54,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "Continuous.comp'",
            "DomMulAct",
            "Real",
            "Equiv.instFunLike",
            "instHSMul",
            "DivInvOneMonoid.toInvOneClass",
            "DistribMulAction.toDistribSMul",
            "AddMonoid.toAddZeroClass",
            "PseudoMetricSpace.toUniformSpace",
            "continuous_id'",
            "Group.toDivisionMonoid",
            "AddCommGroup.toAddGroup",
            "DivisionMonoid.toDivInvOneMonoid",
            "Equiv",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "DomMulAct.mk",
            "Group.toDivInvMonoid",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "AddZeroClass.toZero",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "Real.pseudoMetricSpace",
            "InvOneClass.toInv",
            "SubNegMonoid.toAddMonoid",
            "Equiv.symm",
            "Continuous.const_smul",
            "UniformSpace.toTopologicalSpace",
            "DFunLike.coe"
          ],
          "tactic": "fun_prop",
          "proofState": 300,
          "pos": {
            "line": 54,
            "column": 54
          },
          "goals": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\nint_f_ne_zero : \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0\n\u22a2 Continuous fun x => f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x)",
          "endPos": {
            "line": 54,
            "column": 62
          }
        },
        {
          "usedConstants": [
            "DomMulAct",
            "HasCompactSupport.comp_isClosedEmbedding",
            "Real",
            "Equiv.instFunLike",
            "instHSMul",
            "DivInvOneMonoid.toInvOneClass",
            "Real.instZero",
            "DistribMulAction.toDistribSMul",
            "ContinuousMap.mk",
            "ContinuousMap",
            "AddMonoid.toAddZeroClass",
            "PseudoMetricSpace.toUniformSpace",
            "Group.toDivisionMonoid",
            "AddCommGroup.toAddGroup",
            "DivisionMonoid.toDivInvOneMonoid",
            "Equiv",
            "Homeomorph.smul",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "DomMulAct.mk",
            "Group.toDivInvMonoid",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "AddZeroClass.toZero",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "Real.pseudoMetricSpace",
            "InvOneClass.toInv",
            "SubNegMonoid.toAddMonoid",
            "Equiv.symm",
            "Homeomorph.isClosedEmbedding",
            "UniformSpace.toTopologicalSpace",
            "ContinuousMap.instFunLike",
            "DFunLike.coe",
            "DistribMulAction.toMulAction"
          ],
          "tactic": "exact f_comp.comp_isClosedEmbedding (Homeomorph.smul _).isClosedEmbedding",
          "proofState": 301,
          "pos": {
            "line": 55,
            "column": 4
          },
          "goals": "case intro.mk.intro.intro.a.refine_1\nG : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\nint_f_ne_zero : \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0\n\u22a2 HasCompactSupport fun x => f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x)",
          "endPos": {
            "line": 55,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "DomMulAct",
            "InnerProductSpace.toNormedSpace",
            "Real",
            "Equiv.instFunLike",
            "instHSMul",
            "MeasureTheory.Measure",
            "DivInvOneMonoid.toInvOneClass",
            "Real.instZero",
            "Real.instRCLike",
            "congrArg",
            "DistribMulAction.toDistribSMul",
            "AddMonoid.toAddZeroClass",
            "Group.toDivisionMonoid",
            "AddCommGroup.toAddGroup",
            "DivisionMonoid.toDivInvOneMonoid",
            "DomMulAct.instMonoidOfMulOpposite",
            "id",
            "Equiv",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "Ne",
            "DomMulAct.mk",
            "Group.toDivInvMonoid",
            "MeasureTheory.Measure.instAddCommMonoid",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "MeasureTheory.integral",
            "AddZeroClass.toZero",
            "MulOpposite.instMonoid",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MeasureTheory.Measure.integral_domSMul",
            "InvOneClass.toInv",
            "SubNegMonoid.toAddMonoid",
            "Equiv.symm",
            "OfNat.ofNat",
            "Eq.symm",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "Eq",
            "DFunLike.coe",
            "MeasureTheory.Measure.instDistribMulActionDomMulAct",
            "RCLike.toInnerProductSpaceReal"
          ],
          "tactic": "rw [\u2190 integral_domSMul]",
          "proofState": 302,
          "pos": {
            "line": 56,
            "column": 4
          },
          "goals": "case intro.mk.intro.intro.a.refine_2\nG : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\nint_f_ne_zero : \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0\n\u22a2 \u222b (x : A), f ((DomMulAct.mk.symm g)\u207b\u00b9 \u2022 x) \u2202\u03bd \u2260 0",
          "endPos": {
            "line": 56,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure.instIsAddHaarMeasureHSMulDomMulAct",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsFiniteMeasureOnCompacts",
            "DomMulAct",
            "Real",
            "instHSMul",
            "MeasureTheory.Measure",
            "Real.instZero",
            "DistribMulAction.toDistribSMul",
            "Continuous.integral_pos_of_hasCompactSupport_nonneg_nonzero",
            "AddMonoid.toAddZeroClass",
            "AddCommGroup.toAddGroup",
            "DomMulAct.instMonoidOfMulOpposite",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Group.toDivInvMonoid",
            "LT.lt.ne'",
            "MeasureTheory.Measure.instAddCommMonoid",
            "BorelSpace.opensMeasurable",
            "MeasureTheory.integral",
            "AddZeroClass.toZero",
            "MulOpposite.instMonoid",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "NormedField.toNormedSpace",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "MeasureTheory.Measure.instDistribMulActionDomMulAct",
            "Real.instPreorder",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsOpenPosMeasure"
          ],
          "tactic": "exact (f_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero f_comp f_nonneg f_zero).ne'",
          "proofState": 303,
          "pos": {
            "line": 57,
            "column": 4
          },
          "goals": "case intro.mk.intro.intro.a.refine_2\nG : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\nf : A \u2192 \u211d\nf_cont : Continuous f\nf_comp : HasCompactSupport \u21d1{ toFun := f, continuous_toFun := f_cont }\nf_nonneg : 0 \u2264 { toFun := f, continuous_toFun := f_cont }\nf_zero : { toFun := f, continuous_toFun := f_cont } 0 \u2260 0\nint_f_ne_zero : \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0\n\u22a2 \u222b (x : A), f x \u2202g \u2022 \u03bd \u2260 0",
          "endPos": {
            "line": 57,
            "column": 94
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure.instIsAddHaarMeasureHSMulDomMulAct",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsFiniteMeasureOnCompacts",
            "Eq.mpr",
            "DomMulAct",
            "instHSMul",
            "MeasureTheory.Measure",
            "HMul.hMul",
            "congrArg",
            "DistribMulAction.toDistribSMul",
            "AddMonoid.toAddZeroClass",
            "AddCommGroup.toAddGroup",
            "DomMulAct.instMonoidOfMulOpposite",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsAddLeftInvariant",
            "id",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "NNReal",
            "MeasureTheory.Measure.addHaarScalarFactor_eq_mul",
            "Group.toDivInvMonoid",
            "MeasureTheory.Measure.instAddCommMonoid",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "MeasureTheory.Measure.addHaarScalarFactor",
            "AddZeroClass.toZero",
            "MulOpposite.instMonoid",
            "NonUnitalNonAssocSemiring.toDistrib",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "instNNRealSemiring",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MeasureTheory.Measure.instDistribMulActionDomMulAct",
            "instHMul"
          ],
          "tactic": "rw [addHaarScalarFactor_eq_mul _ (g \u2022 \u03bd), addHaarScalarFactor_domSMul, mul_comm, \u2190 addHaarScalarFactor_eq_mul]",
          "proofState": 304,
          "pos": {
            "line": 62,
            "column": 2
          },
          "goals": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\n\u22a2 \u03bc.addHaarScalarFactor (g \u2022 \u03bc) = \u03bd.addHaarScalarFactor (g \u2022 \u03bd)",
          "endPos": {
            "line": 63,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure.instIsAddHaarMeasureHSMulDomMulAct",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsFiniteMeasureOnCompacts",
            "Eq.mpr",
            "DomMulAct",
            "instHSMul",
            "MeasureTheory.Measure",
            "HMul.hMul",
            "congrArg",
            "DistribMulAction.toDistribSMul",
            "AddMonoid.toAddZeroClass",
            "AddCommGroup.toAddGroup",
            "DomMulAct.instMonoidOfMulOpposite",
            "MeasureTheory.Measure.IsAddHaarMeasure.toIsAddLeftInvariant",
            "id",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "NNReal",
            "MeasureTheory.Measure.addHaarScalarFactor_eq_mul",
            "Group.toDivInvMonoid",
            "MeasureTheory.Measure.instAddCommMonoid",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "MeasureTheory.Measure.addHaarScalarFactor",
            "AddZeroClass.toZero",
            "MulOpposite.instMonoid",
            "NonUnitalNonAssocSemiring.toDistrib",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "instNNRealSemiring",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MeasureTheory.Measure.instDistribMulActionDomMulAct",
            "instHMul"
          ],
          "tactic": "rw [addHaarScalarFactor_eq_mul _ (g \u2022 \u03bd), addHaarScalarFactor_domSMul, mul_comm, \u2190 addHaarScalarFactor_eq_mul]",
          "proofState": 305,
          "pos": {
            "line": 68,
            "column": 2
          },
          "goals": "G : Type u_1\nA : Type u_2\ninst\u271d\u00b9\u00b2 : Group G\ninst\u271d\u00b9\u00b9 : AddCommGroup A\ninst\u271d\u00b9\u2070 : DistribMulAction G A\ninst\u271d\u2079 : MeasurableSpace A\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : MeasurableSMul G A\n\u03bc \u03bd : Measure A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : BorelSpace A\ninst\u271d\u2074 : TopologicalAddGroup A\ninst\u271d\u00b3 : LocallyCompactSpace A\ninst\u271d\u00b2 : ContinuousConstSMul G A\ninst\u271d\u00b9 : \u03bc.IsAddHaarMeasure\ninst\u271d : \u03bd.IsAddHaarMeasure\ng : G\u1d48\u1d50\u1d43\n\u22a2 (g \u2022 \u03bc).addHaarScalarFactor \u03bc = (g \u2022 \u03bd).addHaarScalarFactor \u03bd",
          "endPos": {
            "line": 69,
            "column": 43
          }
        }
      ],
      "env": 15
    }
  },
  {
    "file": "FLT/HaarMeasure/MeasurableSpacePadics.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [],
          "tactic": "simpa only [Metric.closedBall, dist_zero_right] using isCompact_closedBall (0 : \u211a_[p]) 1",
          "proofState": 307,
          "pos": {
            "line": 29,
            "column": 19
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 IsCompact {y | \u2016y\u2016 \u2264 1}",
          "endPos": {
            "line": 30,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "SeminormedAddGroup.toAddGroup",
            "congrArg",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "Eq.mp",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "TopologicalSpace.Compacts.carrier",
            "TopologicalSpace.Compacts.mk",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "funext",
            "Padic.instZero",
            "Set.Nonempty",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "interior",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "ProperSpace.isCompact_closedBall",
            "NormedField.toNormedCommRing",
            "IsOpen.interior_eq",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "dist_zero_right",
            "UniformSpace.toTopologicalSpace",
            "NegZeroClass.toZero",
            "Eq",
            "Padic.instProperSpace",
            "IsCompact",
            "Set"
          ],
          "tactic": "rw [IsOpen.interior_eq]",
          "proofState": 308,
          "pos": {
            "line": 32,
            "column": 4
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 (interior { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier).Nonempty",
          "endPos": {
            "line": 32,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "SeminormedAddGroup.toAddGroup",
            "Real.instZero",
            "Real.orderedSemiring",
            "congrArg",
            "norm_zero",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "Membership.mem",
            "OrderedSemiring.zeroLEOneClass",
            "Eq.mp",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "TopologicalSpace.Compacts.carrier",
            "TopologicalSpace.Compacts.mk",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "funext",
            "Padic.instZero",
            "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.1",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "True",
            "Exists.intro",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "ProperSpace.isCompact_closedBall",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "dist_zero_right",
            "UniformSpace.toTopologicalSpace",
            "NegZeroClass.toZero",
            "Set.instMembership",
            "Padic.instProperSpace",
            "Eq.trans",
            "IsCompact",
            "Set"
          ],
          "tactic": "exact \u27e80, by simp\u27e9",
          "proofState": 309,
          "pos": {
            "line": 33,
            "column": 6
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier.Nonempty",
          "endPos": {
            "line": 33,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "SeminormedAddGroup.toAddGroup",
            "Real.instZero",
            "Real.orderedSemiring",
            "congrArg",
            "norm_zero",
            "OrderedSemiring.zeroLEOneClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.1",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "True",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 310,
          "pos": {
            "line": 33,
            "column": 19
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 0 \u2208 { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier",
          "endPos": {
            "line": 33,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "id",
            "IsOpen"
          ],
          "tactic": "simpa only [Metric.closedBall, dist_zero_right] using IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero",
          "proofState": 311,
          "pos": {
            "line": 34,
            "column": 6
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 IsOpen { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier",
          "endPos": {
            "line": 35,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "PseudoMetricSpace.toUniformSpace",
            "Subtype",
            "LE.le",
            "Real.instOne",
            "Padic.normedField",
            "Topology.IsOpenEmbedding.measurableEmbedding",
            "Padic.instBorelSpace",
            "SeminormedCommRing.toSeminormedRing",
            "MeasurableEmbedding",
            "Padic",
            "One.toOfNat1",
            "Subtype.instMeasurableSpace",
            "instTopologicalSpaceSubtype",
            "Padic.instMeasurableSpace",
            "SeminormedRing.toPseudoMetricSpace",
            "PadicInt.isOpenEmbedding_coe",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "Subtype.val",
            "UniformSpace.toTopologicalSpace"
          ],
          "tactic": "convert isOpenEmbedding_coe.measurableEmbedding",
          "proofState": 312,
          "pos": {
            "line": 53,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 MeasurableEmbedding Subtype.val",
          "endPos": {
            "line": 53,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toSeminormedCommRing",
            "PadicInt",
            "inferInstanceAs",
            "PseudoMetricSpace.toUniformSpace",
            "BorelSpace",
            "PadicInt.instMeasurableSpace",
            "PadicInt.instNormedCommRing",
            "SeminormedCommRing.toSeminormedRing",
            "PadicInt.instBorelSpace",
            "SeminormedRing.toPseudoMetricSpace",
            "UniformSpace.toTopologicalSpace"
          ],
          "tactic": "exact inferInstanceAs (BorelSpace \u2124_[p])",
          "proofState": 313,
          "pos": {
            "line": 54,
            "column": 2
          },
          "goals": "case convert_3\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 BorelSpace { x // \u2016x\u2016 \u2264 1 }",
          "endPos": {
            "line": 54,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure",
            "Preorder.toLT",
            "PadicInt",
            "CompleteLattice.instOmegaCompletePartialOrder",
            "Mathlib.Data.ENNReal.Basic._auxLemma.40",
            "congrArg",
            "CompletelyDistribLattice.toCompleteLattice",
            "Set.univ",
            "MeasureTheory.MeasureSpace.toMeasurableSpace",
            "PartialOrder.toPreorder",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "PadicInt.instMeasureSpace",
            "instENNRealTop",
            "AddMonoidWithOne.toOne",
            "MeasureTheory.MeasureSpace.volume",
            "PadicInt.volume_univ",
            "LT.lt",
            "True",
            "OmegaCompletePartialOrder.toPartialOrder",
            "ENNReal",
            "of_eq_true",
            "One.toOfNat1",
            "instENNRealAddCommMonoidWithOne",
            "ENNReal.instCompleteLinearOrder",
            "CompleteLinearOrder.toCompletelyDistribLattice",
            "Top.top",
            "OfNat.ofNat",
            "DFunLike.coe",
            "Eq.trans",
            "MeasureTheory.Measure.instFunLike",
            "Set"
          ],
          "tactic": "simp\n  -- https://github.com/ImperialCollegeLondon/FLT/issues/278",
          "proofState": 314,
          "pos": {
            "line": 64,
            "column": 28
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 volume Set.univ < \u22a4",
          "endPos": {
            "line": 64,
            "column": 32
          }
        }
      ],
      "sorries": [
        {
          "proofState": 306,
          "pos": {
            "line": 67,
            "column": 87
          },
          "goal": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\ns : Set \u2124_[p]\n\u22a2 volume (Subtype.val '' s) = volume s",
          "endPos": {
            "line": 67,
            "column": 92
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 67,
            "column": 14
          },
          "endPos": {
            "line": 67,
            "column": 24
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 16
    }
  },
  {
    "file": "FLT/GroupScheme/FiniteFlat.lean",
    "output": {
      "env": 17
    }
  },
  {
    "file": "FLT/GlobalLanglandsConjectures/GLnDefs.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "DedekindDomain.FiniteAdeleRing.mul_nonZeroDivisor_mem_finiteIntegralAdeles"
          ],
          "tactic": "exact mul_nonZeroDivisor_mem_finiteIntegralAdeles a",
          "proofState": 319,
          "pos": {
            "line": 86,
            "column": 2
          },
          "goals": "R : Type u_1\nK : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\na : FiniteAdeleRing R K\n\u22a2 \u2203 b c, a * \u2191\u2191b = \u2191c",
          "endPos": {
            "line": 86,
            "column": 53
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction x using TensorProduct.induction_on generalizing y",
          "proofState": 320,
          "pos": {
            "line": 118,
            "column": 4
          },
          "goals": "S : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx y : A \u2297[R] L\n\u22a2 \u2045x, a \u2022 y\u2046 = a \u2022 \u2045x, y\u2046",
          "endPos": {
            "line": 118,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "smul_zero",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "congr",
            "True",
            "eq_self",
            "zero_lie",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "NegZeroClass.toZero",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 321,
          "pos": {
            "line": 119,
            "column": 6
          },
          "goals": "case zero\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\ny : A \u2297[R] L\n\u22a2 \u20450, a \u2022 y\u2046 = a \u2022 \u20450, y\u2046",
          "endPos": {
            "line": 119,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction y using TensorProduct.induction_on",
          "proofState": 322,
          "pos": {
            "line": 120,
            "column": 6
          },
          "goals": "case tmul\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d : A\ny\u271d : L\ny : A \u2297[R] L\n\u22a2 \u2045x\u271d \u2297\u209c[R] y\u271d, a \u2022 y\u2046 = a \u2022 \u2045x\u271d \u2297\u209c[R] y\u271d, y\u2046",
          "endPos": {
            "line": 120,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "smul_zero",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "congr",
            "True",
            "eq_self",
            "lie_zero",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "TensorProduct.tmul",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "NegZeroClass.toZero",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 323,
          "pos": {
            "line": 121,
            "column": 8
          },
          "goals": "case tmul.zero\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d : A\ny\u271d : L\n\u22a2 \u2045x\u271d \u2297\u209c[R] y\u271d, a \u2022 0\u2046 = a \u2022 \u2045x\u271d \u2297\u209c[R] y\u271d, 0\u2046",
          "endPos": {
            "line": 121,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Algebra.mul_smul_comm",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "Algebra.toSMul",
            "DistribSMul.toSMulZeroClass",
            "LieRingModule.toBracket",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [TensorProduct.smul_tmul']",
          "proofState": 324,
          "pos": {
            "line": 122,
            "column": 8
          },
          "goals": "case tmul.tmul\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d : A\ny\u271d : L\n\u22a2 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 x\u271d \u2297\u209c[R] y\u271d\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d \u2297\u209c[R] y\u271d\u2046",
          "endPos": {
            "line": 122,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "DistribSMul.toSMulZeroClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "TensorProduct.leftDistribMulAction",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "TensorProduct.addZeroClass",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "AddCommSemigroup.toAddCommMagma",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "AddCommMonoid.toAddCommSemigroup",
            "AddZeroClass.toAdd",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "smul_add",
            "MonoidWithZero.toMonoid",
            "lie_add",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 325,
          "pos": {
            "line": 123,
            "column": 8
          },
          "goals": "case tmul.add\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 x\u271d\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d\u2046\na\u271d : \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 y\u271d\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, y\u271d\u2046\n\u22a2 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 (x\u271d + y\u271d)\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d + y\u271d\u2046",
          "endPos": {
            "line": 123,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "DistribSMul.toSMulZeroClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "TensorProduct.leftDistribMulAction",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "TensorProduct.addZeroClass",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "AddCommSemigroup.toAddCommMagma",
            "CommRing.toRing",
            "AddCommMonoid.toAddCommSemigroup",
            "AddZeroClass.toAdd",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "smul_add",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero",
            "add_lie"
          ],
          "tactic": "simp_all [add_lie]",
          "proofState": 326,
          "pos": {
            "line": 124,
            "column": 6
          },
          "goals": "case add\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : \u2200 (y : A \u2297[R] L), \u2045x\u271d, a \u2022 y\u2046 = a \u2022 \u2045x\u271d, y\u2046\na\u271d : \u2200 (y : A \u2297[R] L), \u2045y\u271d, a \u2022 y\u2046 = a \u2022 \u2045y\u271d, y\u2046\ny : A \u2297[R] L\n\u22a2 \u2045x\u271d + y\u271d, a \u2022 y\u2046 = a \u2022 \u2045x\u271d + y\u271d, y\u2046",
          "endPos": {
            "line": 124,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Bracket.ext"
          ],
          "tactic": "ext x y",
          "proofState": 327,
          "pos": {
            "line": 131,
            "column": 2
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\n\u22a2 LieAlgebra.ExtendScalars.instBracketTensorProduct R A B B = Ring.instBracket",
          "endPos": {
            "line": 131,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.bracketBilin_apply_apply",
            "Algebra.to_smulCommClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "Ring.instBracket",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Eq.rec",
            "Algebra.toModule",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap.module",
            "LinearMap",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieAlgebra.ExtendScalars.instBracketTensorProduct",
            "MulActionWithZero.toSMulWithZero",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "Algebra.TensorProduct.instNonUnitalNonAssocRing",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "conv_lhs => rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 328,
          "pos": {
            "line": 132,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 \u2045x, y\u2046 = \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DedekindDomain.bracketBilin_apply_apply",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LieRingModule.toBracket",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 329,
          "pos": {
            "line": 132,
            "column": 14
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n| \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DedekindDomain.bracketBilin_apply_apply",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LieRingModule.toBracket",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 330,
          "pos": {
            "line": 132,
            "column": 14
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n| \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DedekindDomain.bracketBilin_apply_apply",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LieRingModule.toBracket",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 331,
          "pos": {
            "line": 132,
            "column": 14
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n| \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.bracketBilin_apply_apply",
            "Algebra.to_smulCommClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "Ring.instBracket",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.toModule",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap.module",
            "LinearMap",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "Algebra.TensorProduct.instRing",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "Algebra.TensorProduct.instNonUnitalNonAssocRing",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "MulZeroClass.toZero",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ (_) (.ofAssociativeAlgebra) _ _ (_) (_) x y]",
          "proofState": 332,
          "pos": {
            "line": 133,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = \u2045x, y\u2046",
          "endPos": {
            "line": 133,
            "column": 86
          }
        },
        {
          "usedConstants": [],
          "tactic": "rotate_left",
          "proofState": 333,
          "pos": {
            "line": 134,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 LieModule R (A \u2297[R] B) (A \u2297[R] B)",
          "endPos": {
            "line": 134,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "lieAlgebraSelfModule",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "CommRing.toRing",
            "Ring.toSemiring",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "exact @lieAlgebraSelfModule ..",
          "proofState": 334,
          "pos": {
            "line": 135,
            "column": 2
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 LieModule R (A \u2297[R] B) (A \u2297[R] B)\ncase bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y",
          "endPos": {
            "line": 135,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.toModule",
            "LieAlgebra.ExtendScalars.instLieRing",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "LinearMap.congr_fun\u2082",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "AddZeroClass.toZero",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "refine LinearMap.congr_fun\u2082 ?_ x y",
          "proofState": 335,
          "pos": {
            "line": 136,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y",
          "endPos": {
            "line": 136,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "TensorProduct.AlgebraTensorModule.curry_injective"
          ],
          "tactic": "ext xa xb ya yb",
          "proofState": 336,
          "pos": {
            "line": 137,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 bracketBilin R (A \u2297[R] B) (A \u2297[R] B) = bracketBilin R (A \u2297[R] B) (A \u2297[R] B)",
          "endPos": {
            "line": 137,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "LinearMap.instFunLike",
            "id",
            "LinearMap",
            "Eq",
            "DFunLike.coe"
          ],
          "tactic": "change @Bracket.bracket _ _ _ (xa \u2297\u209c[R] xb) (ya \u2297\u209c[R] yb) = _",
          "proofState": 337,
          "pos": {
            "line": 138,
            "column": 2
          },
          "goals": "case bracket.h.h.a.h.h.a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\nxa : A\nxb : B\nya : A\nyb : B\n\u22a2 ((TensorProduct.AlgebraTensorModule.curry\n          (((TensorProduct.AlgebraTensorModule.curry (bracketBilin R (A \u2297[R] B) (A \u2297[R] B))) xa) xb))\n        ya)\n      yb =\n    ((TensorProduct.AlgebraTensorModule.curry\n          (((TensorProduct.AlgebraTensorModule.curry (bracketBilin R (A \u2297[R] B) (A \u2297[R] B))) xa) xb))\n        ya)\n      yb",
          "endPos": {
            "line": 138,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.toSMul",
            "Algebra.toModule",
            "Algebra.id",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "LinearMap.module",
            "LinearMap",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "IsScalarTower.left",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "LinearMap.instIsScalarTower",
            "IsScalarTower.to_smulCommClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Module.toDistribMulAction",
            "Algebra.TensorProduct.instRing",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieAlgebra.ExtendScalars.instBracketTensorProduct",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "TensorProduct.AlgebraTensorModule.curry",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "TensorProduct.isScalarTower",
            "MonoidWithZero.toMonoid",
            "TensorProduct.instModule.proof_1",
            "TensorProduct.instModule",
            "TensorProduct.smulCommClass_left",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "dsimp [Ring.lie_def]",
          "proofState": 338,
          "pos": {
            "line": 139,
            "column": 2
          },
          "goals": "case bracket.h.h.a.h.h.a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\nxa : A\nxb : B\nya : A\nyb : B\n\u22a2 \u2045xa \u2297\u209c[R] xb, ya \u2297\u209c[R] yb\u2046 =\n    ((TensorProduct.AlgebraTensorModule.curry\n          (((TensorProduct.AlgebraTensorModule.curry (bracketBilin R (A \u2297[R] B) (A \u2297[R] B))) xa) xb))\n        ya)\n      yb",
          "endPos": {
            "line": 139,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.tmul_sub",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Eq",
            "LieAlgebra.ofAssociativeAlgebra",
            "instHMul"
          ],
          "tactic": "rw [TensorProduct.tmul_sub, mul_comm]",
          "proofState": 339,
          "pos": {
            "line": 140,
            "column": 2
          },
          "goals": "case bracket.h.h.a.h.h.a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\nxa : A\nxb : B\nya : A\nyb : B\n\u22a2 (xa * ya) \u2297\u209c[R] (xb * yb - yb * xb) = (xa * ya) \u2297\u209c[R] (xb * yb) - (ya * xa) \u2297\u209c[R] (yb * xb)",
          "endPos": {
            "line": 140,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.id",
            "id",
            "LinearMap.toAddHom",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "AddZeroClass.toZero",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "LieAlgebra.ofAssociativeAlgebra",
            "AddHom.toFun",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]",
          "proofState": 340,
          "pos": {
            "line": 189,
            "column": 8
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\n\u22a2 \u2200 {x : A \u2297[R] L} {m : A \u2297[R] M}, __spread\u271d\u207b\u2070.toFun \u2045x, m\u2046 = \u2045x, __spread\u271d\u207b\u2070.toFun m\u2046",
          "endPos": {
            "line": 189,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "intro x m",
          "proofState": 341,
          "pos": {
            "line": 190,
            "column": 8
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\n\u22a2 \u2200 {x : A \u2297[R] L} {m : A \u2297[R] M}, (LinearMap.baseChange A \u2191f) \u2045x, m\u2046 = \u2045x, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 190,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction x using TensorProduct.induction_on",
          "proofState": 342,
          "pos": {
            "line": 191,
            "column": 8
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx : A \u2297[R] L\nm : A \u2297[R] M\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x, m\u2046 = \u2045x, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 191,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "RingHom",
            "map_zero",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "zero_lie",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddMonoidHomClass.toZeroHomClass",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [zero_lie, map_zero]",
          "proofState": 343,
          "pos": {
            "line": 192,
            "column": 10
          },
          "goals": "case zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nm : A \u2297[R] M\n\u22a2 (LinearMap.baseChange A \u2191f) \u20450, m\u2046 = \u20450, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 192,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction m using TensorProduct.induction_on",
          "proofState": 344,
          "pos": {
            "line": 193,
            "column": 10
          },
          "goals": "case tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nm : A \u2297[R] M\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, m\u2046 = \u2045x\u271d \u2297\u209c[R] y\u271d, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 193,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "RingHom",
            "map_zero",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "lie_zero",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "AddMonoidHomClass.toZeroHomClass",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 345,
          "pos": {
            "line": 193,
            "column": 59
          },
          "goals": "case tmul.zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, 0\u2046 = \u2045x\u271d \u2297\u209c[R] y\u271d, (LinearMap.baseChange A \u2191f) 0\u2046",
          "endPos": {
            "line": 193,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LieModuleHom",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "Algebra.toModule",
            "LieRingModule.toBracket",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "TensorProduct.tmul",
            "LieModuleHom.map_lie",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieModuleHom.instFunLike",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp_all",
          "proofState": 346,
          "pos": {
            "line": 193,
            "column": 59
          },
          "goals": "case tmul.tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d : A\ny\u271d : M\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d \u2297\u209c[R] y\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d)\u2046",
          "endPos": {
            "line": 193,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "map_add",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "TensorProduct.tmul",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "lie_add",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 347,
          "pos": {
            "line": 193,
            "column": 59
          },
          "goals": "case tmul.add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d y\u271d : A \u2297[R] M\na\u271d\u00b9 : (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) x\u271d\u2046\na\u271d : (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, y\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) y\u271d\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d + y\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) (x\u271d + y\u271d)\u2046",
          "endPos": {
            "line": 193,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "map_add",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero",
            "add_lie"
          ],
          "tactic": "simp_all only [add_lie, map_add]",
          "proofState": 348,
          "pos": {
            "line": 194,
            "column": 10
          },
          "goals": "case add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nm : A \u2297[R] M\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : (LinearMap.baseChange A \u2191f) \u2045x\u271d, m\u2046 = \u2045x\u271d, (LinearMap.baseChange A \u2191f) m\u2046\na\u271d : (LinearMap.baseChange A \u2191f) \u2045y\u271d, m\u2046 = \u2045y\u271d, (LinearMap.baseChange A \u2191f) m\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d + y\u271d, m\u2046 = \u2045x\u271d + y\u271d, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 194,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "Algebra.toSMul",
            "Algebra.id",
            "id",
            "LinearMap.toAddHom",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "AddCommSemigroup.toAddCommMagma",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "AddHom.toFun",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]",
          "proofState": 349,
          "pos": {
            "line": 204,
            "column": 4
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\n\u22a2 \u2200 {x y : A \u2297[R] L}, __spread\u271d\u207b\u2070.toFun \u2045x, y\u2046 = \u2045__spread\u271d\u207b\u2070.toFun x, __spread\u271d\u207b\u2070.toFun y\u2046",
          "endPos": {
            "line": 204,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "intro x m",
          "proofState": 350,
          "pos": {
            "line": 205,
            "column": 4
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\n\u22a2 \u2200 {x y : A \u2297[R] L},\n    (LinearMap.baseChange A \u2191f) \u2045x, y\u2046 = \u2045(LinearMap.baseChange A \u2191f) x, (LinearMap.baseChange A \u2191f) y\u2046",
          "endPos": {
            "line": 205,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction x using TensorProduct.induction_on",
          "proofState": 351,
          "pos": {
            "line": 206,
            "column": 4
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx m : A \u2297[R] L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) x, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 206,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "RingHom",
            "Algebra.toSMul",
            "map_zero",
            "Algebra.id",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "congr",
            "True",
            "eq_self",
            "zero_lie",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "AddCommMonoid.toAddMonoid",
            "AddMonoidHomClass.toZeroHomClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "LieHom.toLinearMap",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [zero_lie, map_zero]",
          "proofState": 352,
          "pos": {
            "line": 207,
            "column": 6
          },
          "goals": "case zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nm : A \u2297[R] L\n\u22a2 (LinearMap.baseChange A \u2191f) \u20450, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) 0, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 207,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction m using TensorProduct.induction_on",
          "proofState": 353,
          "pos": {
            "line": 208,
            "column": 6
          },
          "goals": "case tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nm : A \u2297[R] L\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, m\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d), (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 208,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "RingHom",
            "Algebra.toSMul",
            "map_zero",
            "Algebra.toModule",
            "Algebra.id",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "True",
            "eq_self",
            "lie_zero",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "LieHom.instFunLike",
            "AddMonoidHomClass.toZeroHomClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "LieHom.toLinearMap",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 354,
          "pos": {
            "line": 208,
            "column": 55
          },
          "goals": "case tmul.zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, 0\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d), (LinearMap.baseChange A \u2191f) 0\u2046",
          "endPos": {
            "line": 208,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "LieHom.map_lie",
            "Algebra.toModule",
            "LieRingModule.toBracket",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "TensorProduct.tmul",
            "LieHom.instFunLike",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp_all",
          "proofState": 355,
          "pos": {
            "line": 208,
            "column": 55
          },
          "goals": "case tmul.tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d \u2297\u209c[R] y\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d)\u2046",
          "endPos": {
            "line": 208,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "Algebra.toSMul",
            "Algebra.toModule",
            "Algebra.id",
            "map_add",
            "id",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "AddCommSemigroup.toAddCommMagma",
            "TensorProduct.tmul",
            "LieHom.instFunLike",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieHom.toLinearMap",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "lie_add",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp_all",
          "proofState": 356,
          "pos": {
            "line": 208,
            "column": 55
          },
          "goals": "case tmul.add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 :\n  (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) x\u271d\u2046\na\u271d :\n  (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, y\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) y\u271d\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d + y\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) (x\u271d + y\u271d)\u2046",
          "endPos": {
            "line": 208,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "Algebra.toSMul",
            "Algebra.id",
            "map_add",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "congr",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "AddCommSemigroup.toAddCommMagma",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieHom.toLinearMap",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "add_lie"
          ],
          "tactic": "simp_all only [add_lie, map_add]",
          "proofState": 357,
          "pos": {
            "line": 209,
            "column": 6
          },
          "goals": "case add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nm x\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : (LinearMap.baseChange A \u2191f) \u2045x\u271d, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) x\u271d, (LinearMap.baseChange A \u2191f) m\u2046\na\u271d : (LinearMap.baseChange A \u2191f) \u2045y\u271d, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) y\u271d, (LinearMap.baseChange A \u2191f) m\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d + y\u271d, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) (x\u271d + y\u271d), (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 209,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "instInnerProductSpaceRealComplex",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "IsScalarTower.right",
            "LeftInvariantDerivation.instLieAlgebra",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AlgHom",
            "NormedSpace.toModule",
            "instNormedSpaceLieAddGroup",
            "AddMonoid.toAddZeroClass",
            "Complex.instNormedField",
            "PseudoMetricSpace.toUniformSpace",
            "Module.toMulActionWithZero",
            "Algebra.toSMul",
            "NormedRing.toNonUnitalNormedRing",
            "Real.semiring",
            "Algebra.toModule",
            "Algebra.id",
            "UniversalEnvelopingAlgebra.instAlgebra",
            "DivInvMonoid.toMonoid",
            "UniversalEnvelopingAlgebra",
            "Real.normedAddCommGroup",
            "Module.End.semiring",
            "Complex.instRCLike",
            "Real.instMonoidWithZero",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "Real.commRing",
            "ContMDiffMap.algebra",
            "Real.instAddCommGroup",
            "LinearMap.module",
            "LeftInvariantDerivation.instAddCommGroup",
            "WithTop.some",
            "Algebra.TensorProduct.leftAlgebra",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonUnitalNormedRing.toNormedAddCommGroup",
            "Real.instMonoid",
            "LeftInvariantDerivation.instModule",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "Real.normedCommRing",
            "ContMDiffMap.semiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "CommMonoid.toMonoid",
            "SeminormedAddCommGroup.toAddCommGroup",
            "NormedAlgebra.toNormedSpace",
            "DedekindDomain.instLieAlgebra'",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "ContMDiffMap.addCommMonoid",
            "ENat",
            "instLieGroupOfTopWithTopENat",
            "AddZeroClass.toZero",
            "Algebra.TensorProduct.instSemiring",
            "NormedRing.toSeminormedRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "IsScalarTower.complexToReal",
            "Real.instAddCommMonoid",
            "Monoid.toMulAction",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "NormedAddCommGroup.toAddCommGroup",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "Module.End.ring",
            "SeminormedRing.toPseudoMetricSpace",
            "AutomorphicForm.GLn.actionTensorC",
            "NormedField.toNormedCommRing",
            "Module.End",
            "Complex",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Top.top",
            "instFieldContMDiffRing",
            "ContMDiffMap.module",
            "RCLike.innerProductSpace",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "LieAlgebra.ofAssociativeAlgebra",
            "letFun",
            "LeftInvariantDerivation.instLieRing",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "LieGroup.toContMDiffMul",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Real.instCommMonoid",
            "Semiring.toMonoidWithZero",
            "ContMDiffMap.addCommGroup"
          ],
          "tactic": "have := actionTensorC G E",
          "proofState": 358,
          "pos": {
            "line": 218,
            "column": 2
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n    \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef",
          "endPos": {
            "line": 218,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "revert this",
          "proofState": 359,
          "pos": {
            "line": 218,
            "column": 29
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nthis : \u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef\n\u22a2 UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n    \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef",
          "endPos": {
            "line": 218,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "instInnerProductSpaceRealComplex",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "IsScalarTower.right",
            "UniversalEnvelopingAlgebra.lift",
            "LeftInvariantDerivation.instLieAlgebra",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AlgHom",
            "NormedSpace.toModule",
            "instNormedSpaceLieAddGroup",
            "AddMonoid.toAddZeroClass",
            "Complex.instNormedField",
            "PseudoMetricSpace.toUniformSpace",
            "Module.toMulActionWithZero",
            "SeminormedRing.toRing",
            "Algebra.toSMul",
            "NormedRing.toNonUnitalNormedRing",
            "Real.semiring",
            "Algebra.toModule",
            "Algebra.id",
            "Equiv",
            "UniversalEnvelopingAlgebra.instAlgebra",
            "DivInvMonoid.toMonoid",
            "UniversalEnvelopingAlgebra",
            "Real.normedAddCommGroup",
            "Module.End.semiring",
            "Complex.instRCLike",
            "Real.instMonoidWithZero",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "Real.commRing",
            "ContMDiffMap.algebra",
            "Real.instAddCommGroup",
            "LinearMap.module",
            "LeftInvariantDerivation.instAddCommGroup",
            "WithTop.some",
            "Algebra.TensorProduct.leftAlgebra",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonUnitalNormedRing.toNormedAddCommGroup",
            "Real.instMonoid",
            "LeftInvariantDerivation.instModule",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "Real.normedCommRing",
            "ContMDiffMap.semiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "CommMonoid.toMonoid",
            "SeminormedAddCommGroup.toAddCommGroup",
            "NormedAlgebra.toNormedSpace",
            "DedekindDomain.instLieAlgebra'",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "ContMDiffMap.addCommMonoid",
            "ENat",
            "instLieGroupOfTopWithTopENat",
            "AddZeroClass.toZero",
            "Algebra.TensorProduct.instSemiring",
            "NormedRing.toSeminormedRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "IsScalarTower.complexToReal",
            "Real.instAddCommMonoid",
            "Monoid.toMulAction",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "NormedAddCommGroup.toAddCommGroup",
            "NontriviallyNormedField.toNormedField",
            "Algebra.TensorProduct.instRing",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "Module.End.ring",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Module.End",
            "Complex",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Top.top",
            "instFieldContMDiffRing",
            "ContMDiffMap.module",
            "RCLike.innerProductSpace",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "LeftInvariantDerivation.instLieRing",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "LieGroup.toContMDiffMul",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Real.instCommMonoid",
            "Semiring.toMonoidWithZero",
            "ContMDiffMap.addCommGroup"
          ],
          "tactic": "convert\n  \u21d1(UniversalEnvelopingAlgebra.lift \u2102 (L := \u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) (A :=\n      \u2102 \u2297[\u211d] (Module.End \u211d C^\u221e\u27ee\ud835\udcd8(\u211d, E), G; \u211d\u27ef))) using\n  0",
          "proofState": 360,
          "pos": {
            "line": 219,
            "column": 2
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) \u2192\n    UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n      \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef",
          "endPos": {
            "line": 221,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "_private.Mathlib.Tactic.CongrExclamation.0.implies_congr'"
          ],
          "tactic": "congr!",
          "proofState": 361,
          "pos": {
            "line": 222,
            "column": 2
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 ((\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) \u2192\n      UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n        \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) =\n    ((\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) \u2192\n      UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n        \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef)",
          "endPos": {
            "line": 222,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "id",
            "LieRing",
            "Eq"
          ],
          "tactic": "dsimp [LieAlgebra.ExtendScalars.instLieRing, LieRing.ofAssociativeRing]",
          "proofState": 362,
          "pos": {
            "line": 223,
            "column": 4
          },
          "goals": "case h.h.e'_7\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 LieAlgebra.ExtendScalars.instLieRing \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) = LieRing.ofAssociativeRing",
          "endPos": {
            "line": 223,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "AddMonoid.toAddSemigroup",
            "AddMonoid.toZero",
            "Bracket.bracket",
            "AddCommGroup.toAddGroup",
            "Eq.rec",
            "AddCommGroup",
            "Bracket",
            "instHAdd",
            "LieRing",
            "AddSemigroup.toAdd",
            "LieRing.mk",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Eq.ndrec",
            "Zero.toOfNat0",
            "Eq.refl",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "congr",
          "proofState": 363,
          "pos": {
            "line": 223,
            "column": 77
          },
          "goals": "case h.h.e'_7\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 LieRing.mk \u22ef \u22ef \u22ef \u22ef = LieRing.mk \u22ef \u22ef \u22ef \u22ef",
          "endPos": {
            "line": 223,
            "column": 82
          }
        },
        {
          "usedConstants": [
            "DedekindDomain.diamond_fix"
          ],
          "tactic": "apply diamond_fix",
          "proofState": 364,
          "pos": {
            "line": 224,
            "column": 4
          },
          "goals": "case h.h.e'_7.e_toBracket\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 LieAlgebra.ExtendScalars.instBracketTensorProduct \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef)\n      (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) =\n    Ring.instBracket",
          "endPos": {
            "line": 224,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "id",
            "HEq",
            "LieAlgebra"
          ],
          "tactic": "change HEq ({ .. } : LieAlgebra ..) (@LieAlgebra.mk _ _ _ (_) _ _)",
          "proofState": 365,
          "pos": {
            "line": 225,
            "column": 4
          },
          "goals": "case h.h.e'_8\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\ne_7\u271d : LieAlgebra.ExtendScalars.instLieRing \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) = LieRing.ofAssociativeRing\n\u22a2 HEq (instLieAlgebra' \u2102 \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef)) LieAlgebra.ofAssociativeAlgebra",
          "endPos": {
            "line": 225,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "CommRing",
            "instHSMul",
            "LieAlgebra.mk",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "HEq.refl",
            "Bracket.bracket",
            "Eq.casesOn",
            "MulAction.toSMul",
            "LieRing",
            "CommRing.toCommSemiring",
            "HEq.casesOn",
            "eq_of_heq",
            "Eq.ndrec",
            "Eq.refl",
            "HEq",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "LieAlgebra",
            "Module",
            "Eq.symm",
            "Eq",
            "MonoidWithZero.toMonoid",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "congr!",
          "proofState": 366,
          "pos": {
            "line": 225,
            "column": 70
          },
          "goals": "case h.h.e'_8\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\ne_7\u271d : LieAlgebra.ExtendScalars.instLieRing \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) = LieRing.ofAssociativeRing\n\u22a2 HEq (LieAlgebra.mk \u22ef) (LieAlgebra.mk \u22ef)",
          "endPos": {
            "line": 225,
            "column": 76
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Pi.Function.module",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "instHSMul",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Complex.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "Module.toMulActionWithZero",
            "RingHom",
            "Membership.mem",
            "Field.toDivisionRing",
            "AutomorphicForm.GLn.preweight.d",
            "id",
            "Subtype",
            "AutomorphicForm.GLn.preweight.rho",
            "Submonoid.toMulOneClass",
            "DivisionRing.toRing",
            "Complex.instRCLike",
            "Real.commRing",
            "Complex.addCommGroup",
            "Fin.fintype",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "Matrix.mulVec_add",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "AddZeroClass.toZero",
            "Pi.addCommGroup",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "Submonoid.instSetLike",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "AddHom.mk",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Complex.instRing",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RCLike.innerProductSpace",
            "Fin",
            "Matrix.orthogonalGroup",
            "RingHom.id",
            "Matrix.mulVec",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "SetLike.instMembership",
            "Submonoid",
            "MonoidWithZero.toMonoid",
            "Complex.instField",
            "MulZeroClass.toZero",
            "Units.instMulOneClass",
            "AddCommMagma.toAdd",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simpa using Matrix.mulVec_smul ..",
          "proofState": 367,
          "pos": {
            "line": 291,
            "column": 32
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\nA : \u21a5(orthogonalGroup (Fin n) \u211d)\nx\u271d\u00b9 : \u2102\nx\u271d : Fin w.d \u2192 \u2102\n\u22a2 { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef }.toFun (x\u271d\u00b9 \u2022 x\u271d) =\n    (RingHom.id \u2102) x\u271d\u00b9 \u2022 { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef }.toFun x\u271d",
          "endPos": {
            "line": 291,
            "column": 65
          }
        },
        {
          "usedConstants": [],
          "tactic": "aesop",
          "proofState": 368,
          "pos": {
            "line": 292,
            "column": 19
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\n\u22a2 (fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef }) 1 = 1",
          "endPos": {
            "line": 292,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "Pi.Function.module",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "MonoidHom.instMonoidHomClass",
            "Real",
            "instHSMul",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "IsScalarTower.right",
            "Complex.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "AddHom",
            "Matrix",
            "OneHom.mk",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "instLargeCategoryFGModuleCat",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "Module.toMulActionWithZero",
            "NormedDivisionRing.toDivisionRing",
            "RingHom",
            "Membership.mem",
            "MonoidHomClass.toOneHomClass",
            "NormedField.toField",
            "Field.toDivisionRing",
            "CategoryTheory.CategoryStruct.id",
            "Units",
            "Eq.rec",
            "Algebra.id",
            "AutomorphicForm.GLn.preweight.d",
            "id",
            "Subtype",
            "DistribSMul.toSMulZeroClass",
            "Submonoid.toMonoid",
            "AutomorphicForm.GLn.preweight.rho",
            "Submonoid.toMulOneClass",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "FGModuleCat.of",
            "Complex.instRCLike",
            "CategoryTheory.End.monoid",
            "Module.instIsReflexiveOfFiniteOfProjective",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap",
            "FiniteDimensional.finiteDimensional_self",
            "CategoryTheory.End",
            "Complex.addCommGroup",
            "AddCommMonoid",
            "Fin.fintype",
            "FiniteDimensional.finiteDimensional_pi'",
            "Matrix.mulVec_smul",
            "Units.instOne",
            "NonUnitalCommSemiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "map_mul",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Module.Projective.of_free",
            "MonoidWithZero.toMulZeroOneClass",
            "Matrix.mulVec_add",
            "OneHom.toFun",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "NonUnitalCommRing.toNonUnitalCommSemiring",
            "SeminormedAddCommGroup.toAddCommGroup",
            "map_one",
            "Complex.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "AddZeroClass.toZero",
            "Module.instFiniteDimensionalOfIsReflexive",
            "Pi.addCommGroup",
            "MulOneClass.toOne",
            "LinearMap.mk",
            "MonoidHomClass.toMulHomClass",
            "Module.Free.self",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Eq.ndrec",
            "Semiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Eq.refl",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "CategoryTheory.Category.toCategoryStruct",
            "Units.instMul",
            "AddCommMonoid.toAddMonoid",
            "FGModuleCat",
            "AddCommSemigroup.toAddCommMagma",
            "Submonoid.instSetLike",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "AddHom.mk",
            "ModuleCat.ofHom",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "EuclideanDomain.toCommRing",
            "Complex",
            "Module",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Complex.instRing",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RCLike.innerProductSpace",
            "Fin",
            "Matrix.orthogonalGroup",
            "_auxLemma.2",
            "RingHom.id",
            "Matrix.mulVec",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "SetLike.instMembership",
            "Matrix.one_mulVec",
            "Field.toEuclideanDomain",
            "Submonoid",
            "Add",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instField",
            "MulZeroClass.toZero",
            "Units.instMulOneClass",
            "AddCommMagma.toAdd",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp only [obj_carrier, MonCat.mul_of, _root_.map_mul, Units.val_mul, \u2190 Matrix.mulVec_mulVec]",
          "proofState": 369,
          "pos": {
            "line": 294,
            "column": 6
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\nx\u271d\u00b9 x\u271d : \u21a5(orthogonalGroup (Fin n) \u211d)\n\u22a2 { toFun := fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef },\n          map_one' := \u22ef }.toFun\n      (x\u271d\u00b9 * x\u271d) =\n    { toFun := fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef },\n            map_one' := \u22ef }.toFun\n        x\u271d\u00b9 *\n      { toFun := fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef },\n            map_one' := \u22ef }.toFun\n        x\u271d",
          "endPos": {
            "line": 294,
            "column": 99
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Pi.Function.module",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "MonoidHom.instMonoidHomClass",
            "Real",
            "instHSMul",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "IsScalarTower.right",
            "Complex.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "AddHom",
            "Matrix",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "instLargeCategoryFGModuleCat",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "Module.toMulActionWithZero",
            "NormedDivisionRing.toDivisionRing",
            "RingHom",
            "Membership.mem",
            "NormedField.toField",
            "Field.toDivisionRing",
            "Units",
            "Eq.rec",
            "Algebra.id",
            "AutomorphicForm.GLn.preweight.d",
            "id",
            "Subtype",
            "DistribSMul.toSMulZeroClass",
            "Submonoid.toMonoid",
            "AutomorphicForm.GLn.preweight.rho",
            "Submonoid.toMulOneClass",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "FGModuleCat.of",
            "Complex.instRCLike",
            "Module.instIsReflexiveOfFiniteOfProjective",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "FiniteDimensional.finiteDimensional_self",
            "CategoryTheory.End",
            "Complex.addCommGroup",
            "Fin.fintype",
            "FiniteDimensional.finiteDimensional_pi'",
            "Matrix.mulVec_smul",
            "NonUnitalCommSemiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "map_mul",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Module.Projective.of_free",
            "MonoidWithZero.toMulZeroOneClass",
            "Matrix.mulVec_add",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "NonUnitalCommRing.toNonUnitalCommSemiring",
            "SeminormedAddCommGroup.toAddCommGroup",
            "Complex.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "AddZeroClass.toZero",
            "Module.instFiniteDimensionalOfIsReflexive",
            "Pi.addCommGroup",
            "LinearMap.mk",
            "MonoidHomClass.toMulHomClass",
            "Module.Free.self",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Eq.ndrec",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Eq.refl",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "CategoryTheory.Category.toCategoryStruct",
            "Units.instMul",
            "AddCommMonoid.toAddMonoid",
            "FGModuleCat",
            "AddCommSemigroup.toAddCommMagma",
            "Submonoid.instSetLike",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "AddHom.mk",
            "ModuleCat.ofHom",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "EuclideanDomain.toCommRing",
            "Complex",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Complex.instRing",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RCLike.innerProductSpace",
            "Fin",
            "Matrix.orthogonalGroup",
            "_auxLemma.2",
            "RingHom.id",
            "Matrix.mulVec",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "SetLike.instMembership",
            "Field.toEuclideanDomain",
            "Submonoid",
            "Add",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instField",
            "MulZeroClass.toZero",
            "Units.instMulOneClass",
            "AddCommMagma.toAdd",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rfl",
          "proofState": 370,
          "pos": {
            "line": 295,
            "column": 6
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\nx\u271d\u00b9 x\u271d : \u21a5(orthogonalGroup (Fin n) \u211d)\n\u22a2 ModuleCat.ofHom { toFun := fun x => \u2191(w.rho x\u271d\u00b9) *\u1d65 \u2191(w.rho x\u271d) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef } =\n    ModuleCat.ofHom { toFun := fun x => \u2191(w.rho x\u271d\u00b9) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef } *\n      ModuleCat.ofHom { toFun := fun x => \u2191(w.rho x\u271d) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef }",
          "endPos": {
            "line": 295,
            "column": 9
          }
        }
      ],
      "sorries": [
        {
          "proofState": 315,
          "pos": {
            "line": 91,
            "column": 53
          },
          "goal": "R : Type u_1\nK : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nv : HeightOneSpectrum R\n\u22a2 TopologicalSpace (FiniteAdeleRing \u2124 \u211a)",
          "endPos": {
            "line": 91,
            "column": 58
          }
        },
        {
          "proofState": 316,
          "pos": {
            "line": 94,
            "column": 87
          },
          "goal": "R : Type u_1\nK : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nv : HeightOneSpectrum R\n\u22a2 TopologicalRing (FiniteAdeleRing \u2124 \u211a)",
          "endPos": {
            "line": 94,
            "column": 92
          }
        },
        {
          "proofState": 317,
          "pos": {
            "line": 238,
            "column": 51
          },
          "goal": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 Module \u2102 C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u2102), \u2102\u27ef",
          "endPos": {
            "line": 238,
            "column": 56
          }
        },
        {
          "proofState": 318,
          "pos": {
            "line": 248,
            "column": 81
          },
          "goal": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 \u21a5(Z G E) \u2192\u2090[\u2102] Module.End \u2102 C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u2102), \u2102\u27ef",
          "endPos": {
            "line": 248,
            "column": 86
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 91,
            "column": 0
          },
          "endPos": {
            "line": 91,
            "column": 58
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 94,
            "column": 9
          },
          "endPos": {
            "line": 94,
            "column": 43
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 238,
            "column": 0
          },
          "endPos": {
            "line": 238,
            "column": 56
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 248,
            "column": 4
          },
          "endPos": {
            "line": 248,
            "column": 22
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 18
    }
  },
  {
    "file": "FLT/GlobalLanglandsConjectures/GLzero.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "continuous_const",
            "Complex.instNormedField",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "PseudoMetricSpace.toUniformSpace",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "SeminormedCommRing.toSeminormedRing",
            "Int.instAddGroup",
            "Real.pseudoMetricSpace",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "UniformSpace.toTopologicalSpace",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "continuity",
          "proofState": 381,
          "pos": {
            "line": 61,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 Continuous fun x => c",
          "endPos": {
            "line": 61,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "Eq.mpr",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "Set.preimage",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "IsOpen",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "OfNat.ofNat",
            "Fin",
            "IsLocallyConstant.eq_1",
            "Eq",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "rw [IsLocallyConstant]",
          "proofState": 382,
          "pos": {
            "line": 63,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 GL (Fin 0) \u211d \u2192 IsLocallyConstant fun x => c",
          "endPos": {
            "line": 63,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Units.instDiscreteTopology",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Mathlib.Topology.Order._auxLemma.6",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "Set.preimage",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "of_eq_true",
            "Int.instAddGroup",
            "Subsingleton.discreteTopology",
            "IsOpen",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "aesop",
          "proofState": 383,
          "pos": {
            "line": 64,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 GL (Fin 0) \u211d \u2192 \u2200 (s : Set \u2102), IsOpen ((fun x => c) \u207b\u00b9' s)",
          "endPos": {
            "line": 64,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "Units.instTopologicalSpaceUnits",
            "instENatTop",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "ContMDiff",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "PseudoMetricSpace.toUniformSpace",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "DivisionRing.toDivisionSemiring",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "Finite.of_fintype",
            "Real.commRing",
            "Matrix.linftyOpNormedSpace",
            "WithTop.some",
            "Fin.fintype",
            "Rat.isFractionRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "Real.normedCommRing",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "Ring.toIntAlgebra",
            "Module.Free.self",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "Semiring.toNonUnitalSemiring",
            "Units.instChartedSpace",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "Top.top",
            "OfNat.ofNat",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "UniformSpace.toTopologicalSpace",
            "Ring.toSemiring",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [contMDiff_const]",
          "proofState": 384,
          "pos": {
            "line": 65,
            "column": 19
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a) \u2192\n    ContMDiff (modelWithCornersSelf \u211d (Matrix (Fin 0) (Fin 0) \u211d)) (modelWithCornersSelf \u211d \u2102) \u2191\u22a4 fun y => c",
          "endPos": {
            "line": 65,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Int.euclideanDomain",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Rat.commRing",
            "Eq.trans",
            "forall_congr"
          ],
          "tactic": "simp",
          "proofState": 385,
          "pos": {
            "line": 67,
            "column": 22
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 (g : GL (Fin 0) \u211a) (x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) (y : GL (Fin 0) \u211d),\n    (fun x => c)\n        (((algebraMap \u211a (DedekindDomain.FiniteAdeleRing \u2124 \u211a)).GL (Fin 0)) g * x, ((algebraMap \u211a \u211d).GL (Fin 0)) g * y) =\n      (fun x => c) (x, y)",
          "endPos": {
            "line": 67,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Int.euclideanDomain",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Fin"
          ],
          "tactic": "intros x",
          "proofState": 386,
          "pos": {
            "line": 69,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 (x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)), IsSlowlyIncreasing fun y => (fun x => c) (x, y)",
          "endPos": {
            "line": 69,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "Norm.norm",
            "Units.val",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.instLE",
            "Real",
            "NormedRing.toRing",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.IsSlowlyIncreasing.mk",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Exists",
            "Monoid.toNatPow",
            "Complex.instNorm",
            "Real.semiring",
            "id",
            "AutomorphicForm.GLn.s",
            "Prod.mk",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "Int",
            "LE.le",
            "Real.commRing",
            "Mathlib.Order.Defs.PartialOrder._auxLemma.1",
            "pow_zero",
            "Fin.fintype",
            "MulZeroOneClass.toMulOneClass",
            "Rat.isFractionRing",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "HPow.hPow",
            "Int.instCommRing",
            "Complex.abs",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "Real.instMul",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "AbsoluteValue.funLike",
            "Exists.intro",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "mul_one",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "Real.instPreorder",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "AbsoluteValue"
          ],
          "tactic": "exact\n  {\n    bounded_by := by\n      simp\n      apply Exists.intro (Complex.abs c)\n      apply Exists.intro 0\n      simp }",
          "proofState": 387,
          "pos": {
            "line": 70,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 IsSlowlyIncreasing fun y => (fun x => c) (x, y)",
          "endPos": {
            "line": 76,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "Norm.norm",
            "Units.val",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.instLE",
            "Real",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Exists",
            "Monoid.toNatPow",
            "Complex.instNorm",
            "id",
            "AutomorphicForm.GLn.s",
            "Prod.mk",
            "instOfNatNat",
            "Int",
            "LE.le",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "HPow.hPow",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "Real.instMul",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 388,
          "pos": {
            "line": 72,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2203 C N, \u2200 (M : GL (Fin 0) \u211d), \u2016(fun x => c) (x, M)\u2016 \u2264 C * s \u2191M ^ N",
          "endPos": {
            "line": 72,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "Real.instLE",
            "Real",
            "HMul.hMul",
            "Real.orderedSemiring",
            "CommSemiring.toSemiring",
            "Matrix",
            "instDecidableEqFin",
            "Exists",
            "Monoid.toNatPow",
            "AutomorphicForm.GLn.s",
            "instOfNatNat",
            "LE.le",
            "Real.commRing",
            "Fin.fintype",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Complex.abs",
            "Nat",
            "Real.instMul",
            "AbsoluteValue.funLike",
            "Exists.intro",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "AbsoluteValue"
          ],
          "tactic": "apply Exists.intro (Complex.abs c)",
          "proofState": 389,
          "pos": {
            "line": 73,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2203 C N, \u2200 (M : GL (Fin 0) \u211d), Complex.abs c \u2264 C * s \u2191M ^ N",
          "endPos": {
            "line": 73,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "Real.instLE",
            "Real",
            "HMul.hMul",
            "Real.orderedSemiring",
            "CommSemiring.toSemiring",
            "Matrix",
            "instDecidableEqFin",
            "Monoid.toNatPow",
            "AutomorphicForm.GLn.s",
            "instOfNatNat",
            "LE.le",
            "Real.commRing",
            "Fin.fintype",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Complex.abs",
            "Nat",
            "Real.instMul",
            "AbsoluteValue.funLike",
            "Exists.intro",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "AbsoluteValue"
          ],
          "tactic": "apply Exists.intro 0",
          "proofState": 390,
          "pos": {
            "line": 74,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2203 N, \u2200 (M : GL (Fin 0) \u211d), Complex.abs c \u2264 Complex.abs c * s \u2191M ^ N",
          "endPos": {
            "line": 74,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "Real.instLE",
            "Real",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "Matrix",
            "instDecidableEqFin",
            "Monoid.toNatPow",
            "Real.semiring",
            "AutomorphicForm.GLn.s",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "LE.le",
            "Real.commRing",
            "Mathlib.Order.Defs.PartialOrder._auxLemma.1",
            "pow_zero",
            "Fin.fintype",
            "MulZeroOneClass.toMulOneClass",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Complex.abs",
            "Nat",
            "Real.instMul",
            "True",
            "MulOneClass.toOne",
            "AbsoluteValue.funLike",
            "of_eq_true",
            "One.toOfNat1",
            "implies_true",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "mul_one",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "Real.instPreorder",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "AbsoluteValue"
          ],
          "tactic": "simp",
          "proofState": 391,
          "pos": {
            "line": 75,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2200 (M : GL (Fin 0) \u211d), Complex.abs c \u2264 Complex.abs c * s \u2191M ^ 0",
          "endPos": {
            "line": 75,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "InvOneClass.toOne",
            "NormedRing.toRing",
            "HMul.hMul",
            "Mathlib.Algebra.Group.Basic._auxLemma.19",
            "DivInvOneMonoid.toInvOneClass",
            "and_true",
            "Init.Core._auxLemma.4",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "CancelMonoid.toLeftCancelMonoid",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "Group.toDivisionMonoid",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionMonoid.toDivInvOneMonoid",
            "Units",
            "Subgroup.mk",
            "Set.instSingletonSet",
            "LeftCancelMonoid.toMonoid",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "Mathlib.Algebra.Group.Units.Basic._auxLemma.12",
            "Unique.instSubsingleton",
            "And",
            "instUniqueUnitsOfSubsingleton",
            "CommRing.toCommSemiring",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "Eq.refl",
            "InvOneClass.toInv",
            "Submonoid.mk",
            "Init.PropLemmas._auxLemma.50",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "Group.toCancelMonoid",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "Set"
          ],
          "tactic": "let U : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := { 1 }, one_mem' := by simp, mul_mem' := by simp\n    inv_mem' := by simp }",
          "proofState": 392,
          "pos": {
            "line": 86,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2203 U, IsConstantOn U fun x => c",
          "endPos": {
            "line": 91,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "HMul.hMul",
            "and_true",
            "Init.Core._auxLemma.4",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "CancelMonoid.toLeftCancelMonoid",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "Units",
            "Set.instSingletonSet",
            "LeftCancelMonoid.toMonoid",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "Mathlib.Algebra.Group.Units.Basic._auxLemma.12",
            "Unique.instSubsingleton",
            "And",
            "instUniqueUnitsOfSubsingleton",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "Eq.refl",
            "Init.PropLemmas._auxLemma.50",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "Group.toCancelMonoid",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 393,
          "pos": {
            "line": 89,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 {a b : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)}, a \u2208 {1} \u2192 b \u2208 {1} \u2192 a * b \u2208 {1}",
          "endPos": {
            "line": 89,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Monoid.toMulOneClass",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "Set.instSingletonSet",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 394,
          "pos": {
            "line": 88,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 1 \u2208 { carrier := {1}, mul_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 88,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "InvOneClass.toOne",
            "NormedRing.toRing",
            "Mathlib.Algebra.Group.Basic._auxLemma.19",
            "DivInvOneMonoid.toInvOneClass",
            "Init.Core._auxLemma.4",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "Group.toDivisionMonoid",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionMonoid.toDivInvOneMonoid",
            "Set.instSingletonSet",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "InvOneClass.toInv",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "forall_congr",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 395,
          "pos": {
            "line": 90,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 {x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)},\n    x \u2208 { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef }.carrier \u2192\n      x\u207b\u00b9 \u2208 { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 90,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Subgroup",
            "instOfNatNat",
            "Int",
            "AutomorphicForm.GLn.IsConstantOn",
            "Units.instGroup",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Exists.intro",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "apply Exists.intro U",
          "proofState": 396,
          "pos": {
            "line": 92,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 \u2203 U, IsConstantOn U fun x => c",
          "endPos": {
            "line": 92,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Mathlib.Topology.Compactness.Compact._auxLemma.24",
            "Submonoid.toSubsemigroup",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Units.instDiscreteTopology",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Set.Elem",
            "Set.instSingletonSet",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Real.commRing",
            "AutomorphicForm.GLn.IsConstantOn.mk",
            "Mathlib.Topology.Order._auxLemma.6",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "eq_self",
            "Subsemigroup.carrier",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "Subsingleton.discreteTopology",
            "Eq.refl",
            "IsOpen",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "Prod",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "IsCompact",
            "Subgroup.toSubmonoid",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "exact\n  { is_open := by simp\n    is_compact := by aesop\n    finite_level := by simp }",
          "proofState": 397,
          "pos": {
            "line": 93,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 IsConstantOn U fun x => c",
          "endPos": {
            "line": 97,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Submonoid.toSubsemigroup",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Units.instDiscreteTopology",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Mathlib.Topology.Order._auxLemma.6",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Subsemigroup.carrier",
            "of_eq_true",
            "Int.instAddGroup",
            "Subsingleton.discreteTopology",
            "IsOpen",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "instTopologicalSpaceMatrix",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Subgroup.toSubmonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 398,
          "pos": {
            "line": 94,
            "column": 24
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 IsOpen U.carrier",
          "endPos": {
            "line": 94,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Mathlib.Topology.Compactness.Compact._auxLemma.24",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Set.instSingletonSet",
            "instOfNatNat",
            "Int",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "instTopologicalSpaceMatrix",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "IsCompact",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "aesop",
          "proofState": 399,
          "pos": {
            "line": 95,
            "column": 27
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 IsCompact U.carrier",
          "endPos": {
            "line": 95,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Submonoid.toSubsemigroup",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Set.Elem",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "eq_self",
            "Subsemigroup.carrier",
            "of_eq_true",
            "Int.instAddGroup",
            "Eq.refl",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Subgroup.toSubmonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 400,
          "pos": {
            "line": 96,
            "column": 29
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 \u2191U.carrier \u2192 GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a) \u2192 GL (Fin 0) \u211d \u2192 c = c",
          "endPos": {
            "line": 96,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Int.euclideanDomain",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Fin"
          ],
          "tactic": "intros x",
          "proofState": 401,
          "pos": {
            "line": 78,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 (x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)),\n    FiniteDimensional \u2102\n      (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n        Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n          (annihilator \u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 78,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "FiniteDimensional.eq_1",
            "Algebra.id",
            "id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Int",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "FiniteDimensional",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Module.Finite",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.annihilator",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "IsLocallyConstant.eq_1",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "rw [FiniteDimensional]",
          "proofState": 402,
          "pos": {
            "line": 79,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 FiniteDimensional \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        (annihilator \u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 79,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "AutomorphicForm.GLn.annihilator.eq_1",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Module.Finite",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.annihilator",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "IsLocallyConstant.eq_1",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "rw [annihilator]",
          "proofState": 403,
          "pos": {
            "line": 80,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 Module.Finite \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        (annihilator \u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 80,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Module.Finite",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "IsLocallyConstant.eq_1",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 404,
          "pos": {
            "line": 81,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 Module.Finite \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        ((Submodule.span \u2102 {\u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9}).compatibleMaps \u22a5))",
          "endPos": {
            "line": 81,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "sorryAx",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "Submodule.instTop",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Lean.Name.num",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "Submodule.FG",
            "Lean.Name.str",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Lean.Name.anonymous",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Lean.Name",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Bool.false",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Module.Finite.mk",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "exact { fg_top := by sorry }",
          "proofState": 405,
          "pos": {
            "line": 82,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 Module.Finite \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        ((Submodule.span \u2102 {\u27e8fun y => c, \u22ef\u27e9}).compatibleMaps \u22a5))",
          "endPos": {
            "line": 84,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "sorryAx",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "Submodule.instTop",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Lean.Name.num",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "Submodule.FG",
            "Lean.Name.str",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Lean.Name.anonymous",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Lean.Name",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Bool.false",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "sorry",
          "proofState": 406,
          "pos": {
            "line": 83,
            "column": 21
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u22a4.FG",
          "endPos": {
            "line": 83,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "Eq.mpr",
            "AutomorphicForm.GL0.ofComplex",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "Function.LeftInverse",
            "NormedRing.toRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Function.LeftInverse.eq_1",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [Function.LeftInverse]",
          "proofState": 407,
          "pos": {
            "line": 105,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 Function.LeftInverse (fun c => ofComplex \u03c1 c) fun f => f.toFun 1",
          "endPos": {
            "line": 105,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "AutomorphicForm.GL0.ofComplex",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [ofComplex]",
          "proofState": 408,
          "pos": {
            "line": 106,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 \u2200 (x : AutomorphicFormForGLnOverQ 0 \u03c1), ofComplex \u03c1 (x.toFun 1) = x",
          "endPos": {
            "line": 106,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "instOfNatNat",
            "Nat",
            "OfNat.ofNat"
          ],
          "tactic": "intro x",
          "proofState": 409,
          "pos": {
            "line": 107,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 \u2200 (x : AutomorphicFormForGLnOverQ 0 \u03c1),\n    { toFun := fun x_1 => x.toFun 1, is_smooth := \u22ef, is_periodic := \u22ef, is_slowly_increasing := \u22ef, has_finite_level := \u22ef,\n        is_finite_cod := \u22ef } =\n      x",
          "endPos": {
            "line": 107,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "AutomorphicForm.GL0.ofComplex.proof_1",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "AutomorphicForm.GL0.ofComplex.proof_2",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GL0.ofComplex.proof_3",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "AutomorphicForm.GL0.ofComplex.proof_6",
            "instOfNatNat",
            "Int",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.mk",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "AutomorphicForm.GL0.ofComplex.proof_5",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "letFun",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "AutomorphicForm.GL0.ofComplex.proof_4",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have h : x.toFun = fun _ => x.toFun 1 := by exact funext fun g \u21a6 congrArg x.toFun <| Subsingleton.eq_one g",
          "proofState": 410,
          "pos": {
            "line": 108,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\nx : AutomorphicFormForGLnOverQ 0 \u03c1\n\u22a2 { toFun := fun x_1 => x.toFun 1, is_smooth := \u22ef, is_periodic := \u22ef, is_slowly_increasing := \u22ef, has_finite_level := \u22ef,\n      is_finite_cod := \u22ef } =\n    x",
          "endPos": {
            "line": 109,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Subsingleton.eq_one",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "instSubsingletonProd",
            "funext",
            "Unique.instSubsingleton",
            "instUniqueUnitsOfSubsingleton",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "exact funext fun g \u21a6 congrArg x.toFun <| Subsingleton.eq_one g",
          "proofState": 411,
          "pos": {
            "line": 109,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nx : AutomorphicFormForGLnOverQ 0 \u03c1\n\u22a2 x.toFun = fun x_1 => x.toFun 1",
          "endPos": {
            "line": 109,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "AutomorphicForm.GL0.ofComplex.proof_1",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "HMul.hMul",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "MonoidHom",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Module.toMulActionWithZero",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "AutomorphicForm.GL0.ofComplex.proof_2",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "AutomorphicForm.GL0.ofComplex.proof_3",
            "Exists",
            "algebraMap",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "Eq.rec",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Subgroup",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "AutomorphicForm.GL0.ofComplex.proof_6",
            "instOfNatNat",
            "Complex.instRCLike",
            "Int",
            "AutomorphicForm.GLn.IsConstantOn",
            "LieAlgebra.ExtendScalars.instLieRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.mk",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "Field.toCommRing",
            "IsScalarTower.left",
            "DivisionRing.toRatAlgebra",
            "AutomorphicForm.GLn.IsSmooth",
            "smulCommClass_self",
            "Fin.fintype",
            "Units.instOne",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "FiniteDimensional",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "DedekindDomain.instLieAlgebra'",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "eq_self",
            "Subalgebra.algebra",
            "Module.Free.self",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "Eq.ndrec",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Units.instMul",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "AutomorphicForm.GLn.IsSlowlyIncreasing",
            "AutomorphicForm.GLn.Weight",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "AutomorphicForm.GL0.ofComplex.proof_5",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "OfNat.ofNat",
            "Eq.symm",
            "AutomorphicForm.GLn.annihilator",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "RCLike.charZero_rclike",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "Rat.commRing",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Units.instMulOneClass",
            "Subalgebra.toSemiring",
            "AutomorphicForm.GL0.ofComplex.proof_4",
            "RingHom.GL",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "WithTop"
          ],
          "tactic": "simp_rw [\u2190 h]",
          "proofState": 412,
          "pos": {
            "line": 110,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\nx : AutomorphicFormForGLnOverQ 0 \u03c1\nh : x.toFun = fun x_1 => x.toFun 1\n\u22a2 { toFun := fun x_1 => x.toFun 1, is_smooth := \u22ef, is_periodic := \u22ef, is_slowly_increasing := \u22ef, has_finite_level := \u22ef,\n      is_finite_cod := \u22ef } =\n    x",
          "endPos": {
            "line": 110,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "Eq.mpr",
            "AutomorphicForm.GL0.ofComplex",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "Function.LeftInverse",
            "NormedRing.toRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Function.RightInverse.eq_1",
            "Ring.toIntAlgebra",
            "Function.RightInverse",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [Function.RightInverse, Function.LeftInverse]",
          "proofState": 413,
          "pos": {
            "line": 112,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 Function.RightInverse (fun c => ofComplex \u03c1 c) fun f => f.toFun 1",
          "endPos": {
            "line": 112,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "True",
            "eq_self",
            "of_eq_true",
            "implies_true",
            "Complex",
            "Eq",
            "Eq.trans",
            "forall_congr"
          ],
          "tactic": "simp [ofComplex]",
          "proofState": 414,
          "pos": {
            "line": 113,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 \u2200 (x : \u2102), (ofComplex \u03c1 x).toFun 1 = x",
          "endPos": {
            "line": 113,
            "column": 20
          }
        }
      ],
      "sorries": [
        {
          "proofState": 371,
          "pos": {
            "line": 50,
            "column": 58
          },
          "goal": "n : \u2115\n\u03c1 : Weight n\n\u22a2 Prop",
          "endPos": {
            "line": 50,
            "column": 63
          }
        },
        {
          "proofState": 372,
          "pos": {
            "line": 83,
            "column": 21
          },
          "goal": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u22a4.FG",
          "endPos": {
            "line": 83,
            "column": 26
          }
        },
        {
          "proofState": 373,
          "pos": {
            "line": 127,
            "column": 19
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 IsSmooth fun x => z",
          "endPos": {
            "line": 127,
            "column": 24
          }
        },
        {
          "proofState": 374,
          "pos": {
            "line": 128,
            "column": 21
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2200 (g : GL (Fin n) \u211a) (x : GL (Fin n) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) (y : GL (Fin n) \u211d),\n    (fun x => z)\n        (((algebraMap \u211a (DedekindDomain.FiniteAdeleRing \u2124 \u211a)).GL (Fin n)) g * x, ((algebraMap \u211a \u211d).GL (Fin n)) g * y) =\n      (fun x => z) (x, y)",
          "endPos": {
            "line": 128,
            "column": 26
          }
        },
        {
          "proofState": 375,
          "pos": {
            "line": 129,
            "column": 30
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2200 (x : GL (Fin n) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)), IsSlowlyIncreasing fun y => (fun x => z) (x, y)",
          "endPos": {
            "line": 129,
            "column": 35
          }
        },
        {
          "proofState": 376,
          "pos": {
            "line": 131,
            "column": 26
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2203 U, IsConstantOn U fun x => z",
          "endPos": {
            "line": 131,
            "column": 31
          }
        },
        {
          "proofState": 377,
          "pos": {
            "line": 130,
            "column": 23
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2200 (x : GL (Fin n) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)),\n    FiniteDimensional \u2102\n      (\u21a5(Z (GL (Fin n) \u211d) (Matrix (Fin n) (Fin n) \u211d)) \u29f8\n        Submodule.comap (actionTensorCAlg'3 (GL (Fin n) \u211d) (Matrix (Fin n) (Fin n) \u211d)).toLinearMap\n          (annihilator \u27e8fun y => (fun x => z) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 130,
            "column": 28
          }
        },
        {
          "proofState": 378,
          "pos": {
            "line": 136,
            "column": 28
          },
          "goal": "\u03c1 : Weight 0\nz : \u2102\n\u22a2 \u03c1.IsTrivial",
          "endPos": {
            "line": 136,
            "column": 33
          }
        },
        {
          "proofState": 379,
          "pos": {
            "line": 137,
            "column": 14
          },
          "goal": "\u03c1 : Weight 0\n\u22a2 Function.LeftInverse (fun z => ofComplex z \u03c1 \u22ef) fun f => f.toFun 1",
          "endPos": {
            "line": 137,
            "column": 19
          }
        },
        {
          "proofState": 380,
          "pos": {
            "line": 138,
            "column": 15
          },
          "goal": "\u03c1 : Weight 0\n\u22a2 Function.RightInverse (fun z => ofComplex z \u03c1 \u22ef) fun f => f.toFun 1",
          "endPos": {
            "line": 138,
            "column": 20
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 50,
            "column": 4
          },
          "endPos": {
            "line": 50,
            "column": 24
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 58,
            "column": 4
          },
          "endPos": {
            "line": 58,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 134,
            "column": 18
          },
          "endPos": {
            "line": 134,
            "column": 32
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 134,
            "column": 18
          },
          "endPos": {
            "line": 134,
            "column": 32
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 134,
            "column": 18
          },
          "endPos": {
            "line": 134,
            "column": 32
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 19
    }
  },
  {
    "file": "FLT/NumberField/InfiniteAdeleRing.lean",
    "output": {
      "sorries": [
        {
          "proofState": 415,
          "pos": {
            "line": 28,
            "column": 2
          },
          "goal": "K : Type u_1\nL : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : NumberField L\ninst\u271d : Algebra K L\n\u22a2 L \u2297[K] InfiniteAdeleRing K \u2243A[L]InfiniteAdeleRing L",
          "endPos": {
            "line": 28,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 26,
            "column": 4
          },
          "endPos": {
            "line": 26,
            "column": 49
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 20
    }
  },
  {
    "file": "FLT/NumberField/Completion.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "WithAbs",
            "Pi.topologicalSpace",
            "WithAbs.instRing",
            "NumberField.InfinitePlace.Completion.instAlgebra",
            "IsModuleTopology.continuous_of_ringHom",
            "Real.orderedSemiring",
            "SeminormedAddCommGroup.to_uniformAddGroup",
            "Complex.instNormedField",
            "NumberField.InfinitePlace.comap",
            "PseudoMetricSpace.toUniformSpace",
            "NormedDivisionRing.toDivisionRing",
            "RingHom",
            "NormedField.toField",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "NumberField.InfinitePlace.Completion",
            "DivisionRing.toRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NumberField.InfinitePlace.ExtensionPlace",
            "UniformSpace.Completion.uniformSpace",
            "Pi.semiring",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "WithAbs.normedField",
            "UniformSpace.Completion.ring",
            "UniformSpace.Completion.instNormedCommRing",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "Algebra.TensorProduct.instSemiring",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "TensorProduct",
            "Semifield.toCommSemiring",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "EuclideanDomain.toCommRing",
            "Complex",
            "NumberField.InfinitePlace.Completion.instTopologicalSpaceTensorProduct",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subtype.val",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "NumberField.InfinitePlace.Completion.instNormedField",
            "LieAlgebra.ofAssociativeAlgebra",
            "TopologicalDivisionRing.toTopologicalRing",
            "NumberField.place",
            "Field.toEuclideanDomain",
            "NormedDivisionRing.to_topologicalDivisionRing",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "AbsoluteValue"
          ],
          "tactic": "apply IsModuleTopology.continuous_of_ringHom (R := v.Completion)",
          "proofState": 416,
          "pos": {
            "line": 48,
            "column": 4
          },
          "goals": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nv : InfinitePlace K\nw : InfinitePlace L\n\u22a2 Continuous (\u2191\u2191__spread\u271d\u207b\u2070.toRingHom).toFun",
          "endPos": {
            "line": 48,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "Continuous",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "WithAbs",
            "Pi.topologicalSpace",
            "WithAbs.instRing",
            "NumberField.InfinitePlace.Completion.instAlgebra",
            "Real.orderedSemiring",
            "SeminormedAddCommGroup.to_uniformAddGroup",
            "Complex.instNormedField",
            "NumberField.InfinitePlace.comap",
            "PseudoMetricSpace.toUniformSpace",
            "NormedDivisionRing.toDivisionRing",
            "RingHom",
            "Algebra.toSMul",
            "NormedField.toField",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "Algebra.toModule",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "DivisionRing.toRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NumberField.InfinitePlace.ExtensionPlace",
            "UniformSpace.Completion.uniformSpace",
            "Pi.semiring",
            "Pi.algebra",
            "RingHom.comp",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "WithAbs.normedField",
            "UniformSpace.Completion.ring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "AlgHom.toRingHom",
            "UniformSpace.Completion.instNormedCommRing",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "Algebra.TensorProduct.instAlgebra",
            "Algebra.TensorProduct.instSemiring",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "TensorProduct",
            "Semifield.toCommSemiring",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "EuclideanDomain.toCommRing",
            "Complex",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subtype.val",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "NumberField.InfinitePlace.Completion.instNormedField",
            "LieAlgebra.ofAssociativeAlgebra",
            "TopologicalDivisionRing.toTopologicalRing",
            "letFun",
            "NumberField.place",
            "Field.toEuclideanDomain",
            "NormedDivisionRing.to_topologicalDivisionRing",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Algebra.TensorProduct.includeRight",
            "AbsoluteValue"
          ],
          "tactic": "show Continuous (RingHom.comp _ Algebra.TensorProduct.includeRight.toRingHom)",
          "proofState": 417,
          "pos": {
            "line": 49,
            "column": 4
          },
          "goals": "case h\u03c6\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nv : InfinitePlace K\nw : InfinitePlace L\n\u22a2 Continuous \u21d1(__spread\u271d\u207b\u2070.comp (algebraMap v.Completion (L \u2297[K] v.Completion)))",
          "endPos": {
            "line": 49,
            "column": 81
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "Continuous",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NumberField.InfinitePlace.Completion.comapSemialgHom_cont",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "WithAbs",
            "Pi.topologicalSpace",
            "WithAbs.instRing",
            "NumberField.InfinitePlace.Completion.instAlgebra",
            "Real.orderedSemiring",
            "SeminormedAddCommGroup.to_uniformAddGroup",
            "Complex.instNormedField",
            "NumberField.InfinitePlace.comap",
            "PseudoMetricSpace.toUniformSpace",
            "NormedDivisionRing.toDivisionRing",
            "RingHom",
            "Algebra.toSMul",
            "NormedField.toField",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "Algebra.toModule",
            "continuous_pi",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "NumberField.InfinitePlace.Completion.comapSemialgHom",
            "DivisionRing.toRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NumberField.InfinitePlace.ExtensionPlace",
            "UniformSpace.Completion.uniformSpace",
            "Pi.semiring",
            "WithAbs.instAlgebraReal_fLT",
            "Pi.algebra",
            "RingHom.comp",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "WithAbs.normedField",
            "UniformSpace.Completion.ring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "AlgHom.toRingHom",
            "UniformSpace.Completion.instNormedCommRing",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "Algebra.TensorProduct.instAlgebra",
            "Algebra.TensorProduct.instSemiring",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "TensorProduct",
            "WithAbs.instSemiring",
            "Semifield.toCommSemiring",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "EuclideanDomain.toCommRing",
            "Complex",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subtype.val",
            "SemialgHom",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "NumberField.InfinitePlace.Completion.instNormedField",
            "LieAlgebra.ofAssociativeAlgebra",
            "TopologicalDivisionRing.toTopologicalRing",
            "NumberField.place",
            "Field.toEuclideanDomain",
            "NormedDivisionRing.to_topologicalDivisionRing",
            "Subtype.property",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Algebra.TensorProduct.includeRight",
            "AbsoluteValue"
          ],
          "tactic": "convert (continuous_pi fun wv : v.ExtensionPlace L => comapSemialgHom_cont wv.2) using 1",
          "proofState": 418,
          "pos": {
            "line": 50,
            "column": 4
          },
          "goals": "case h\u03c6\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nv : InfinitePlace K\nw : InfinitePlace L\n\u22a2 Continuous \u21d1(__spread\u271d\u207b\u2070.comp Algebra.TensorProduct.includeRight.toRingHom)",
          "endPos": {
            "line": 50,
            "column": 92
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext",
          "proofState": 419,
          "pos": {
            "line": 51,
            "column": 4
          },
          "goals": "case h.e'_5\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nv : InfinitePlace K\nw : InfinitePlace L\n\u22a2 \u21d1(__spread\u271d\u207b\u2070.comp Algebra.TensorProduct.includeRight.toRingHom) = fun a wv => (comapSemialgHom \u22ef) a",
          "endPos": {
            "line": 51,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "SemialgHom.baseChange_of_algebraMap_tmul_right",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "instFunLike",
            "IsScalarTower.right",
            "WithAbs",
            "NumberField.InfinitePlace.Completion.instAlgebra",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "SemialgHom.baseChange_of_algebraMap",
            "AlgHom",
            "AlgHom.funLike",
            "Pi.semialgHom",
            "Complex.instNormedField",
            "NumberField.InfinitePlace.comap",
            "RingHom",
            "Algebra.toSMul",
            "NormedField.toField",
            "Exists",
            "algebraMap",
            "Algebra.toModule",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "NumberField.InfinitePlace.Completion.comapSemialgHom",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NumberField.InfinitePlace.ExtensionPlace",
            "AddMonoidWithOne.toOne",
            "Pi.semiring",
            "WithAbs.instAlgebraReal_fLT",
            "Pi.algebra",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "WithAbs.normedField",
            "Localization.instSMulCommClassOfIsScalarTower",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace.Completion.baseChange.proof_1",
            "Algebra.TensorProduct.instSemiring",
            "True",
            "CommSemiring.toCommMonoid",
            "eq_self",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "One.toOfNat1",
            "NumberField.InfinitePlace",
            "TensorProduct",
            "WithAbs.instSemiring",
            "Semifield.toCommSemiring",
            "TensorProduct.tmul",
            "Complex",
            "OfNat.ofNat",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "NumberField.InfinitePlace.Completion.instNormedField",
            "NumberField.place",
            "Eq.trans",
            "Subtype.property",
            "Complex.instSemiring",
            "AbsoluteValue"
          ],
          "tactic": "simp [baseChange]",
          "proofState": 420,
          "pos": {
            "line": 52,
            "column": 4
          },
          "goals": "case h.e'_5.h.h\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nv : InfinitePlace K\nw : InfinitePlace L\nx\u271d\u00b9 : v.Completion\nx\u271d : ExtensionPlace L v\n\u22a2 (__spread\u271d\u207b\u2070.comp Algebra.TensorProduct.includeRight.toRingHom) x\u271d\u00b9 x\u271d = (comapSemialgHom \u22ef) x\u271d\u00b9",
          "endPos": {
            "line": 52,
            "column": 21
          }
        }
      ],
      "env": 21
    }
  },
  {
    "file": "FLT/NumberField/Embeddings.lean",
    "output": null
  },
  {
    "file": "FLT/NumberField/AdeleRing.lean",
    "output": null
  },
  {
    "file": "FLT/AutomorphicRepresentation/Example.lean",
    "output": null
  },
  {
    "file": "FLT/Deformations/RepresentationTheory/Subrepresentation.lean",
    "output": null
  },
  {
    "file": "FLT/Deformations/RepresentationTheory/Irreducible.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Topology/Homeomorph.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Topology/Constructions.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/RepresentationTheory/Basic.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/GroupTheory/Index.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/LinearAlgebra/Determinant.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Topology/Algebra/Monoid.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Topology/Algebra/UniformRing.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Topology/Algebra/Order/Field.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Topology/Algebra/Module/ModuleTopology.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Analysis/Normed/Ring/WithAbs.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/NumberTheory/NumberField/Completion.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/NumberTheory/NumberField/Basic.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/MeasureTheory/Group/Action.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/LinearAlgebra/Span/Defs.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Data/Fin/Basic.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Data/Finset/Lattice/Fold.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Algebra/Algebra/Bilinear.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Algebra/Algebra/Pi.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Algebra/Algebra/Hom.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Algebra/Order/Hom/Monoid.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Algebra/Order/AbsoluteValue/Basic.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Algebra/Group/Subgroup/Defs.lean",
    "output": null
  },
  {
    "file": "FLT/Mathlib/Algebra/Module/LinearMap/Defs.lean",
    "output": null
  },
  {
    "file": "FLT/AutomorphicForm/QuaternionAlgebra/Defs.lean",
    "output": null
  },
  {
    "file": "FLT/AutomorphicForm/QuaternionAlgebra/FiniteDimensional.lean",
    "output": null
  },
  {
    "file": "FLT/MathlibExperiments/Coalgebra/Monoid.lean",
    "output": null
  },
  {
    "file": "FLT/MathlibExperiments/Coalgebra/TensorProduct.lean",
    "output": null
  },
  {
    "file": "FLT/MathlibExperiments/Coalgebra/Sweedler.lean",
    "output": null
  },
  {
    "file": "FLT/MathlibExperiments/HopfAlgebra/Basic.lean",
    "output": null
  },
  {
    "file": "FLT/HaarMeasure/DistribHaarChar/RealComplex.lean",
    "output": null
  },
  {
    "file": "FLT/HaarMeasure/DistribHaarChar/Basic.lean",
    "output": null
  },
  {
    "file": "FLT/HaarMeasure/DistribHaarChar/Padic.lean",
    "output": null
  },
  {
    "file": "FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean",
    "output": null
  }
]