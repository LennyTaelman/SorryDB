[
  {
    "file": "FLT.lean",
    "output": {
      "messages": [
        {
          "severity": "info",
          "pos": {
            "line": 30,
            "column": 0
          },
          "endPos": {
            "line": 30,
            "column": 6
          },
          "data": "'PNat.pow_add_pow_ne_pow' depends on axioms: [propext, sorryAx, Classical.choice, Quot.sound]"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/DivisionAlgebra/Finiteness.lean",
    "output": {
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 38,
            "column": 87
          },
          "goal": "K : Type u_1\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : NumberField K\nD : Type u_2\ninst\u271d\u00b9 : DivisionRing D\ninst\u271d : Algebra K D\n\u22a2 Module.Finite (FiniteAdeleRing (\ud835\udcde K) K) (D \u2297[K] FiniteAdeleRing (\ud835\udcde K) K)",
          "endPos": {
            "line": 38,
            "column": 92
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 70,
            "column": 2
          },
          "goal": "K : Type u_1\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : NumberField K\nD : Type u_2\ninst\u271d\u00b3 : DivisionRing D\ninst\u271d\u00b2 : Algebra K D\ninst\u271d\u00b9 : FiniteDimensional K D\ninst\u271d : Algebra.IsCentral K D\nU : Subgroup (Dfx K D)\nhU : IsOpen \u2191U\n\u22a2 Finite (Doset.Quotient (Set.range \u21d1(incl\u2081 K D)) \u2191U)",
          "endPos": {
            "line": 70,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 38,
            "column": 0
          },
          "endPos": {
            "line": 38,
            "column": 92
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 67,
            "column": 8
          },
          "endPos": {
            "line": 67,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/EllipticCurve/Torsion.lean",
    "output": {
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 35,
            "column": 26
          },
          "goal": "k : Type u\ninst\u271d\u00b9 : Field k\nE : WeierstrassCurve k\ninst\u271d : E.IsElliptic\nn : \u2115\n\u22a2 \u2200 (x : E.n_torsion n), n \u2022 x = 0",
          "endPos": {
            "line": 35,
            "column": 31
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 39,
            "column": 91
          },
          "goal": "k : Type u\ninst\u271d\u00b9 : Field k\nE : WeierstrassCurve k\ninst\u271d : E.IsElliptic\nn : \u2115\nhn : 0 < n\n\u22a2 Finite (E.n_torsion n)",
          "endPos": {
            "line": 39,
            "column": 96
          }
        },
        {
          "proofState": 2,
          "pos": {
            "line": 44,
            "column": 38
          },
          "goal": "k : Type u\ninst\u271d\u00b2 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b9 : E.IsElliptic\ninst\u271d : IsSepClosed k\nn : \u2115\nhn : \u2191n \u2260 0\n\u22a2 Nat.card (E.n_torsion n) = n ^ 2",
          "endPos": {
            "line": 44,
            "column": 43
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 49,
            "column": 66
          },
          "goal": "d : \u2115\nA : Type u_1\ninst\u271d : AddCommGroup A\nn : \u2115\nhn : 0 < n\nr : \u2115\nh : \u2200 (d : \u2115), d \u2223 n \u2192 Nat.card \u21a5(Submodule.torsionBy \u2124 A \u2191d) = d ^ r\n\u22a2 \u2203 \u03c6, True",
          "endPos": {
            "line": 49,
            "column": 71
          }
        },
        {
          "proofState": 4,
          "pos": {
            "line": 55,
            "column": 56
          },
          "goal": "k : Type u\ninst\u271d\u00b2 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b9 : E.IsElliptic\ninst\u271d : IsSepClosed k\nn : \u2115\nhn : \u2191n \u2260 0\n\u22a2 \u2203 \u03c6, True",
          "endPos": {
            "line": 55,
            "column": 61
          }
        },
        {
          "proofState": 5,
          "pos": {
            "line": 61,
            "column": 40
          },
          "goal": "k : Type u\ninst\u271d\u2075 : Field k\nE : WeierstrassCurve k\ninst\u271d\u2074 : E.IsElliptic\nK L : Type u\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra k K\ninst\u271d : Algebra k L\nf : K \u2192\u2090[k] L\n\u22a2 E\u27eeK\u27ef \u2192+ E\u27eeL\u27ef",
          "endPos": {
            "line": 61,
            "column": 45
          }
        },
        {
          "proofState": 6,
          "pos": {
            "line": 64,
            "column": 73
          },
          "goal": "k : Type u\ninst\u271d\u00b3 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b2 : E.IsElliptic\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra k K\n\u22a2 map E (AlgHom.id k K) = AddMonoidHom.id E\u27eeK\u27ef",
          "endPos": {
            "line": 64,
            "column": 78
          }
        },
        {
          "proofState": 7,
          "pos": {
            "line": 69,
            "column": 48
          },
          "goal": "k : Type u\ninst\u271d\u2077 : Field k\nE : WeierstrassCurve k\ninst\u271d\u2076 : E.IsElliptic\nK L M : Type u\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : Field M\ninst\u271d\u00b2 : Algebra k K\ninst\u271d\u00b9 : Algebra k L\ninst\u271d : Algebra k M\nf : K \u2192\u2090[k] L\ng : L \u2192\u2090[k] M\n\u22a2 (map E g).comp (map E f) = map E (g.comp f)",
          "endPos": {
            "line": 69,
            "column": 53
          }
        },
        {
          "proofState": 8,
          "pos": {
            "line": 73,
            "column": 44
          },
          "goal": "k : Type u\ninst\u271d\u00b3 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b2 : E.IsElliptic\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra k K\n\u22a2 DistribMulAction (K \u2243\u2090[k] K) E\u27eeK\u27ef",
          "endPos": {
            "line": 73,
            "column": 49
          }
        },
        {
          "proofState": 9,
          "pos": {
            "line": 77,
            "column": 59
          },
          "goal": "k : Type u\ninst\u271d\u00b3 : Field k\nE : WeierstrassCurve k\ninst\u271d\u00b2 : E.IsElliptic\nn : \u2115\nK : Type u\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra k K\n\u22a2 Representation (ZMod n) (K \u2243\u2090[k] K) (E.n_torsion n)",
          "endPos": {
            "line": 77,
            "column": 64
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 34,
            "column": 14
          },
          "endPos": {
            "line": 34,
            "column": 22
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 39,
            "column": 8
          },
          "endPos": {
            "line": 39,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 43,
            "column": 8
          },
          "endPos": {
            "line": 43,
            "column": 39
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 47,
            "column": 8
          },
          "endPos": {
            "line": 47,
            "column": 26
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 54,
            "column": 8
          },
          "endPos": {
            "line": 54,
            "column": 44
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 60,
            "column": 4
          },
          "endPos": {
            "line": 60,
            "column": 31
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 63,
            "column": 6
          },
          "endPos": {
            "line": 63,
            "column": 36
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 66,
            "column": 6
          },
          "endPos": {
            "line": 66,
            "column": 38
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 72,
            "column": 4
          },
          "endPos": {
            "line": 72,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 76,
            "column": 4
          },
          "endPos": {
            "line": 76,
            "column": 48
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/Basic/Reductions.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "FermatLastTheorem"
          ],
          "tactic": "intro h\u2081 a b c n h\u2082",
          "proofState": 2,
          "pos": {
            "line": 49,
            "column": 2
          },
          "goals": "\u22a2 FermatLastTheorem \u2192 \u2200 (a b c : \u2115+), \u2200 n > 2, a ^ n + b ^ n \u2260 c ^ n",
          "endPos": {
            "line": 49,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "specialize h\u2081 n h\u2082 a b c (by simp) (by simp) (by simp)",
          "proofState": 3,
          "pos": {
            "line": 50,
            "column": 2
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 a ^ n + b ^ n \u2260 c ^ n",
          "endPos": {
            "line": 50,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 4,
          "pos": {
            "line": 50,
            "column": 31
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 \u2191a \u2260 0",
          "endPos": {
            "line": 50,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 5,
          "pos": {
            "line": 50,
            "column": 41
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 \u2191b \u2260 0",
          "endPos": {
            "line": 50,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 6,
          "pos": {
            "line": 50,
            "column": 51
          },
          "goals": "h\u2081 : FermatLastTheorem\na b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\n\u22a2 \u2191c \u2260 0",
          "endPos": {
            "line": 50,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "OrderedCommMonoid.toCommMonoid",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "instPNatLinearOrderedCancelCommMonoid",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "instPNatAdd",
            "Monoid.toNatPow",
            "id",
            "Ne",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "instHPow",
            "PNat"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 7,
          "pos": {
            "line": 51,
            "column": 2
          },
          "goals": "a b c : \u2115+\nn : \u2115\nh\u2082 : n > 2\nh\u2081 : \u2191a ^ n + \u2191b ^ n \u2260 \u2191c ^ n\n\u22a2 a ^ n + b ^ n \u2260 c ^ n",
          "endPos": {
            "line": 51,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "FermatLastTheorem.of_odd_primes"
          ],
          "tactic": "apply FermatLastTheorem.of_odd_primes",
          "proofState": 8,
          "pos": {
            "line": 57,
            "column": 2
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\n\u22a2 FermatLastTheorem",
          "endPos": {
            "line": 57,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Nat"
          ],
          "tactic": "intro p pp p_odd",
          "proofState": 9,
          "pos": {
            "line": 58,
            "column": 2
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\n\u22a2 \u2200 (p : \u2115), Nat.Prime p \u2192 Odd p \u2192 FermatLastTheoremFor p",
          "endPos": {
            "line": 58,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "dite",
            "Nat",
            "FermatLastTheoremFor",
            "OfNat.ofNat",
            "Not",
            "Nat.decLe"
          ],
          "tactic": "if hp5 : 5 \u2264 p then exact H _ hp5 pp\nelse\n  have hp2 := pp.two_le\n  interval_cases p\n  \u00b7 contradiction\n  \u00b7 exact fermatLastTheoremThree\n  \u00b7\n    contradiction\n      /-\n      \n      We continue with the reduction of Fermat's Last Theorem.\n      \n      -/",
          "proofState": 10,
          "pos": {
            "line": 59,
            "column": 2
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 66,
            "column": 19
          }
        },
        {
          "usedConstants": [],
          "tactic": "exact H _ hp5 pp",
          "proofState": 11,
          "pos": {
            "line": 60,
            "column": 4
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\nhp5 : 5 \u2264 p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 60,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "Nat",
            "FermatLastTheoremFor",
            "Nat.Prime.two_le",
            "OfNat.ofNat",
            "letFun"
          ],
          "tactic": "have hp2 := pp.two_le",
          "proofState": 12,
          "pos": {
            "line": 62,
            "column": 4
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\nhp5 : \u00ac5 \u2264 p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 62,
            "column": 25
          }
        },
        {
          "usedConstants": [],
          "tactic": "interval_cases p",
          "proofState": 13,
          "pos": {
            "line": 63,
            "column": 4
          },
          "goals": "H : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime p\np_odd : Odd p\nhp5 : \u00ac5 \u2264 p\nhp2 : 2 \u2264 p\n\u22a2 FermatLastTheoremFor p",
          "endPos": {
            "line": 63,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "Odd",
            "instOfNatNat",
            "absurd",
            "Nat",
            "FermatLastTheoremFor",
            "Bool",
            "Nat.instSemiring",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Nat.instDecidablePredOdd",
            "of_decide_eq_false"
          ],
          "tactic": "contradiction",
          "proofState": 14,
          "pos": {
            "line": 64,
            "column": 6
          },
          "goals": "case \u00ab2\u00bb\nH : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime 2\np_odd : Odd 2\nhp5 : \u00ac5 \u2264 2\nhp2 : 2 \u2264 2\n\u22a2 FermatLastTheoremFor 2",
          "endPos": {
            "line": 64,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "fermatLastTheoremThree"
          ],
          "tactic": "exact fermatLastTheoremThree",
          "proofState": 15,
          "pos": {
            "line": 65,
            "column": 6
          },
          "goals": "case \u00ab3\u00bb\nH : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime 3\np_odd : Odd 3\nhp5 : \u00ac5 \u2264 3\nhp2 : 2 \u2264 3\n\u22a2 FermatLastTheoremFor 3",
          "endPos": {
            "line": 65,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "Nat.Prime",
            "instOfNatNat",
            "absurd",
            "Nat",
            "FermatLastTheoremFor",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Nat.decidablePrime",
            "of_decide_eq_false"
          ],
          "tactic": "contradiction\n  /-\n  \n  We continue with the reduction of Fermat's Last Theorem.\n  \n  -/",
          "proofState": 16,
          "pos": {
            "line": 66,
            "column": 6
          },
          "goals": "case \u00ab4\u00bb\nH : \u2200 p \u2265 5, Nat.Prime p \u2192 FermatLastTheoremFor p\np : \u2115\npp : Nat.Prime 4\np_odd : Odd 4\nhp5 : \u00ac5 \u2264 4\nhp2 : 2 \u2264 4\n\u22a2 FermatLastTheoremFor 4",
          "endPos": {
            "line": 66,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega",
          "proofState": 17,
          "pos": {
            "line": 98,
            "column": 62
          },
          "goals": "P : FreyPackage\n\u22a2 0 < 5",
          "endPos": {
            "line": 98,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "Int",
            "Int.instDvd",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "Eq",
            "letFun"
          ],
          "tactic": "have foo : gcd a b \u2223 gcd a c := by\n  apply dvd_gcd (gcd_dvd_left a b)\n  rw [\u2190 Int.pow_dvd_pow_iff hp.ne', \u2190 h]\n  apply dvd_add <;> rw [Int.pow_dvd_pow_iff hp.ne']\n  \u00b7 exact gcd_dvd_left a b\n  \u00b7 exact gcd_dvd_right a b",
          "proofState": 18,
          "pos": {
            "line": 103,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 108,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "apply dvd_gcd (gcd_dvd_left a b)",
          "proofState": 19,
          "pos": {
            "line": 104,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 gcd a c",
          "endPos": {
            "line": 104,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 Int.pow_dvd_pow_iff hp.ne', \u2190 h]",
          "proofState": 20,
          "pos": {
            "line": 105,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 c",
          "endPos": {
            "line": 105,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "dvd_add"
          ],
          "tactic": "apply dvd_add",
          "proofState": 21,
          "pos": {
            "line": 106,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b ^ p \u2223 a ^ p + b ^ p",
          "endPos": {
            "line": 106,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 22,
          "pos": {
            "line": 106,
            "column": 22
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b ^ p \u2223 a ^ p",
          "endPos": {
            "line": 106,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 23,
          "pos": {
            "line": 106,
            "column": 22
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b ^ p \u2223 b ^ p",
          "endPos": {
            "line": 106,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "exact gcd_dvd_left a b",
          "proofState": 24,
          "pos": {
            "line": 107,
            "column": 6
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 a",
          "endPos": {
            "line": 107,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_right"
          ],
          "tactic": "exact gcd_dvd_right a b",
          "proofState": 25,
          "pos": {
            "line": 108,
            "column": 6
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b \u2223 b",
          "endPos": {
            "line": 108,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "Int",
            "Int.instDvd",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "Eq",
            "letFun"
          ],
          "tactic": "have bar : gcd a c \u2223 gcd a b := by\n  apply dvd_gcd (gcd_dvd_left a c)\n  have h2 : b ^ p = c ^ p - a ^ p := eq_sub_of_add_eq' h\n  rw [\u2190 Int.pow_dvd_pow_iff hp.ne', h2]\n  apply dvd_add\n  \u00b7 rw [Int.pow_dvd_pow_iff hp.ne']\n    exact gcd_dvd_right a c\n  \u00b7 rw [dvd_neg, Int.pow_dvd_pow_iff hp.ne']\n    exact gcd_dvd_left a c",
          "proofState": 26,
          "pos": {
            "line": 109,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 117,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "apply dvd_gcd (gcd_dvd_left a c)",
          "proofState": 27,
          "pos": {
            "line": 110,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\n\u22a2 gcd a c \u2223 gcd a b",
          "endPos": {
            "line": 110,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Dvd.dvd",
            "semigroupDvd",
            "HSub.hSub",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "eq_sub_of_add_eq'",
            "Int.instMonoid",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "Int.instCancelCommMonoidWithZero",
            "Int.instSub",
            "instHPow",
            "Eq",
            "letFun"
          ],
          "tactic": "have h2 : b ^ p = c ^ p - a ^ p := eq_sub_of_add_eq' h",
          "proofState": 28,
          "pos": {
            "line": 111,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\n\u22a2 gcd a c \u2223 b",
          "endPos": {
            "line": 111,
            "column": 58
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 Int.pow_dvd_pow_iff hp.ne', h2]",
          "proofState": 29,
          "pos": {
            "line": 112,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c \u2223 b",
          "endPos": {
            "line": 112,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "dvd_add"
          ],
          "tactic": "apply dvd_add",
          "proofState": 30,
          "pos": {
            "line": 113,
            "column": 4
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c ^ p \u2223 c ^ p - a ^ p",
          "endPos": {
            "line": 113,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "Int",
            "Int.pow_dvd_pow_iff",
            "Int.instDvd",
            "Int.instMonoid",
            "LT.lt.ne'",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "Nat.instPreorder",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 31,
          "pos": {
            "line": 114,
            "column": 6
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c ^ p \u2223 c ^ p",
          "endPos": {
            "line": 114,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_right"
          ],
          "tactic": "exact gcd_dvd_right a c",
          "proofState": 32,
          "pos": {
            "line": 115,
            "column": 6
          },
          "goals": "case h\u2081\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c \u2223 c",
          "endPos": {
            "line": 115,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Semigroup.toMul",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "Int.instSemigroup",
            "Monoid.toNatPow",
            "id",
            "Int",
            "Int.instMonoid",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "HPow.hPow",
            "dvd_neg",
            "Nat",
            "propext",
            "Int.instCancelCommMonoidWithZero",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "InvolutiveNeg.toNeg",
            "Eq",
            "Neg.neg"
          ],
          "tactic": "rw [dvd_neg, Int.pow_dvd_pow_iff hp.ne']",
          "proofState": 33,
          "pos": {
            "line": 116,
            "column": 6
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c ^ p \u2223 -a ^ p",
          "endPos": {
            "line": 116,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "GCDMonoid.gcd_dvd_left"
          ],
          "tactic": "exact gcd_dvd_left a c",
          "proofState": 34,
          "pos": {
            "line": 117,
            "column": 6
          },
          "goals": "case h\u2082\na b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nh2 : b ^ p = c ^ p - a ^ p\n\u22a2 gcd a c \u2223 a",
          "endPos": {
            "line": 117,
            "column": 28
          }
        },
        {
          "usedConstants": [],
          "tactic": "change _ \u2223 (Int.gcd a c : \u2124) at foo",
          "proofState": 35,
          "pos": {
            "line": 118,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 gcd a c\nbar : gcd a c \u2223 gcd a b\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 118,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Dvd.dvd",
            "Int.ofNat_dvd",
            "Int",
            "Nat.cast",
            "Int.instDvd",
            "Nat.instDvd",
            "Nat",
            "Iff.mp",
            "instNatCastInt"
          ],
          "tactic": "apply Int.ofNat_dvd.1at bar",
          "proofState": 36,
          "pos": {
            "line": 119,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nbar : gcd a c \u2223 gcd a b\nfoo : gcd a b \u2223 \u2191(a.gcd c)\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 119,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Dvd.dvd",
            "Int.ofNat_dvd",
            "Int",
            "Nat.cast",
            "Int.instDvd",
            "Nat.instDvd",
            "Nat",
            "Iff.mp",
            "instNatCastInt"
          ],
          "tactic": "apply Int.ofNat_dvd.1at foo",
          "proofState": 37,
          "pos": {
            "line": 120,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nfoo : gcd a b \u2223 \u2191(a.gcd c)\nbar : a.gcd c \u2223 a.gcd b\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 120,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Int",
            "Nat.cast",
            "congr_arg",
            "Nat",
            "instNatCastInt",
            "Nat.dvd_antisymm"
          ],
          "tactic": "exact congr_arg ((\u2191) : \u2115 \u2192 \u2124) <| Nat.dvd_antisymm foo bar",
          "proofState": 38,
          "pos": {
            "line": 121,
            "column": 2
          },
          "goals": "a b c : \u2124\np : \u2115\nhp : 0 < p\nh : a ^ p + b ^ p = c ^ p\nbar : a.gcd c \u2223 a.gcd b\nfoo : a.gcd b \u2223 a.gcd c\n\u22a2 gcd a b = gcd a c",
          "endPos": {
            "line": 121,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "congrArg",
            "id",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "instOfNat",
            "FLT.FreyPackage.hFLT",
            "FLT.FreyPackage.hppos",
            "Int.instCancelCommMonoidWithZero",
            "FLT.FreyPackage.a",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 gcdab_eq_gcdac P.hppos P.hFLT, P.hgcdab]",
          "proofState": 39,
          "pos": {
            "line": 124,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 gcd P.a P.c = 1",
          "endPos": {
            "line": 124,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "congrArg",
            "id",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "Int.instGCDMonoid",
            "instOfNat",
            "FLT.FreyPackage.hppos",
            "Int.instCancelCommMonoidWithZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 gcdab_eq_gcdac P.hppos, gcd_comm, P.hgcdab]",
          "proofState": 40,
          "pos": {
            "line": 127,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 gcd P.b P.c = 1",
          "endPos": {
            "line": 127,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "Monoid.toNatPow",
            "id",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "add_comm",
            "Int.instMonoid",
            "FLT.FreyPackage.c",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "Int.instAdd",
            "FLT.FreyPackage.a",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "Eq",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup"
          ],
          "tactic": "rw [add_comm]",
          "proofState": 41,
          "pos": {
            "line": 128,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.b ^ P.p + P.a ^ P.p = P.c ^ P.p",
          "endPos": {
            "line": 128,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "FLT.FreyPackage.hFLT"
          ],
          "tactic": "exact P.hFLT",
          "proofState": 42,
          "pos": {
            "line": 129,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.a ^ P.p + P.b ^ P.p = P.c ^ P.p",
          "endPos": {
            "line": 129,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Lean.Omega.Constraint.not_sat'_of_isImpossible",
            "of_decide_eq_true",
            "le_of_le_of_eq",
            "Lean.Omega.Constraint.mk",
            "Lean.Omega.Constraint.combine_sat'",
            "Odd",
            "HSub.hSub",
            "Lean.Omega.LinearCombo.eval",
            "Option.some",
            "Monoid.toNatPow",
            "id",
            "Nat.Prime.odd_of_ne_two",
            "instDecidableEqBool",
            "Int.instNegInt",
            "Int.sub_nonneg_of_le",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage",
            "Nat.cast",
            "Lean.Omega.Int.sub_congr",
            "List.cons",
            "Int.instMonoid",
            "Lean.Omega.LinearCombo",
            "Bool.true",
            "Option.none",
            "instHSub",
            "HPow.hPow",
            "Lean.Omega.LinearCombo.coordinate_eval_0",
            "instOfNat",
            "Lean.Omega.LinearCombo.mk",
            "Lean.Omega.Coeffs.ofList",
            "Nat",
            "Lean.Omega.Constraint.addEquality_sat",
            "Lean.Omega.LinearCombo.sub_eval",
            "Lean.Omega.LinearCombo.coordinate",
            "Bool",
            "Nonempty",
            "Nat.instSemiring",
            "Eq.refl",
            "Int.instSub",
            "Lean.Omega.Int.ofNat_le_of_le",
            "instNatCastInt",
            "instHPow",
            "Lean.Omega.Int.ofNat_congr",
            "OfNat.ofNat",
            "Eq.symm",
            "Lean.Omega.Constraint.addInequality_sat",
            "Decidable.decide",
            "Eq",
            "Lean.Omega.LinearCombo.instSub",
            "letFun",
            "Neg.neg",
            "Int.instLEInt",
            "Eq.trans",
            "Lean.Omega.Constraint.isImpossible",
            "Int.sub_eq_zero_of_eq",
            "List.nil"
          ],
          "tactic": "have p_odd :=\n  pp.odd_of_ne_two\n    (by omega)\n      -- First, show that we can make a,b coprime by dividing through by gcd a b",
          "proofState": 43,
          "pos": {
            "line": 150,
            "column": 2
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 150,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "Nat",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "omega",
          "proofState": 44,
          "pos": {
            "line": 150,
            "column": 37
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\n\u22a2 p \u2260 2",
          "endPos": {
            "line": 150,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Int.instCommMonoid",
            "add_mul",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CancelCommMonoidWithZero.toIsLeftCancelMulZero",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "cast",
            "Distrib.rightDistribClass",
            "pow_ne_zero",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Eq.mp",
            "right_ne_zero_of_mul",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "CommMagma.toMul",
            "instOfNatNat",
            "Int",
            "mul_left_cancel\u2080",
            "Int.pow_dvd_pow_iff",
            "FLT.FreyPackage",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "And.casesOn",
            "LT.lt.ne'",
            "Int.instNormedCommRing",
            "instHAdd",
            "Int.instDistrib",
            "And",
            "Exists.casesOn",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5.match_1",
            "Nat.instPreorder",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "AddGroup.existsAddOfLE",
            "Nat.Prime.ne_zero",
            "And.intro",
            "congr",
            "AddZeroClass.toZero",
            "LT.lt",
            "left_ne_zero_of_mul",
            "Exists.intro",
            "Iff.mp",
            "mul_comm",
            "Eq.ndrec",
            "Int.instAdd",
            "Int.instAddGroup",
            "Int.instCancelCommMonoidWithZero",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Nonempty",
            "Zero.toOfNat0",
            "Int.exists_gcd_one'",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "instLTNat",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "mul_pow",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.gcd_pos_of_ne_zero_left",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have \u27e8a, b, c, a0, b0, c0, ab, H\u27e9 : \u2203 (a b c : \u2124), a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 Int.gcd a b = 1 \u2227 a ^ p + b ^ p = c ^ p :=\n  by\n  obtain \u27e8d, a', b', d0, cop, a_eq, b_eq\u27e9 := Int.exists_gcd_one' (Int.gcd_pos_of_ne_zero_left b ha)\n  simp only [a_eq, mul_pow, b_eq] at H\n  rw [\u2190 add_mul, mul_comm] at H\n  obtain \u27e8c', rfl\u27e9 := (Int.pow_dvd_pow_iff pp.ne_zero).1 \u27e8_, H.symm\u27e9\n  rw [mul_pow] at H\n  have a0' := left_ne_zero_of_mul (a_eq \u25b8 ha)\n  have b0' := left_ne_zero_of_mul (b_eq \u25b8 hb)\n  have c0' := right_ne_zero_of_mul hc\n  exact\n    \u27e8a', b', c', a0', b0', c0', cop, mul_left_cancel\u2080 (pow_ne_zero _ (mod_cast d0.ne')) H\u27e9\n      -- Then show that WLOG we can take b to be even,\n        -- because at least one of a,b,c is even and we can permute if needed",
          "proofState": 45,
          "pos": {
            "line": 152,
            "column": 2
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\np_odd : Odd p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 163,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "Int.exists_gcd_one'",
            "Int.gcd_pos_of_ne_zero_left"
          ],
          "tactic": "obtain \u27e8d, a', b', d0, cop, a_eq, b_eq\u27e9 := Int.exists_gcd_one' (Int.gcd_pos_of_ne_zero_left b ha)",
          "proofState": 46,
          "pos": {
            "line": 154,
            "column": 4
          },
          "goals": "a b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\np_odd : Odd p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 155,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "Int.instCommMonoid",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Monoid.toNatPow",
            "Eq.mp",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "congr",
            "Int.instAdd",
            "instNatCastInt",
            "instHPow",
            "mul_pow",
            "Eq",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp only [a_eq, mul_pow, b_eq] at H",
          "proofState": 47,
          "pos": {
            "line": 156,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro\na b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH : a ^ p + b ^ p = c ^ p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 156,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "Int.instCommMonoid",
            "add_mul",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Distrib.rightDistribClass",
            "Monoid.toNatPow",
            "Eq.mp",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "instHAdd",
            "Int.instDistrib",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "Int.instAdd",
            "instNatCastInt",
            "instHPow",
            "Eq.symm",
            "Eq",
            "instHMul"
          ],
          "tactic": "rw [\u2190 add_mul, mul_comm] at H",
          "proofState": 48,
          "pos": {
            "line": 157,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro\na b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nH : a' ^ p * \u2191d ^ p + b' ^ p * \u2191d ^ p = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 157,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.pow_dvd_pow_iff",
            "Nat.Prime.ne_zero",
            "Exists.intro",
            "Iff.mp",
            "Eq.symm"
          ],
          "tactic": "obtain \u27e8c', rfl\u27e9 := (Int.pow_dvd_pow_iff pp.ne_zero).1 \u27e8_, H.symm\u27e9",
          "proofState": 49,
          "pos": {
            "line": 158,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro\na b c : \u2124\nha : a \u2260 0\nhb : b \u2260 0\nhc : c \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 158,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "Int.instCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Monoid.toNatPow",
            "Eq.mp",
            "CommMagma.toMul",
            "Int",
            "Nat.cast",
            "Int.instNormedCommRing",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "Int.instAdd",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "mul_pow",
            "Eq",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "rw [mul_pow] at H",
          "proofState": 50,
          "pos": {
            "line": 159,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = (\u2191d * c') ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 159,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "left_ne_zero_of_mul",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "have a0' := left_ne_zero_of_mul (a_eq \u25b8 ha)",
          "proofState": 51,
          "pos": {
            "line": 160,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 160,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "left_ne_zero_of_mul",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "have b0' := left_ne_zero_of_mul (b_eq \u25b8 hb)",
          "proofState": 52,
          "pos": {
            "line": 161,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\na0' : a' \u2260 0\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 161,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "right_ne_zero_of_mul",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "have c0' := right_ne_zero_of_mul hc",
          "proofState": 53,
          "pos": {
            "line": 162,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\na0' : a' \u2260 0\nb0' : b' \u2260 0\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 162,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.gcd",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "congrArg",
            "CancelCommMonoidWithZero.toIsLeftCancelMulZero",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "cast",
            "pow_ne_zero",
            "Exists",
            "Monoid.toNatPow",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "CommMagma.toMul",
            "instOfNatNat",
            "Int",
            "mul_left_cancel\u2080",
            "Nat.cast",
            "Int.instMonoid",
            "LT.lt.ne'",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat.instPreorder",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "AddGroup.existsAddOfLE",
            "And.intro",
            "AddZeroClass.toZero",
            "Exists.intro",
            "Int.instAdd",
            "Int.instAddGroup",
            "Int.instCancelCommMonoidWithZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "exact\n  \u27e8a', b', c', a0', b0', c0', cop, mul_left_cancel\u2080 (pow_ne_zero _ (mod_cast d0.ne')) H\u27e9\n    -- Then show that WLOG we can take b to be even,\n      -- because at least one of a,b,c is even and we can permute if needed",
          "proofState": 54,
          "pos": {
            "line": 163,
            "column": 4
          },
          "goals": "case intro.intro.intro.intro.intro.intro.intro\na b : \u2124\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\np_odd : Odd p\nd : \u2115\na' b' : \u2124\nd0 : 0 < d\ncop : a'.gcd b' = 1\na_eq : a = a' * \u2191d\nb_eq : b = b' * \u2191d\nc' : \u2124\nhc : \u2191d * c' \u2260 0\nH : \u2191d ^ p * (a' ^ p + b' ^ p) = \u2191d ^ p * c' ^ p\na0' : a' \u2260 0\nb0' : b' \u2260 0\nc0' : c' \u2260 0\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 163,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Int.even_pow",
            "Iff.mpr",
            "Monoid",
            "Odd.neg_pow",
            "Int.gcd",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5.match_2",
            "Int.gcd_neg",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "Int.instDecidablePredEven",
            "id",
            "Int.instNegInt",
            "Nat.Prime.pos",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "Nat.cast_inj",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.even_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "FLT.FreyPackage",
            "Nat.cast",
            "add_comm",
            "dite",
            "Int.instMonoid",
            "iff_of_false",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "Iff",
            "HPow.hPow",
            "instOfNat",
            "And.left",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "And.intro",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "Even",
            "eq_self",
            "SubNegMonoid.toNeg",
            "Exists.intro",
            "Iff.mp",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "add_neg_cancel_comm_assoc",
            "Nonempty",
            "Zero.toOfNat0",
            "neg_ne_zero",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Int.gcd_comm",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "even_neg",
            "Neg.neg",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "have \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9 :\n  \u2203 (a b c : \u2124), a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 Int.gcd a b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p := by\n  if eb : Even b then exact \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9\n  else\n    if ea : Even a then exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9\n    else\n      refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9\n      \u00b7 refine Int.gcd_neg.trans (.trans (.symm ?_) ab)\n        exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)\n      \u00b7 refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1\n        \u00b7 exact fun h => ea (Int.even_pow.1 h).1\n        \u00b7 exact fun h => eb (Int.even_pow.1 h).1\n      \u00b7\n        simp [p_odd.neg_pow, \u2190 H]\n          -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 55,
          "pos": {
            "line": 166,
            "column": 2
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Int.instDecidablePredEven",
            "Ne",
            "instOfNatNat",
            "Int",
            "dite",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Even",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "Not"
          ],
          "tactic": "if eb : Even b then exact \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9\nelse\n  if ea : Even a then exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9\n  else\n    refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9\n    \u00b7 refine Int.gcd_neg.trans (.trans (.symm ?_) ab)\n      exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)\n    \u00b7 refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1\n      \u00b7 exact fun h => ea (Int.even_pow.1 h).1\n      \u00b7 exact fun h => eb (Int.even_pow.1 h).1\n    \u00b7\n      simp [p_odd.neg_pow, \u2190 H]\n        -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 56,
          "pos": {
            "line": 168,
            "column": 4
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "exact \u27e8a, b, c, a0, b0, c0, ab, eb, H\u27e9",
          "proofState": 57,
          "pos": {
            "line": 169,
            "column": 6
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : Even b\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 169,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Int.instDecidablePredEven",
            "Ne",
            "instOfNatNat",
            "Int",
            "dite",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Even",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "Not"
          ],
          "tactic": "if ea : Even a then exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9\nelse\n  refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9\n  \u00b7 refine Int.gcd_neg.trans (.trans (.symm ?_) ab)\n    exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)\n  \u00b7 refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1\n    \u00b7 exact fun h => ea (Int.even_pow.1 h).1\n    \u00b7 exact fun h => eb (Int.even_pow.1 h).1\n  \u00b7\n    simp [p_odd.neg_pow, \u2190 H]\n      -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 58,
          "pos": {
            "line": 170,
            "column": 9
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Eq.mpr",
            "congrArg",
            "Exists",
            "Monoid.toNatPow",
            "Eq.rec",
            "id",
            "Ne",
            "instOfNatNat",
            "Int",
            "add_comm",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "OfNat.ofNat",
            "Int.gcd_comm",
            "Eq",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup"
          ],
          "tactic": "exact \u27e8b, a, c, b0, a0, c0, Int.gcd_comm a b \u25b8 ab, ea, by rwa [add_comm]\u27e9",
          "proofState": 59,
          "pos": {
            "line": 171,
            "column": 6
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : Even a\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 171,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "Monoid.toNatPow",
            "id",
            "Int",
            "add_comm",
            "Int.instMonoid",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "Int.instAdd",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "Eq",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup"
          ],
          "tactic": "rwa [add_comm]",
          "proofState": 60,
          "pos": {
            "line": 171,
            "column": 64
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : Even a\n\u22a2 b ^ p + a ^ p = c ^ p",
          "endPos": {
            "line": 171,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Iff.mpr",
            "Int.gcd",
            "NegZeroClass.toNeg",
            "AddMonoid.toAddZeroClass",
            "Exists",
            "Monoid.toNatPow",
            "Int.instNegInt",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "Zero.toOfNat0",
            "neg_ne_zero",
            "instHPow",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "even_neg",
            "Neg.neg"
          ],
          "tactic": "refine \u27e8a, -c, -b, a0, neg_ne_zero.2 c0, neg_ne_zero.2 b0, ?_, even_neg.2 ?_, ?_\u27e9",
          "proofState": 61,
          "pos": {
            "line": 173,
            "column": 6
          },
          "goals": "a\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 173,
            "column": 87
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Int.gcd_neg",
            "Int.instNegInt",
            "instOfNatNat",
            "Int",
            "Nat",
            "OfNat.ofNat",
            "Eq.symm",
            "Neg.neg",
            "Eq.trans"
          ],
          "tactic": "refine Int.gcd_neg.trans (.trans (.symm ?_) ab)",
          "proofState": 62,
          "pos": {
            "line": 174,
            "column": 8
          },
          "goals": "case refine_1\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 a.gcd (-c) = 1",
          "endPos": {
            "line": 174,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "FLT.FreyPackage.gcdab_eq_gcdac",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Nat.Prime.pos",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "Nat.cast_inj",
            "Nat.cast",
            "Int.instRing",
            "Nat",
            "Iff.mp",
            "Int.instCharZero",
            "Eq",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "exact Nat.cast_inj.1 (gcdab_eq_gcdac pp.pos H)",
          "proofState": 63,
          "pos": {
            "line": 175,
            "column": 8
          },
          "goals": "case refine_1\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 a.gcd b = a.gcd c",
          "endPos": {
            "line": 175,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Int.even_pow",
            "Iff.mpr",
            "Monoid.toNatPow",
            "Eq.rec",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.even_add",
            "Int.instMonoid",
            "iff_of_false",
            "instHAdd",
            "And",
            "Iff",
            "HPow.hPow",
            "And.left",
            "HAdd.hAdd",
            "Nat",
            "Even",
            "Iff.mp",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "refine ((Int.even_pow (n := p)).1 (H.symm \u25b8 Int.even_add.2 (iff_of_false ?_ ?_))).1",
          "proofState": 64,
          "pos": {
            "line": 176,
            "column": 8
          },
          "goals": "case refine_2\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 Even c",
          "endPos": {
            "line": 176,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Int.even_pow",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "And",
            "HPow.hPow",
            "And.left",
            "Nat",
            "Even",
            "Iff.mp",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat"
          ],
          "tactic": "exact fun h => ea (Int.even_pow.1 h).1",
          "proofState": 65,
          "pos": {
            "line": 177,
            "column": 10
          },
          "goals": "case refine_2.refine_1\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 \u00acEven (a ^ p)",
          "endPos": {
            "line": 177,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "Int.even_pow",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "And",
            "HPow.hPow",
            "And.left",
            "Nat",
            "Even",
            "Iff.mp",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat"
          ],
          "tactic": "exact fun h => eb (Int.even_pow.1 h).1",
          "proofState": 66,
          "pos": {
            "line": 178,
            "column": 10
          },
          "goals": "case refine_2.refine_2\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 \u00acEven (b ^ p)",
          "endPos": {
            "line": 178,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Monoid",
            "Odd.neg_pow",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Monoid.toNatPow",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "add_neg_cancel_comm_assoc",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp [p_odd.neg_pow, \u2190 H]\n  -- We can ensure additionally that a \u2261 3 [ZMOD 4] by negating everything if necessary",
          "proofState": 67,
          "pos": {
            "line": 179,
            "column": 8
          },
          "goals": "case refine_3\na\u271d b\u271d c\u271d : \u2124\nha : a\u271d \u2260 0\nhb : b\u271d \u2260 0\nhc : c\u271d \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\np_odd : Odd p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\nH : a ^ p + b ^ p = c ^ p\neb : \u00acEven b\nea : \u00acEven a\n\u22a2 a ^ p + (-c) ^ p = (-b) ^ p",
          "endPos": {
            "line": 179,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Int.decidableDvd",
            "Iff.mpr",
            "Monoid",
            "Odd.neg_pow",
            "Int.gcd",
            "Eq.mpr",
            "Int.modEq_iff_dvd",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "of_decide_eq_true",
            "Nat.ble",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "False.elim",
            "AddMonoid.toAddZeroClass",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "eq_false_of_decide",
            "HSub.hSub",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "AddCommGroup.toAddGroup",
            "Int.gcd_neg",
            "Exists",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "Eq.mp",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_start",
            "id",
            "False.casesOn",
            "Distrib.toAdd",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "GCDMonoid.dvd_gcd",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5.match_3",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "CommMonoidWithZero.toMonoidWithZero",
            "SubtractionMonoid.toSubNegMonoid",
            "NonUnitalSemiring.toSemigroupWithZero",
            "SubNegZeroMonoid.toNegZeroClass",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "FLT.FreyPackage",
            "Nat.cast",
            "add_comm",
            "Int.instDvd",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toSemigroupWithZero",
            "Bool.true",
            "Int.instNormedCommRing",
            "Int.instGCDMonoid",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHAdd",
            "And",
            "instHSub",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Int.ModEq",
            "And.intro",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Int.ModEq.neg",
            "True",
            "Even",
            "eq_self",
            "SubNegMonoid.toNeg",
            "Exists.intro",
            "Iff.mp",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "HasDistribNeg",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_stop",
            "Bool",
            "of_eq_true",
            "Int.instAdd",
            "Even.neg",
            "even_iff_two_dvd",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "NonUnitalRing.toNonUnitalSemiring",
            "Semiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nonempty",
            "Zero.toOfNat0",
            "Eq.refl",
            "neg_ne_zero",
            "Int.instSub",
            "AddCommSemigroup.toAddCommMagma",
            "instNatCastInt",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq.symm",
            "Bool.false",
            "AddZeroClass.toAdd",
            "Decidable.decide",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "Int.neg_gcd",
            "letFun",
            "Neg.neg",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_succ",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instSemiring",
            "Int.instAddCommSemigroup",
            "Dvd.dvd.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "have \u27e8a, b, c, ha0, hb0, hc0, ab, ha3, eb, hFLT\u27e9 :\n  \u2203 (a b c : \u2124), a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 Int.gcd a b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p := by\n  -- Since b is even, a cannot also be even\n  have a_odd' : \u2200 {i}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i := fun ai ei =>\n    by\n    have ea := (dvd_sub_right ei).1 (.trans (by decide) (Int.modEq_iff_dvd.1 ai))\n    simpa (config := { decide := true }) [gcd, ab] using dvd_gcd ea (even_iff_two_dvd.1 eb)\n  mod_cases a_mod:a % 4\n  \u00b7 cases a_odd' a_mod (by decide)\n  \u00b7\n    exact\n      \u27e8-a, -b, -c, neg_ne_zero.2 a0, neg_ne_zero.2 b0, neg_ne_zero.2 c0, by rwa [Int.neg_gcd, Int.gcd_neg], a_mod.neg,\n        eb.neg, by simp [p_odd.neg_pow, \u2190 H, add_comm]\u27e9\n  \u00b7 cases a_odd' a_mod (by decide)\n  \u00b7\n    exact\n      \u27e8a, b, c, a0, b0, c0, ab, a_mod, eb, H\u27e9\n        -- Build the Frey package from the assumptions",
          "proofState": 68,
          "pos": {
            "line": 181,
            "column": 2
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 194,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Int.gcd",
            "Int.modEq_iff_dvd",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "Dvd.dvd",
            "of_decide_eq_true",
            "congrArg",
            "False.elim",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "eq_false_of_decide",
            "HSub.hSub",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "AddCommGroup.toAddGroup",
            "Exists",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "Eq.mp",
            "id",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "GCDMonoid.dvd_gcd",
            "Ne",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "CommMonoidWithZero.toMonoidWithZero",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toSemigroupWithZero",
            "Bool.true",
            "Int.instNormedCommRing",
            "Int.instGCDMonoid",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHAdd",
            "And",
            "instHSub",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Int.ModEq",
            "Even",
            "Iff.mp",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "Bool",
            "Int.instAdd",
            "even_iff_two_dvd",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "NonUnitalRing.toNonUnitalSemiring",
            "Semiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Bool.false",
            "Decidable.decide",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "letFun",
            "Eq.trans",
            "Int.instSemiring",
            "Dvd.dvd.trans"
          ],
          "tactic": "have a_odd' : \u2200 {i}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i := fun ai ei =>\n  by\n  have ea := (dvd_sub_right ei).1 (.trans (by decide) (Int.modEq_iff_dvd.1 ai))\n  simpa (config := { decide := true }) [gcd, ab] using dvd_gcd ea (even_iff_two_dvd.1 eb)",
          "proofState": 69,
          "pos": {
            "line": 185,
            "column": 4
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 187,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Int.modEq_iff_dvd",
            "False",
            "Dvd.dvd",
            "of_decide_eq_true",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "id",
            "Int",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "Int.instDvd",
            "SubNegMonoid.toSub",
            "Bool.true",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "Int.ModEq",
            "Iff.mp",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "Bool",
            "NonUnitalRing.toNonUnitalSemiring",
            "Eq.refl",
            "Int.instSub",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq",
            "letFun",
            "Dvd.dvd.trans"
          ],
          "tactic": "have ea := (dvd_sub_right ei).1 (.trans (by decide) (Int.modEq_iff_dvd.1 ai))",
          "proofState": 70,
          "pos": {
            "line": 186,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\ni\u271d : \u2124\nai : a \u2261 i\u271d [ZMOD 4]\nei : 2 \u2223 i\u271d\n\u22a2 False",
          "endPos": {
            "line": 186,
            "column": 83
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "semigroupDvd",
            "SemigroupWithZero.toSemigroup",
            "id",
            "Int",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "Bool.true",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instOfNat",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "Bool",
            "NonUnitalRing.toNonUnitalSemiring",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "decide",
          "proofState": 71,
          "pos": {
            "line": 186,
            "column": 50
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\ni\u271d : \u2124\nai : a \u2261 i\u271d [ZMOD 4]\nei : 2 \u2223 i\u271d\n\u22a2 2 \u2223 4",
          "endPos": {
            "line": 186,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa (config := { decide := true }) [gcd, ab] using dvd_gcd ea (even_iff_two_dvd.1 eb)",
          "proofState": 72,
          "pos": {
            "line": 187,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\ni\u271d : \u2124\nai : a \u2261 i\u271d [ZMOD 4]\nei : 2 \u2223 i\u271d\nea : 2 \u2223 a\n\u22a2 False",
          "endPos": {
            "line": 187,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Nat.ble",
            "Exists",
            "Monoid.toNatPow",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_start",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.ModEq",
            "Even",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_stop",
            "Bool",
            "Int.instAdd",
            "Eq.refl",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "Mathlib.Tactic.ModCases.IntMod.onModCases_succ"
          ],
          "tactic": "mod_cases a_mod:a % 4",
          "proofState": 73,
          "pos": {
            "line": 188,
            "column": 4
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 188,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "cases a_odd' a_mod (by decide)",
          "proofState": 74,
          "pos": {
            "line": 189,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 0 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 189,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "decide",
          "proofState": 75,
          "pos": {
            "line": 189,
            "column": 29
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 0 [ZMOD 4]\n\u22a2 2 \u2223 0",
          "endPos": {
            "line": 189,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Iff.mpr",
            "Monoid",
            "Odd.neg_pow",
            "Int.gcd",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Int.gcd_neg",
            "Exists",
            "Monoid.toNatPow",
            "id",
            "Int.instNegInt",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "add_comm",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.ModEq",
            "And.intro",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Int.ModEq.neg",
            "True",
            "Even",
            "eq_self",
            "SubNegMonoid.toNeg",
            "Exists.intro",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "Even.neg",
            "Zero.toOfNat0",
            "neg_ne_zero",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Int.neg_gcd",
            "Neg.neg",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "exact\n  \u27e8-a, -b, -c, neg_ne_zero.2 a0, neg_ne_zero.2 b0, neg_ne_zero.2 c0, by rwa [Int.neg_gcd, Int.gcd_neg], a_mod.neg,\n    eb.neg, by simp [p_odd.neg_pow, \u2190 H, add_comm]\u27e9",
          "proofState": 76,
          "pos": {
            "line": 190,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 1 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 192,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Eq.mpr",
            "congrArg",
            "id",
            "Int.instNegInt",
            "instOfNatNat",
            "Int",
            "Nat",
            "OfNat.ofNat",
            "Eq",
            "Int.neg_gcd",
            "Neg.neg"
          ],
          "tactic": "rwa [Int.neg_gcd, Int.gcd_neg]",
          "proofState": 77,
          "pos": {
            "line": 191,
            "column": 11
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 1 [ZMOD 4]\n\u22a2 (-a).gcd (-b) = 1",
          "endPos": {
            "line": 191,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Monoid",
            "Odd.neg_pow",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Monoid.toNatPow",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "add_comm",
            "Int.instMonoid",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "HasDistribNeg",
            "of_eq_true",
            "Int.instAdd",
            "AddCommSemigroup.toAddCommMagma",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "Int.instAddCommSemigroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp [p_odd.neg_pow, \u2190 H, add_comm]",
          "proofState": 78,
          "pos": {
            "line": 192,
            "column": 11
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 1 [ZMOD 4]\n\u22a2 (-a) ^ p + (-b) ^ p = (-c) ^ p",
          "endPos": {
            "line": 192,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "cases a_odd' a_mod (by decide)",
          "proofState": 79,
          "pos": {
            "line": 193,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 2 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 193,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Int.decidableDvd",
            "Dvd.dvd",
            "of_decide_eq_true",
            "id",
            "Int",
            "Int.instDvd",
            "Bool.true",
            "instOfNat",
            "Bool",
            "Eq.refl",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq"
          ],
          "tactic": "decide",
          "proofState": 80,
          "pos": {
            "line": 193,
            "column": 29
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 2 [ZMOD 4]\n\u22a2 2 \u2223 2",
          "endPos": {
            "line": 193,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "Exists",
            "Monoid.toNatPow",
            "Ne",
            "instOfNatNat",
            "Int",
            "Int.instMonoid",
            "instHAdd",
            "And",
            "HPow.hPow",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Int.ModEq",
            "And.intro",
            "Even",
            "Exists.intro",
            "Int.instAdd",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "exact\n  \u27e8a, b, c, a0, b0, c0, ab, a_mod, eb, H\u27e9\n    -- Build the Frey package from the assumptions",
          "proofState": 81,
          "pos": {
            "line": 194,
            "column": 6
          },
          "goals": "a\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\nha : a\u271d\u00b9 \u2260 0\nhb : b\u271d\u00b9 \u2260 0\nhc : c\u271d\u00b9 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\np_odd : Odd p\na\u271d b\u271d c\u271d : \u2124\na0\u271d : a\u271d \u2260 0\nb0\u271d : b\u271d \u2260 0\nc0\u271d : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\nH\u271d : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\na0 : a \u2260 0\nb0 : b \u2260 0\nc0 : c \u2260 0\nab : a.gcd b = 1\neb : Even b\nH : a ^ p + b ^ p = c ^ p\na_odd' : \u2200 {i : \u2124}, a \u2261 i [ZMOD 4] \u2192 \u00ac2 \u2223 i\na_mod : a \u2261 3 [ZMOD 4]\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 a.gcd b = 1 \u2227 a \u2261 3 [ZMOD 4] \u2227 Even b \u2227 a ^ p + b ^ p = c ^ p",
          "endPos": {
            "line": 194,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Int.gcd",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SemigroupWithZero.toSemigroup",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "NonUnitalSemiring.toSemigroupWithZero",
            "Nonempty.intro",
            "FLT.FreyPackage",
            "Nat.cast",
            "ZMod",
            "Int.instDvd",
            "ZMod.intCast_zmod_eq_zero_iff_dvd",
            "AddMonoidWithOne.toOne",
            "FLT.FreyPackage.mk",
            "ZMod.intCast_eq_intCast_iff",
            "instNatAtLeastTwo",
            "instOfNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Int.ModEq",
            "True",
            "Even",
            "eq_self",
            "Iff.mp",
            "of_eq_true",
            "even_iff_two_dvd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "instNatCastInt",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring"
          ],
          "tactic": "exact\n  \u27e8{  a, b, c, ha0, hb0, hc0, p, pp, hp5, hFLT\n      hgcdab := by simp [gcd, ab]\n      ha4 := (ZMod.intCast_eq_intCast_iff ..).2 ha3\n      hb2 := (ZMod.intCast_zmod_eq_zero_iff_dvd ..).2 (even_iff_two_dvd.1 eb) }\u27e9",
          "proofState": 82,
          "pos": {
            "line": 196,
            "column": 2
          },
          "goals": "a\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 : \u2124\nha : a\u271d\u00b2 \u2260 0\nhb : b\u271d\u00b2 \u2260 0\nhc : c\u271d\u00b2 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b2 ^ p + b\u271d\u00b2 ^ p = c\u271d\u00b2 ^ p\np_odd : Odd p\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\na0\u271d : a\u271d\u00b9 \u2260 0\nb0\u271d : b\u271d\u00b9 \u2260 0\nc0\u271d : c\u271d\u00b9 \u2260 0\nab\u271d\u00b9 : a\u271d\u00b9.gcd b\u271d\u00b9 = 1\nH\u271d : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\na\u271d b\u271d c\u271d : \u2124\na0 : a\u271d \u2260 0\nb0 : b\u271d \u2260 0\nc0 : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\neb\u271d : Even b\u271d\nH : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhc0 : c \u2260 0\nab : a.gcd b = 1\nha3 : a \u2261 3 [ZMOD 4]\neb : Even b\nhFLT : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 201,
            "column": 4
          }
        },
        {
          "usedConstants": [
            "Int.gcd",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "AddMonoidWithOne.toOne",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "True",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "instNatCastInt",
            "OfNat.ofNat",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp [gcd, ab]",
          "proofState": 83,
          "pos": {
            "line": 198,
            "column": 17
          },
          "goals": "a\u271d\u00b2 b\u271d\u00b2 c\u271d\u00b2 : \u2124\nha : a\u271d\u00b2 \u2260 0\nhb : b\u271d\u00b2 \u2260 0\nhc : c\u271d\u00b2 \u2260 0\np : \u2115\npp : Nat.Prime p\nhp5 : 5 \u2264 p\nH\u271d\u00b9 : a\u271d\u00b2 ^ p + b\u271d\u00b2 ^ p = c\u271d\u00b2 ^ p\np_odd : Odd p\na\u271d\u00b9 b\u271d\u00b9 c\u271d\u00b9 : \u2124\na0\u271d : a\u271d\u00b9 \u2260 0\nb0\u271d : b\u271d\u00b9 \u2260 0\nc0\u271d : c\u271d\u00b9 \u2260 0\nab\u271d\u00b9 : a\u271d\u00b9.gcd b\u271d\u00b9 = 1\nH\u271d : a\u271d\u00b9 ^ p + b\u271d\u00b9 ^ p = c\u271d\u00b9 ^ p\na\u271d b\u271d c\u271d : \u2124\na0 : a\u271d \u2260 0\nb0 : b\u271d \u2260 0\nc0 : c\u271d \u2260 0\nab\u271d : a\u271d.gcd b\u271d = 1\neb\u271d : Even b\u271d\nH : a\u271d ^ p + b\u271d ^ p = c\u271d ^ p\na b c : \u2124\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhc0 : c \u2260 0\nab : a.gcd b = 1\nha3 : a \u2261 3 [ZMOD 4]\neb : Even b\nhFLT : a ^ p + b ^ p = c ^ p\n\u22a2 gcd a b = 1",
          "endPos": {
            "line": 198,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "WeierstrassCurve.\u0394",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "Rat",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "instTransEq",
            "FLT.FreyPackage.c",
            "HPow.hPow",
            "Nat",
            "Trans.simple",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "trans (P.a ^ P.p) ^ 2 * (P.b ^ P.p) ^ 2 * (P.c ^ P.p) ^ 2 / 2 ^ 8",
          "proofState": 84,
          "pos": {
            "line": 217,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 = (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) / 2 ^ 8",
          "endPos": {
            "line": 217,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "Int.cast",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "GroupWithZero.toMonoidWithZero",
            "Rat.instMul",
            "instHDiv",
            "NormedRing.toRing",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "MulZeroClass.toMul",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "FLT.FreyPackage.p",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "instNatAtLeastTwo",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Eq.refl",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "Nat.cast_zero",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Rat.instLinearOrderedField",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "field_simp",
          "proofState": 85,
          "pos": {
            "line": 218,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 = (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.c ^ P.p) ^ 2 / 2 ^ 8",
          "endPos": {
            "line": 218,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "Int.cast",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "GroupWithZero.toMonoidWithZero",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "congrArg",
            "Mathlib.Data.Nat.Cast.Basic._auxLemma.2",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Nat.instMonoid",
            "Rat",
            "DivisionSemiring.toGroupWithZero",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Nat",
            "congr",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Rat.monoid",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Rat.commRing",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "norm_cast",
          "proofState": 86,
          "pos": {
            "line": 219,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 * 2 ^ 8 = (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.c ^ P.p) ^ 2",
          "endPos": {
            "line": 219,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "one_pow",
            "AddGroup.toSubtractionMonoid",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "GroupWithZero.toMonoidWithZero",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "sub_self",
            "Monoid.toMulOneClass",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "sub_zero",
            "Nat.instMonoid",
            "MulZeroClass.zero_mul",
            "AddMonoid.toAddZeroClass",
            "WeierstrassCurve.\u0394.proof_1",
            "Rat",
            "WeierstrassCurve.b\u2088.proof_1",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_pow",
            "HSub.hSub",
            "WeierstrassCurve.b\u2086.proof_1",
            "Rat.addMonoid",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.instPowNat",
            "Nat.instCharZero",
            "Monoid.toNatPow",
            "Int.cast_add",
            "WeierstrassCurve.\u0394.proof_2",
            "Rat.instIntCast",
            "neg_neg",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "WeierstrassCurve.a\u2082",
            "WeierstrassCurve.b\u2084.proof_1",
            "AddGroupWithOne.toIntCast",
            "WeierstrassCurve.a\u2083",
            "FLT.FreyPackage.p",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "MulZeroClass.mul_zero",
            "Int.instMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "CommRing.toCommSemiring",
            "Int.cast_mul",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.7",
            "Ring.toAddCommGroup",
            "WeierstrassCurve.a\u2086",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "MulOneClass.toOne",
            "SubNegMonoid.toNeg",
            "FLT.FreyPackage.hFLT",
            "WeierstrassCurve.a\u2084",
            "of_eq_true",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "neg_mul",
            "FLT.FreyPackage.FreyCurve",
            "Rat.addGroup",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "add_zero",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq.symm",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "NegZeroClass.toZero",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "WeierstrassCurve.mk",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "zero_pow",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "zero_sub",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "WeierstrassCurve.a\u2081",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "WeierstrassCurve.\u0394.proof_3",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [\u2190 P.hFLT, WeierstrassCurve.\u0394, FreyCurve, WeierstrassCurve.b\u2082, WeierstrassCurve.b\u2084, WeierstrassCurve.b\u2086,\n  WeierstrassCurve.b\u2088]",
          "proofState": 87,
          "pos": {
            "line": 220,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.\u0394 * \u2191(2 ^ 8) = \u2191((P.a ^ P.p) ^ 2 * (P.b ^ P.p) ^ 2 * (P.c ^ P.p) ^ 2)",
          "endPos": {
            "line": 221,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Mathlib.Tactic.Ring.pow_one",
            "GroupWithZero.toMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "Mathlib.Tactic.Ring.coeff_one",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Mathlib.Meta.NormNum.intPow_negOfNat_bit1",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Monoid.toMulOneClass",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "WeierstrassCurve.\u0394.proof_1",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.one_natPow",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "Mathlib.Meta.NormNum.IsNatPowT.bit1",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "WeierstrassCurve.b\u2084.proof_1",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "CommRing.toCommSemiring",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "instNatAtLeastTwo",
            "Rat.instCharZero",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "Mathlib.Meta.NormNum.intPow_negOfNat_bit0",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Mathlib.Meta.NormNum.isRat_pow",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Rat.monoid",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Rat.semiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 88,
          "pos": {
            "line": 222,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 ((1 + 4 * ((\u2191P.b ^ P.p - 1 - \u2191P.a ^ P.p) / 4)) ^ 2 * (-(\u2191P.a ^ P.p * \u2191P.b ^ P.p) / 16) ^ 2 -\n        8 * (2 * (-(\u2191P.a ^ P.p * \u2191P.b ^ P.p) / 16)) ^ 3) *\n      256 =\n    (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.a ^ P.p + \u2191P.b ^ P.p) ^ 2",
          "endPos": {
            "line": 222,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Rat",
            "_auxLemma.1",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "CommMagma.toMul",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Rat.commMonoid",
            "FLT.FreyPackage.c",
            "HPow.hPow",
            "CommMonoid.toMonoid",
            "Nat",
            "congr",
            "True",
            "CommSemigroup.toCommMagma",
            "eq_self",
            "mul_comm",
            "of_eq_true",
            "FLT.FreyPackage.a",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "_auxLemma.2",
            "Eq",
            "Rat.instDiv",
            "Nat.instCommSemigroup",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp [\u2190 mul_pow, \u2190 pow_mul, mul_comm 2]",
          "proofState": 89,
          "pos": {
            "line": 223,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.a ^ P.p) ^ 2 * (\u2191P.b ^ P.p) ^ 2 * (\u2191P.c ^ P.p) ^ 2 / 2 ^ 8 = (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) / 2 ^ 8",
          "endPos": {
            "line": 223,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Eq.mpr",
            "WeierstrassCurve.\u0394",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Rat",
            "IsUnit",
            "FLT.FreyPackage.FreyCurve.\u0394",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw [FreyCurve.\u0394, isUnit_iff_ne_zero]",
          "proofState": 90,
          "pos": {
            "line": 227,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 IsUnit P.FreyCurve.\u0394",
          "endPos": {
            "line": 227,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "div_ne_zero"
          ],
          "tactic": "apply div_ne_zero",
          "proofState": 91,
          "pos": {
            "line": 228,
            "column": 4
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) / 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 228,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Int.cast_zero",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instMulNat",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "SubNegZeroMonoid.toNegZeroClass",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Distrib.toMul",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Eq.symm",
            "NegZeroClass.toZero",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Rat.instNatCast",
            "MulZeroClass.toZero",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul"
          ],
          "tactic": "norm_cast",
          "proofState": 92,
          "pos": {
            "line": 229,
            "column": 6
          },
          "goals": "case ha\nP : FreyPackage\n\u22a2 (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p) \u2260 0",
          "endPos": {
            "line": 229,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "HMul.hMul",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "pow_ne_zero",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "FLT.FreyPackage.ha0",
            "MonoidWithZero.toMulZeroOneClass",
            "FLT.FreyPackage.hc0",
            "Nat",
            "AddGroup.existsAddOfLE",
            "FLT.FreyPackage.hb0",
            "Int.instAddGroup",
            "FLT.FreyPackage.a",
            "LinearOrderedRing.isDomain",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "mul_ne_zero",
            "OfNat.ofNat",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "exact pow_ne_zero _ <| mul_ne_zero (mul_ne_zero P.ha0 P.hb0) P.hc0",
          "proofState": 93,
          "pos": {
            "line": 230,
            "column": 6
          },
          "goals": "case ha\nP : FreyPackage\n\u22a2 \u00ac(P.a * P.b * P.c) ^ (2 * P.p) = 0",
          "endPos": {
            "line": 230,
            "column": 72
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "GroupWithZero.toMonoidWithZero",
            "NormedRing.toRing",
            "LinearOrderedSemifield.toSemifield",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "Monoid.toNatPow",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Nat.instAddMonoidWithOne",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "Zero.toOfNat0",
            "Eq.refl",
            "instHPow",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Rat.instLinearOrderedField",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero"
          ],
          "tactic": "norm_num",
          "proofState": 94,
          "pos": {
            "line": 231,
            "column": 6
          },
          "goals": "case hb\nP : FreyPackage\n\u22a2 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 231,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "one_pow",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "CommRing.toNonUnitalCommRing",
            "Monoid.toMulOneClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "WeierstrassCurve.b\u2082",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "WeierstrassCurve.a\u2082",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "instHAdd",
            "CommRing.toCommSemiring",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "neg_mul",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "NormedField.toNormedCommRing",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "WeierstrassCurve.mk",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "WeierstrassCurve.a\u2081",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve, WeierstrassCurve.b\u2082]",
          "proofState": 95,
          "pos": {
            "line": 235,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.b\u2082 = \u2191P.b ^ P.p - \u2191P.a ^ P.p",
          "endPos": {
            "line": 235,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "WeierstrassCurve.b\u2082.proof_1",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Monoid.toMulOneClass",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "DivisionRing.toRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "MulOneClass.toOne",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Rat.monoid",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 96,
          "pos": {
            "line": 236,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 1 + 4 * ((\u2191P.b ^ P.p - 1 - \u2191P.a ^ P.p) / 4) = \u2191P.b ^ P.p - \u2191P.a ^ P.p",
          "endPos": {
            "line": 236,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Rat.addMonoid",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.instPowNat",
            "Rat.instIntCast",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "WeierstrassCurve.b\u2084",
            "WeierstrassCurve.b\u2084.proof_1",
            "WeierstrassCurve.a\u2083",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "MulZeroClass.mul_zero",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "instHAdd",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "WeierstrassCurve.a\u2084",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "neg_mul",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "NormedField.toNormedCommRing",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "add_zero",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "WeierstrassCurve.mk",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Rat.instNeg",
            "WeierstrassCurve.a\u2081",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve, WeierstrassCurve.b\u2084]",
          "proofState": 97,
          "pos": {
            "line": 240,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.b\u2084 = -(\u2191P.a * \u2191P.b) ^ P.p / 8",
          "endPos": {
            "line": 240,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "DivisionRing.toRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "WeierstrassCurve.b\u2084.proof_1",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Int.mul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "NormedField.toNormedCommRing",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Rat.instNeg",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 98,
          "pos": {
            "line": 241,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 2 * (-(\u2191P.a ^ P.p * \u2191P.b ^ P.p) / 16) = -(\u2191P.a * \u2191P.b) ^ P.p / 8",
          "endPos": {
            "line": 241,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "WeierstrassCurve.c\u2084.proof_1",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "WeierstrassCurve.c\u2084",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "FLT.FreyPackage.FreyCurve.b\u2084",
            "WeierstrassCurve.b\u2082",
            "FLT.FreyPackage.FreyCurve.b\u2082",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "WeierstrassCurve.b\u2084",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "SubNegMonoid.toSub",
            "instHAdd",
            "CommRing.toCommSemiring",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Rat.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Rat.instNeg",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve.b\u2082, FreyCurve.b\u2084, WeierstrassCurve.c\u2084]",
          "proofState": 99,
          "pos": {
            "line": 245,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.c\u2084 = (\u2191P.a ^ P.p) ^ 2 + \u2191P.a ^ P.p * \u2191P.b ^ P.p + (\u2191P.b ^ P.p) ^ 2",
          "endPos": {
            "line": 245,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instSub",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.isNat_add",
            "Rat.instMul",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "WeierstrassCurve.c\u2084.proof_1",
            "Int.rawCast",
            "Rat",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.commSemiring",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Rat.instPowNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Rat.instIntCast",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "Rat.instDivisionRing",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "CommRing.toCommSemiring",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Int.mul",
            "Rat.instAdd",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Rat.monoid",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Rat.instDiv",
            "Rat.commRing",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Rat.instNeg",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 100,
          "pos": {
            "line": 246,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.b ^ P.p - \u2191P.a ^ P.p) ^ 2 - 24 * (-(\u2191P.a * \u2191P.b) ^ P.p / 8) =\n    (\u2191P.a ^ P.p) ^ 2 + \u2191P.a ^ P.p * \u2191P.b ^ P.p + (\u2191P.b ^ P.p) ^ 2",
          "endPos": {
            "line": 246,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "HMul.hMul",
            "congrArg",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "WeierstrassCurve.c\u2084",
            "Rat.instIntCast",
            "id",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "FLT.FreyPackage.c",
            "instHAdd",
            "instHSub",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "Rat.instAdd",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve.c\u2084",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "rw [FreyCurve.c\u2084]",
          "proofState": 101,
          "pos": {
            "line": 250,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.c\u2084 = \u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p",
          "endPos": {
            "line": 250,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Rat",
            "HSub.hSub",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Rat.instAdd",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instHPow",
            "NormedField.toNormedCommRing",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Rat.monoid",
            "Ring.toSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw_mod_cast [pow_mul', \u2190 hFLT]",
          "proofState": 102,
          "pos": {
            "line": 251,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 (\u2191P.a ^ P.p) ^ 2 + \u2191P.a ^ P.p * \u2191P.b ^ P.p + (\u2191P.b ^ P.p) ^ 2 = \u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p",
          "endPos": {
            "line": 251,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "FLT.FreyPackage.p",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "FLT.FreyPackage.b",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMonoid",
            "Int.instMul",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 103,
          "pos": {
            "line": 252,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 (P.a ^ P.p) ^ 2 + P.a ^ P.p * P.b ^ P.p + (P.b ^ P.p) ^ 2 = (P.a ^ P.p + P.b ^ P.p) ^ 2 - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 252,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Units.val",
            "WeierstrassCurve.\u0394",
            "Rat.instMul",
            "DivInvMonoid.toInv",
            "instHDiv",
            "HMul.hMul",
            "DivisionCommMonoid.toDivisionMonoid",
            "congrArg",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "Units.val_inv_eq_inv_val",
            "Rat",
            "FLT.FreyPackage.FreyCurve.\u0394",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Units",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "WeierstrassCurve.\u0394'",
            "DivInvMonoid.toMonoid",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "DivisionMonoid.toDivInvMonoid",
            "FLT.FreyPackage.c",
            "Inv.inv",
            "HPow.hPow",
            "Nat",
            "True",
            "eq_self",
            "DivInvMonoid.toDiv",
            "of_eq_true",
            "FLT.FreyPackage.a",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "inv_div",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Units.instInv",
            "Rat.instDiv",
            "Rat.commRing",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp [FreyCurve.\u0394]",
          "proofState": 104,
          "pos": {
            "line": 256,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 \u2191P.FreyCurve.\u0394'\u207b\u00b9 = 2 ^ 8 / (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p)",
          "endPos": {
            "line": 256,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "instHDiv",
            "HMul.hMul",
            "DivisionCommMonoid.toDivisionMonoid",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "instMulNat",
            "instOfNatNat",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "DivisionMonoid.toDivInvMonoid",
            "mul_div_right_comm",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "DivInvMonoid.toDiv",
            "FLT.FreyPackage.a",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "FLT.FreyPackage.FreyCurve",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "rw [mul_div_right_comm, WeierstrassCurve.j, FreyCurve.\u0394'inv, FreyCurve.c\u2084']",
          "proofState": 105,
          "pos": {
            "line": 260,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 P.FreyCurve.j = 2 ^ 8 * (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 / (\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p)",
          "endPos": {
            "line": 260,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.cast_intCast",
            "Rat.instMul",
            "Real",
            "Rat.cast_mul",
            "NormedRing.toRing",
            "HMul.hMul",
            "DivisionRing.toRatCast",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Rify._auxLemma.3",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Int.cast_sub",
            "Int.cast_zero",
            "Real.instRatCast",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_pow",
            "HSub.hSub",
            "Real.instLT",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "DivisionRing.toDivisionSemiring",
            "Int.cast_add",
            "Rat.instIntCast",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Rat.cast",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "Int.instLTInt",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Int.cast_mul",
            "instHSub",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Real.instDivisionRing",
            "LT.lt",
            "Mathlib.Tactic.Qify._auxLemma.4",
            "Rat.instAdd",
            "Rat.cast_zero",
            "DivisionSemiring.toSemiring",
            "Rat.cast_add",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Rat.instLT",
            "Int.instSub",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Ring.toSemiring",
            "Eq",
            "Rat.cast_pow",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Rat.cast_sub",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rify",
          "proofState": 106,
          "pos": {
            "line": 263,
            "column": 2
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 0 < (a + b) ^ 2 - a * b",
          "endPos": {
            "line": 263,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Real.instLinearOrderedField",
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "Iff.mpr",
            "AddGroup.toSubtractionMonoid",
            "StrictOrderedSemiring.toPosMulStrictMono",
            "Int.cast",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Mathlib.Meta.NormNum.isNat_add",
            "Real.partialOrder",
            "Real",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "Trans.trans",
            "IsDomain.to_noZeroDivisors",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "Nat.rawCast",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "OrderedAddCommGroup.toAddLeftMono",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Nat.ble",
            "Real.instZero",
            "Real.instAddMonoid",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "Real.orderedSemiring",
            "Even.pow_nonneg",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "OrderedAddCommMonoid.toPartialOrder",
            "Real.instDivInvMonoid",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "IsCancelAdd.toIsLeftCancelAdd",
            "PartialOrder.toPreorder",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "HSub.hSub",
            "AddCancelMonoid.toIsCancelAdd",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "Real.instLT",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "pow_ne_zero",
            "DivisionMonoid.toDivInvOneMonoid",
            "OrderedSemiring.zeroLEOneClass",
            "LinearOrderedSemiring.toPosMulReflectLT",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "Real.instAddGroup",
            "Ne",
            "DivisionRing.toRing",
            "Real.instRing",
            "OrderedSemiring.toSemiring",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "LinearOrderedRing.toStrictOrderedRing",
            "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
            "SubNegZeroMonoid.toNegZeroClass",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "Real.instMonoid",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "even_two_mul",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Mathlib.Meta.Positivity.pos_of_isNat",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Real.instIsDomain",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Real.orderedAddCommGroup",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "AddGroup.existsAddOfLE",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.nontrivial",
            "Real.instDivisionRing",
            "LT.lt",
            "Real.instIntCast",
            "Int.mul",
            "DivInvMonoid.toDiv",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Bool",
            "lt_add_of_le_of_pos",
            "LinearOrderedSemifield.toLinearOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.cast_ne_zero",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "div_pos",
            "InvOneClass.toInv",
            "instTransEq_1",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddGroup.toAddCancelMonoid",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "RCLike.charZero_rclike",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "calc\n  (0 : \u211d) < (a ^ 2 + (a + b) ^ 2 + b ^ 2) / 2 := by positivity\n  _ = (a + b) ^ 2 - a * b := by ring",
          "proofState": 107,
          "pos": {
            "line": 264,
            "column": 2
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 0 < (\u2191a + \u2191b) ^ 2 - \u2191a * \u2191b",
          "endPos": {
            "line": 266,
            "column": 38
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  (0 : \u211d) < (a ^ 2 + (a + b) ^ 2 + b ^ 2) / 2 := by positivity\n  _ = (a + b) ^ 2 - a * b := by ring",
          "proofState": 108,
          "pos": {
            "line": 265,
            "column": 4
          },
          "goals": "no goals",
          "endPos": {
            "line": 266,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Real.instLinearOrderedField",
            "Iff.mpr",
            "AddGroup.toSubtractionMonoid",
            "StrictOrderedSemiring.toPosMulStrictMono",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.partialOrder",
            "Real",
            "IsDomain.to_noZeroDivisors",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "OrderedAddCommGroup.toAddLeftMono",
            "Nat.ble",
            "Real.instZero",
            "Real.instAddMonoid",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Real.orderedSemiring",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "IsCancelAdd.toIsLeftCancelAdd",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "AddCancelMonoid.toIsCancelAdd",
            "DivisionSemiring.toGroupWithZero",
            "Preorder.toLE",
            "pow_ne_zero",
            "OrderedSemiring.zeroLEOneClass",
            "LinearOrderedSemiring.toPosMulReflectLT",
            "Monoid.toNatPow",
            "IsLeftCancelAdd.addLeftStrictMono_of_addLeftMono",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Real.instAddGroup",
            "Ne",
            "Real.instRing",
            "OrderedSemiring.toSemiring",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
            "SubNegZeroMonoid.toNegZeroClass",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "Real.instMonoid",
            "instHAdd",
            "even_two_mul",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Mathlib.Meta.Positivity.pos_of_isNat",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Real.instIsDomain",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Real.orderedAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.nontrivial",
            "Real.instIntCast",
            "Bool",
            "lt_add_of_le_of_pos",
            "LinearOrderedSemifield.toLinearOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "Int.cast_ne_zero",
            "div_pos",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "AddGroup.toAddCancelMonoid",
            "OfNat.ofNat",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "RCLike.charZero_rclike",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "positivity",
          "proofState": 109,
          "pos": {
            "line": 265,
            "column": 54
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 0 < (\u2191a ^ 2 + (\u2191a + \u2191b) ^ 2 + \u2191b ^ 2) / 2",
          "endPos": {
            "line": 265,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "Int.cast",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Tactic.Ring.single_pow",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Mathlib.Meta.NormNum.isNat_add",
            "Real",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pow",
            "Real.instDivInvMonoid",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.one_pow",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "Real.instAdd",
            "Real.instMonoid",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.div_congr",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "DivInvMonoid.toDiv",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Mathlib.Tactic.Ring.div_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 110,
          "pos": {
            "line": 266,
            "column": 34
          },
          "goals": "a b : \u2124\nhb : b \u2260 0\n\u22a2 (\u2191a ^ 2 + (\u2191a + \u2191b) ^ 2 + \u2191b ^ 2) / 2 = (\u2191a + \u2191b) ^ 2 - \u2191a * \u2191b",
          "endPos": {
            "line": 266,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Nat.Prime",
            "Dvd.dvd",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "Fact",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "Nat.cast",
            "Int.instDvd",
            "Fact.mk",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "letFun",
            "Rat.commRing"
          ],
          "tactic": "have := Fact.mk hqPrime",
          "proofState": 111,
          "pos": {
            "line": 273,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 273,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "Nat.Prime",
            "Dvd.dvd",
            "Nat.prime_iff_prime_int",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "Prime",
            "CommSemiring.toCommMonoidWithZero",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "Nat.cast",
            "Int.instDvd",
            "Iff.mp",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "Int.instCommSemiring",
            "letFun",
            "Rat.commRing"
          ],
          "tactic": "have hqPrime' := Nat.prime_iff_prime_int.mp hqPrime",
          "proofState": 112,
          "pos": {
            "line": 274,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 274,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Rat.instMul",
            "Dvd.dvd",
            "HMul.hMul",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "Ne",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "letFun",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "have h\u2080 : ((P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3 : \u211a) \u2260 0 :=\n  by\n  rw_mod_cast [pow_mul', \u2190 P.hFLT, mul_pow]\n  exact pow_ne_zero _ <| ne_of_gt <| j_pos_aux _ _ (pow_ne_zero _ P.hb0)",
          "proofState": 113,
          "pos": {
            "line": 275,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 277,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Int.cast_zero",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instMulNat",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "SubNegZeroMonoid.toNegZeroClass",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHSub",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Distrib.toMul",
            "Int.instRing",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq.symm",
            "NegZeroClass.toZero",
            "Ring.toSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Rat.instNatCast",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw_mod_cast [pow_mul', \u2190 P.hFLT, mul_pow]",
          "proofState": 114,
          "pos": {
            "line": 276,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\n\u22a2 (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0",
          "endPos": {
            "line": 276,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Int.instCommMonoid",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "HSub.hSub",
            "Preorder.toLE",
            "pow_ne_zero",
            "Monoid.toNatPow",
            "ne_of_gt",
            "instOfNatNat",
            "Int",
            "_private.0.FLT.FreyPackage.j_pos_aux",
            "LinearOrderedRing.toStrictOrderedRing",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Int.instMonoid",
            "instHAdd",
            "instHSub",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "HAdd.hAdd",
            "CommMonoid.toMonoid",
            "Nat",
            "AddGroup.existsAddOfLE",
            "FLT.FreyPackage.hb0",
            "Int.instAdd",
            "Int.instAddGroup",
            "FLT.FreyPackage.a",
            "Zero.toOfNat0",
            "Int.instSub",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "OrderedAddCommGroup.toPartialOrder",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "exact pow_ne_zero _ <| ne_of_gt <| j_pos_aux _ _ (pow_ne_zero _ P.hb0)",
          "proofState": 115,
          "pos": {
            "line": 277,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\n\u22a2 \u00ac((P.a ^ P.p + P.b ^ P.p) ^ 2 - P.a ^ P.p * P.b ^ P.p) ^ 3 = 0",
          "endPos": {
            "line": 277,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "IsDomain.to_noZeroDivisors",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "WeierstrassCurve.j",
            "OrderedAddCommMonoid.toPartialOrder",
            "Rat",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Ne",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "Int.instNormedCommRing",
            "FLT.FreyPackage.ha0",
            "instOfNat",
            "FLT.FreyPackage.hc0",
            "AddGroup.existsAddOfLE",
            "FLT.FreyPackage.hb0",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "mul_ne_zero",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "letFun",
            "Rat.commRing",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "have h\u2081 : P.a * P.b * P.c \u2260 0 := mul_ne_zero (mul_ne_zero P.ha0 P.hb0) P.hc0",
          "proofState": 116,
          "pos": {
            "line": 278,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 278,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "Dvd.dvd",
            "instHDiv",
            "HMul.hMul",
            "congrArg",
            "FLT.FreyPackage.instIsEllipticRatFreyCurve",
            "FLT.FreyPackage.FreyCurve.j",
            "WeierstrassCurve.j",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "FLT.FreyPackage.FreyCurve",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Eq",
            "Rat.instDiv",
            "Rat.commRing",
            "instHMul"
          ],
          "tactic": "rw [FreyCurve.j, padicValRat.div (mul_ne_zero (by norm_num) h\u2080) (pow_ne_zero _ (mod_cast h\u2081)),\n  padicValRat.mul (by norm_num) h\u2080, padicValRat.pow two_ne_zero, \u2190 Nat.cast_two, \u2190 padicValRat_of_nat,\n  padicValNat_primes hqodd.ne', Nat.cast_zero, mul_zero, zero_add]",
          "proofState": 117,
          "pos": {
            "line": 279,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u2191P.p \u2223 padicValRat q P.FreyCurve.j",
          "endPos": {
            "line": 281,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Nat.instAddMonoidWithOne",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "instHPow",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "norm_num",
          "proofState": 118,
          "pos": {
            "line": 279,
            "column": 52
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 279,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NormedRing.toRing",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Monoid.toNatPow",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.IsNatPowT.trans",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Nat.instAddMonoidWithOne",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "HPow.hPow",
            "Nat",
            "Nat.pow",
            "Bool",
            "Eq.refl",
            "instHPow",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Bool.false",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Eq",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Rat.semiring",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "norm_num",
          "proofState": 119,
          "pos": {
            "line": 280,
            "column": 24
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 2 ^ 8 \u2260 0",
          "endPos": {
            "line": 280,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Rat.instSub",
            "Rat.instMul",
            "Dvd.dvd",
            "HMul.hMul",
            "Rat",
            "HSub.hSub",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "OfNat.ofNat",
            "Rat.monoid",
            "Rat.semiring",
            "Not",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have : \u00ac(q : \u2124) \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3 :=\n  by\n  rw [hqPrime'.dvd_pow_iff_dvd three_ne_zero]\n  have hq' : Xor' ((q : \u2124) \u2223 P.a * P.b) ((q : \u2124) \u2223 P.c) :=\n    by\n    rw [xor_iff_not_iff, iff_iff_and_or_not_and_not]\n    rintro (\u27e8hab, hc\u27e9 | \u27e8hab, hc\u27e9)\n    \u00b7 rw [hqPrime'.dvd_mul] at hab\n      apply hqPrime'.not_dvd_one\n      cases hab with\n      | inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n      | inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc\n    \u00b7 rw [hqPrime'.dvd_mul] at hqbad\n      exact hqbad.rec hab hc\n  have h2p0 := mul_ne_zero two_ne_zero P.hp0\n  cases hq' with\n  | inl h =>\n    rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]\n    exact h.2\n  | inr h =>\n    rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]\n    exact h.2",
          "proofState": 120,
          "pos": {
            "line": 282,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u2191P.p \u2223 padicValRat q ((\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3) - padicValRat q ((\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p))",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Nat.instMulZeroClass",
            "Dvd.dvd",
            "HMul.hMul",
            "congrArg",
            "semigroupDvd",
            "HSub.hSub",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "instHSub",
            "HPow.hPow",
            "Prime.dvd_pow_iff_dvd",
            "Nat.instNeZeroSucc",
            "Nat",
            "propext",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "three_ne_zero",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Not",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "rw [hqPrime'.dvd_pow_iff_dvd three_ne_zero]",
          "proofState": 121,
          "pos": {
            "line": 283,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3",
          "endPos": {
            "line": 283,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "HSub.hSub",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.p",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "Xor'",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "instHSub",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Not",
            "letFun",
            "instHMul"
          ],
          "tactic": "have hq' : Xor' ((q : \u2124) \u2223 P.a * P.b) ((q : \u2124) \u2223 P.c) :=\n  by\n  rw [xor_iff_not_iff, iff_iff_and_or_not_and_not]\n  rintro (\u27e8hab, hc\u27e9 | \u27e8hab, hc\u27e9)\n  \u00b7 rw [hqPrime'.dvd_mul] at hab\n    apply hqPrime'.not_dvd_one\n    cases hab with\n    | inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n    | inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc\n  \u00b7 rw [hqPrime'.dvd_mul] at hqbad\n    exact hqbad.rec hab hc",
          "proofState": 122,
          "pos": {
            "line": 284,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 293,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "HMul.hMul",
            "congrArg",
            "xor_iff_not_iff",
            "id",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "Xor'",
            "FLT.FreyPackage.c",
            "Iff",
            "propext",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Eq",
            "Not",
            "instHMul"
          ],
          "tactic": "rw [xor_iff_not_iff, iff_iff_and_or_not_and_not]",
          "proofState": 123,
          "pos": {
            "line": 285,
            "column": 6
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)",
          "endPos": {
            "line": 285,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "And",
            "FLT.FreyPackage.a",
            "Or",
            "instNatCastInt",
            "Not",
            "instHMul"
          ],
          "tactic": "rintro (\u27e8hab, hc\u27e9 | \u27e8hab, hc\u27e9)",
          "proofState": 124,
          "pos": {
            "line": 286,
            "column": 6
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\n\u22a2 \u00ac(\u2191q \u2223 P.a * P.b \u2227 \u2191q \u2223 P.c \u2228 \u00ac\u2191q \u2223 P.a * P.b \u2227 \u00ac\u2191q \u2223 P.c)",
          "endPos": {
            "line": 286,
            "column": 36
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [hqPrime'.dvd_mul] at hab",
          "proofState": 125,
          "pos": {
            "line": 287,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a * P.b\nhc : \u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 287,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toCommMonoidWithZero",
            "Prime.not_dvd_one",
            "Int",
            "Nat.cast",
            "instNatCastInt",
            "Int.instCommSemiring"
          ],
          "tactic": "apply hqPrime'.not_dvd_one",
          "proofState": 126,
          "pos": {
            "line": 288,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a \u2228 \u2191q \u2223 P.b\nhc : \u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 288,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "MonoidWithZero.toSemigroupWithZero",
            "FLT.FreyPackage.a",
            "Eq.refl",
            "Or",
            "instNatCastInt",
            "Int.instCommSemiring"
          ],
          "tactic": "cases hab with\n| inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n| inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc",
          "proofState": 127,
          "pos": {
            "line": 289,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a \u2228 \u2191q \u2223 P.b\nhc : \u2191q \u2223 P.c\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 291,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases hab with\n| inl ha => rw [\u2190 P.hgcdac]; exact dvd_gcd ha hc\n| inr hb => rw [\u2190 P.hgcdbc]; exact dvd_gcd hb hc",
          "proofState": 128,
          "pos": {
            "line": 289,
            "column": 8
          },
          "goals": "case inl.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u2191q \u2223 P.a \u2228 \u2191q \u2223 P.b\nhc : \u2191q \u2223 P.c\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 291,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "FLT.FreyPackage.hgcdac",
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "id",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Nat.cast",
            "MulZeroOneClass.toMulOneClass",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "MulOneClass.toOne",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 P.hgcdac]",
          "proofState": 129,
          "pos": {
            "line": 290,
            "column": 20
          },
          "goals": "case inl.intro.inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nha : \u2191q \u2223 P.a\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 290,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "Nat.cast",
            "FLT.FreyPackage.c",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "FLT.FreyPackage.a",
            "instNatCastInt"
          ],
          "tactic": "exact dvd_gcd ha hc",
          "proofState": 130,
          "pos": {
            "line": 290,
            "column": 37
          },
          "goals": "case inl.intro.inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nha : \u2191q \u2223 P.a\n\u22a2 \u2191q \u2223 gcd P.a P.c",
          "endPos": {
            "line": 290,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "congrArg",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "id",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "MulZeroOneClass.toMulOneClass",
            "FLT.FreyPackage.c",
            "GCDMonoid.gcd",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instGCDMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "MulOneClass.toOne",
            "Int.instCancelCommMonoidWithZero",
            "One.toOfNat1",
            "instNatCastInt",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "FLT.FreyPackage.hgcdbc"
          ],
          "tactic": "rw [\u2190 P.hgcdbc]",
          "proofState": 131,
          "pos": {
            "line": 291,
            "column": 20
          },
          "goals": "case inl.intro.inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nhb : \u2191q \u2223 P.b\n\u22a2 \u2191q \u2223 1",
          "endPos": {
            "line": 291,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "GCDMonoid.dvd_gcd",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "FLT.FreyPackage.c",
            "Int.instGCDMonoid",
            "Int.instCancelCommMonoidWithZero",
            "instNatCastInt"
          ],
          "tactic": "exact dvd_gcd hb hc",
          "proofState": 132,
          "pos": {
            "line": 291,
            "column": 37
          },
          "goals": "case inl.intro.inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhc : \u2191q \u2223 P.c\nhb : \u2191q \u2223 P.b\n\u22a2 \u2191q \u2223 gcd P.b P.c",
          "endPos": {
            "line": 291,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [hqPrime'.dvd_mul] at hqbad",
          "proofState": 133,
          "pos": {
            "line": 292,
            "column": 8
          },
          "goals": "case inr.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u00ac\u2191q \u2223 P.a * P.b\nhc : \u00ac\u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 292,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "False",
            "Dvd.dvd",
            "HMul.hMul",
            "Or.rec",
            "semigroupDvd",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "FLT.FreyPackage.a",
            "Or",
            "instNatCastInt",
            "Int.instCommSemiring",
            "instHMul"
          ],
          "tactic": "exact hqbad.rec hab hc",
          "proofState": 134,
          "pos": {
            "line": 293,
            "column": 8
          },
          "goals": "case inr.intro\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b \u2228 \u2191q \u2223 P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhab : \u00ac\u2191q \u2223 P.a * P.b\nhc : \u00ac\u2191q \u2223 P.c\n\u22a2 False",
          "endPos": {
            "line": 293,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Nat.instMulZeroClass",
            "IsDomain.to_noZeroDivisors",
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "HSub.hSub",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "Nat.instStarOrderedRing",
            "Nat.instStarRing",
            "Ne",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "FLT.FreyPackage.p",
            "Nat.instNonUnitalSemiring",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "two_ne_zero",
            "instHSub",
            "HPow.hPow",
            "FLT.FreyPackage.hp0",
            "Nat.instNeZeroSucc",
            "Nat",
            "StarOrderedRing.toExistsAddOfLE",
            "Nat.instPartialOrder",
            "FLT.FreyPackage.a",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "mul_ne_zero",
            "Nat.instLinearOrderedSemiring",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Not",
            "letFun",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "have h2p0 := mul_ne_zero two_ne_zero P.hp0",
          "proofState": 135,
          "pos": {
            "line": 294,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhq' : Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 294,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Xor'",
            "FLT.FreyPackage.c",
            "FLT.FreyPackage.a",
            "Eq.refl",
            "instNatCastInt"
          ],
          "tactic": "cases hq' with\n| inl h =>\n  rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]\n  exact h.2\n| inr h =>\n  rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]\n  exact h.2",
          "proofState": 136,
          "pos": {
            "line": 295,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhq' : Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)\nh2p0 : 2 * P.p \u2260 0\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases hq' with\n| inl h =>\n  rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]\n  exact h.2\n| inr h =>\n  rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]\n  exact h.2",
          "proofState": 137,
          "pos": {
            "line": 295,
            "column": 4
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nhq' : Xor' (\u2191q \u2223 P.a * P.b) (\u2191q \u2223 P.c)\nh2p0 : 2 * P.p \u2260 0\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "HMul.hMul",
            "dvd_sub_left",
            "congrArg",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "CommSemiring.toCommMonoidWithZero",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "NonUnitalSemiring.toSemigroupWithZero",
            "FLT.FreyPackage.p",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "dvd_pow",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "FLT.FreyPackage.hp0",
            "And.left",
            "Nat",
            "propext",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "NonUnitalRing.toNonUnitalSemiring",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Not",
            "instHMul"
          ],
          "tactic": "rw [dvd_sub_left (dvd_pow h.1 P.hp0), hqPrime'.dvd_pow_iff_dvd h2p0]",
          "proofState": 138,
          "pos": {
            "line": 297,
            "column": 6
          },
          "goals": "case inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.a * P.b \u2227 \u00ac\u2191q \u2223 P.c\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 297,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "And.right",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Not",
            "instHMul"
          ],
          "tactic": "exact h.2",
          "proofState": 139,
          "pos": {
            "line": 298,
            "column": 6
          },
          "goals": "case inl\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.a * P.b \u2227 \u00ac\u2191q \u2223 P.c\n\u22a2 \u00ac\u2191q \u2223 P.c",
          "endPos": {
            "line": 298,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Dvd.dvd",
            "HMul.hMul",
            "congrArg",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "semigroupDvd",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "CommSemiring.toCommMonoidWithZero",
            "dvd_sub_right",
            "SemigroupWithZero.toSemigroup",
            "Monoid.toNatPow",
            "NonUnitalRing.toNonUnitalNonAssocRing",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "NonUnitalSemiring.toSemigroupWithZero",
            "FLT.FreyPackage.p",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "dvd_pow",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "FLT.FreyPackage.c",
            "MonoidWithZero.toSemigroupWithZero",
            "Int.instNormedCommRing",
            "NonUnitalNormedRing.toNonUnitalRing",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "And.left",
            "Nat",
            "propext",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "NonUnitalRing.toNonUnitalSemiring",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Not",
            "instHMul"
          ],
          "tactic": "rw [dvd_sub_right (dvd_pow h.1 h2p0), hqPrime'.dvd_pow_iff_dvd P.hp0]",
          "proofState": 140,
          "pos": {
            "line": 300,
            "column": 6
          },
          "goals": "case inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.c \u2227 \u00ac\u2191q \u2223 P.a * P.b\n\u22a2 \u00ac\u2191q \u2223 P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p",
          "endPos": {
            "line": 300,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "Dvd.dvd",
            "HMul.hMul",
            "Int",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "And.right",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "Not",
            "instHMul"
          ],
          "tactic": "exact h.2",
          "proofState": 141,
          "pos": {
            "line": 301,
            "column": 6
          },
          "goals": "case inr\nP : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nh2p0 : 2 * P.p \u2260 0\nh : \u2191q \u2223 P.c \u2227 \u00ac\u2191q \u2223 P.a * P.b\n\u22a2 \u00ac\u2191q \u2223 P.a * P.b",
          "endPos": {
            "line": 301,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Rat.instSub",
            "Eq.mpr",
            "Rat.instMul",
            "Dvd.dvd",
            "NormedRing.toRing",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Rat",
            "HSub.hSub",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Rat.instPowNat",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Distrib.toMul",
            "Nat",
            "congr",
            "NonUnitalNonAssocSemiring.toDistrib",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Rat.monoid",
            "Ring.toSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "norm_cast",
          "proofState": 142,
          "pos": {
            "line": 302,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis\u271d : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nthis : \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3\n\u22a2 \u2191P.p \u2223 padicValRat q ((\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3) - padicValRat q ((\u2191P.a * \u2191P.b * \u2191P.c) ^ (2 * P.p))",
          "endPos": {
            "line": 302,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Eq.mpr",
            "Dvd.dvd",
            "NormedRing.toRing",
            "HMul.hMul",
            "congrArg",
            "padicValInt",
            "Rat",
            "HSub.hSub",
            "Monoid.toNatPow",
            "Rat.instIntCast",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instDvd",
            "Int.instMonoid",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "padicValRat.of_int",
            "instHSub",
            "Rat.instNormedField",
            "HPow.hPow",
            "Nat",
            "FLT.FreyPackage.a",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "rw [padicValRat.of_int, padicValInt.eq_zero_of_not_dvd this, Nat.cast_zero, zero_sub, Int.cast_pow,\n  padicValRat.pow (mod_cast h\u2081), dvd_neg, Nat.cast_mul]",
          "proofState": 143,
          "pos": {
            "line": 303,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis\u271d : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nthis : \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3\n\u22a2 \u2191P.p \u2223 padicValRat q \u2191((P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3) - padicValRat q \u2191((P.a * P.b * P.c) ^ (2 * P.p))",
          "endPos": {
            "line": 304,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "dvd_mul_of_dvd_left",
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NormedRing.toRing",
            "HMul.hMul",
            "Int.instCommSemigroup",
            "Rat",
            "AddMonoidWithOne.toNatCast",
            "CommMagma.toMul",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "FLT.FreyPackage.p",
            "padicValRat",
            "FLT.FreyPackage.b",
            "Nat.cast",
            "Int.instMul",
            "FLT.FreyPackage.c",
            "dvd_mul_left",
            "Rat.instNormedField",
            "CommSemigroup.toSemigroup",
            "Nat",
            "CommSemigroup.toCommMagma",
            "FLT.FreyPackage.a",
            "instNatCastInt",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "Int.instSemiring",
            "instHMul"
          ],
          "tactic": "exact dvd_mul_of_dvd_left (dvd_mul_left _ _) _",
          "proofState": 144,
          "pos": {
            "line": 305,
            "column": 2
          },
          "goals": "P : FreyPackage\nq : \u2115\nhqPrime : Nat.Prime q\nhqbad : \u2191q \u2223 P.a * P.b * P.c\nhqodd : 2 < q\nthis\u271d : Fact (Nat.Prime q)\nhqPrime' : Prime \u2191q\nh\u2080 : (\u2191P.c ^ (2 * P.p) - (\u2191P.a * \u2191P.b) ^ P.p) ^ 3 \u2260 0\nh\u2081 : P.a * P.b * P.c \u2260 0\nthis : \u00ac\u2191q \u2223 (P.c ^ (2 * P.p) - (P.a * P.b) ^ P.p) ^ 3\n\u22a2 \u2191P.p \u2223 \u21912 * \u2191P.p * padicValRat q \u2191(P.a * P.b * P.c)",
          "endPos": {
            "line": 305,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "FLT.Wiles_Frey"
          ],
          "tactic": "apply Wiles_Frey P",
          "proofState": 145,
          "pos": {
            "line": 347,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 False",
          "endPos": {
            "line": 347,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "FLT.Mazur_Frey"
          ],
          "tactic": "exact Mazur_Frey P",
          "proofState": 146,
          "pos": {
            "line": 349,
            "column": 2
          },
          "goals": "P : FreyPackage\n\u22a2 IsSimpleModule (ZMod P.p) (P.FreyCurve.torsionGaloisRepresentation P.p Qbar).asModule",
          "endPos": {
            "line": 349,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "False",
            "Nat.Prime",
            "Nonempty.elim",
            "FLT.of_p_ge_5",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "GE.ge",
            "Distrib.toAdd",
            "Ne",
            "instOfNatNat",
            "instLENat",
            "FLT.FreyPackage",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "FLT.FreyPackage.false",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "instHPow",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "refine of_p_ge_5 fun p hp5 pp a b c ha hb _ h \u21a6 Nonempty.elim ?_ FreyPackage.false",
          "proofState": 147,
          "pos": {
            "line": 354,
            "column": 2
          },
          "goals": "\u22a2 FermatLastTheorem",
          "endPos": {
            "line": 354,
            "column": 85
          }
        },
        {
          "usedConstants": [
            "FLT.FreyPackage.of_not_FermatLastTheorem_p_ge_5",
            "Int",
            "Nat.cast",
            "instNatCastInt"
          ],
          "tactic": "apply FreyPackage.of_not_FermatLastTheorem_p_ge_5 (a := a) (b := b) (c := c)",
          "proofState": 148,
          "pos": {
            "line": 355,
            "column": 2
          },
          "goals": "p : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 Nonempty FreyPackage",
          "endPos": {
            "line": 355,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 149,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case ha\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191a \u2260 0",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 150,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case hb\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191b \u2260 0",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 151,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case hc\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191c \u2260 0",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption_mod_cast",
          "proofState": 152,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case pp\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 Nat.Prime ?p",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption_mod_cast",
          "proofState": 153,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case hp5\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 5 \u2264 p",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "congrArg",
            "Mathlib.Data.Nat.Cast.Basic._auxLemma.2",
            "Nat.instMonoid",
            "Mathlib.Data.Nat.Cast.Defs._auxLemma.3",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Monoid.toNatPow",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "Int.instMonoid",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "congr",
            "Int.instAdd",
            "instAddNat",
            "instNatCastInt",
            "instHPow",
            "Int.instCharZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "assumption_mod_cast",
          "proofState": 154,
          "pos": {
            "line": 356,
            "column": 8
          },
          "goals": "case H\np : \u2115\nhp5 : p \u2265 5\npp : Nat.Prime p\na b c : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nx\u271d : c \u2260 0\nh : a ^ p + b ^ p = c ^ p\n\u22a2 \u2191a ^ p + \u2191b ^ p = \u2191c ^ p",
          "endPos": {
            "line": 356,
            "column": 27
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 324,
            "column": 93
          },
          "goal": "P : FreyPackage\n\u22a2 IsSimpleModule (ZMod P.p) (P.FreyCurve.torsionGaloisRepresentation P.p Qbar).asModule",
          "endPos": {
            "line": 324,
            "column": 98
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 334,
            "column": 95
          },
          "goal": "P : FreyPackage\n\u22a2 \u00acIsSimpleModule (ZMod P.p) (P.FreyCurve.torsionGaloisRepresentation P.p Qbar).asModule",
          "endPos": {
            "line": 334,
            "column": 100
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 323,
            "column": 8
          },
          "endPos": {
            "line": 323,
            "column": 18
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 333,
            "column": 8
          },
          "endPos": {
            "line": 333,
            "column": 18
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/MathlibExperiments/IsFrobenius.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "Eq.mpr",
            "AlgEquiv.instEquivLike",
            "RingHom.instRingHomClass",
            "MulEquiv.instEquivLike",
            "AlgEquiv.symm",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingHom",
            "Algebra.IsAlgebraic.of_finite",
            "Field.toDivisionRing",
            "id",
            "Ideal.map",
            "AlgEquivClass.toAlgHomClass",
            "DivInvMonoid.toMonoid",
            "DivisionRing.toRing",
            "Ideal",
            "Field.toSemifield",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "AlgEquiv.instAlgEquivClass",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "AlgEquiv",
            "galRestrict",
            "RingHomClass.toRingHom",
            "Ideal.comap",
            "AlgEquiv.aut",
            "DivisionSemiring.toSemiring",
            "MulEquiv",
            "Semifield.toCommSemiring",
            "AlgHomClass.toRingHomClass",
            "CommRing.toRing",
            "CompatibleFamily.comap_symm",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AlgEquiv.instFunLike",
            "EquivLike.toFunLike"
          ],
          "tactic": "erw [\u2190 comap_symm]",
          "proofState": 1,
          "pos": {
            "line": 63,
            "column": 6
          },
          "goals": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : FiniteDimensional K L\ng : L \u2243\u2090[K] L\nP : Ideal A\ninst\u271d : P.IsMaximal\nQ : Ideal B\nh : IsInvariant ((galRestrict A K L B) g) Q\n\u22a2 Q = Ideal.map (\u2191((galRestrict A K L B) g)) Q",
          "endPos": {
            "line": 63,
            "column": 24
          }
        },
        {
          "usedConstants": [],
          "tactic": "exact h",
          "proofState": 2,
          "pos": {
            "line": 63,
            "column": 26
          },
          "goals": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : FiniteDimensional K L\ng : L \u2243\u2090[K] L\nP : Ideal A\ninst\u271d : P.IsMaximal\nQ : Ideal B\nh : IsInvariant ((galRestrict A K L B) g) Q\n\u22a2 Q = Ideal.comap (\u2191((galRestrict A K L B) g).symm) Q",
          "endPos": {
            "line": 63,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "MonoidHom.ext"
          ],
          "tactic": "ext a l",
          "proofState": 3,
          "pos": {
            "line": 83,
            "column": 2
          },
          "goals": "K L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\n\u22a2 AlgEquiv.restrictNormalHom L = MonoidHom.id (L \u2243\u2090[K] L)",
          "endPos": {
            "line": 83,
            "column": 9
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa only [Algebra.id.map_eq_id, RingHom.id_apply, AlgHom.coe_coe] using\n  AlgHom.restrictNormal_commutes (E := L) (F := K) (K\u2081 := L) (K\u2082 := L) a l",
          "proofState": 4,
          "pos": {
            "line": 84,
            "column": 2
          },
          "goals": "case h.h\nK L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\na : L \u2243\u2090[K] L\nl : L\n\u22a2 ((AlgEquiv.restrictNormalHom L) a) l = ((MonoidHom.id (L \u2243\u2090[K] L)) a) l",
          "endPos": {
            "line": 85,
            "column": 76
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "MonoidHom.instFunLike",
            "IsScalarTower.right",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "congrArg",
            "Algebra.id",
            "id",
            "DivInvMonoid.toMonoid",
            "Field.toSemifield",
            "Group.toDivInvMonoid",
            "AlgEquiv.restrictNormalHom",
            "Semifield.toDivisionSemiring",
            "CompatibleFamily.AlgEquiv_restrict_to_domain_equals_id",
            "AlgEquiv",
            "MonoidHom.id",
            "AlgEquiv.aut",
            "DivisionSemiring.toSemiring",
            "Semifield.toCommSemiring",
            "Eq",
            "DFunLike.coe"
          ],
          "tactic": "rw [AlgEquiv_restrict_to_domain_equals_id K L h1]",
          "proofState": 5,
          "pos": {
            "line": 89,
            "column": 2
          },
          "goals": "K L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\ng : L \u2243\u2090[K] L\n\u22a2 (AlgEquiv.restrictNormalHom L) g = g",
          "endPos": {
            "line": 89,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "MonoidHom.instFunLike",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "DivInvMonoid.toMonoid",
            "Field.toSemifield",
            "Group.toDivInvMonoid",
            "Semifield.toDivisionSemiring",
            "AlgEquiv",
            "MonoidHom.id",
            "AlgEquiv.aut",
            "DivisionSemiring.toSemiring",
            "Eq.refl",
            "Semifield.toCommSemiring",
            "DFunLike.coe"
          ],
          "tactic": "rfl",
          "proofState": 6,
          "pos": {
            "line": 90,
            "column": 2
          },
          "goals": "K L : Type\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nh1 : Normal K L\ng : L \u2243\u2090[K] L\n\u22a2 (MonoidHom.id (L \u2243\u2090[K] L)) g = g",
          "endPos": {
            "line": 90,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "sorryAx",
            "instOfNatNat",
            "Lean.Name.num",
            "NumberField.RingOfIntegers.instCommRing",
            "Ideal",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "HasQuotient.Quotient",
            "CommRing.toCommSemiring",
            "Fintype",
            "Nat",
            "Lean.Name",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Bool.false",
            "Ideal.instHasQuotient_1"
          ],
          "tactic": "sorry\n  -- all broken from here but no longer sure this is the right level of generality",
          "proofState": 7,
          "pos": {
            "line": 116,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : NumberField K\nP : Ideal (\ud835\udcde K)\ninst\u271d : P.IsMaximal\n\u22a2 Fintype (\ud835\udcde K \u29f8 P)",
          "endPos": {
            "line": 116,
            "column": 7
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 116,
            "column": 2
          },
          "goal": "p : \u2115\ninst\u271d\u00b9\u2075 : Fact (Nat.Prime p)\nA K L B : Type\ninst\u271d\u00b9\u2074 : CommRing A\ninst\u271d\u00b9\u00b3 : CommRing B\ninst\u271d\u00b9\u00b2 : Algebra A B\ninst\u271d\u00b9\u00b9 : Field K\ninst\u271d\u00b9\u2070 : Field L\ninst\u271d\u2079 : Algebra A K\ninst\u271d\u2078 : IsFractionRing A K\ninst\u271d\u2077 : Algebra B L\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : NumberField K\nP : Ideal (\ud835\udcde K)\ninst\u271d : P.IsMaximal\n\u22a2 Fintype (\ud835\udcde K \u29f8 P)",
          "endPos": {
            "line": 116,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 115,
            "column": 9
          },
          "endPos": {
            "line": 115,
            "column": 34
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 119,
            "column": 0
          },
          "endPos": {
            "line": 119,
            "column": 5
          },
          "data": "using 'exit' to interrupt Lean"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/MathlibExperiments/IsCentralSimple.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [],
          "tactic": "induction s using Finset.induction_on with\n| empty =>\n  simp only [Finset.sum_empty]\n  exact r.refl 0\n| insert hj ih =>\n  next h' j s' =>\n    simp_rw [Finset.sum_insert hj]\n    apply RingCon.add\n    \u00b7 exact h j (Finset.mem_insert_self j s')\n    \u00b7 exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 0,
          "pos": {
            "line": 39,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\ns : Finset \u03b9\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 s, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 s, a i) (\u2211 i \u2208 s, b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction s using Finset.induction_on with\n| empty =>\n  simp only [Finset.sum_empty]\n  exact r.refl 0\n| insert hj ih =>\n  next h' j s' =>\n    simp_rw [Finset.sum_insert hj]\n    apply RingCon.add\n    \u00b7 exact h j (Finset.mem_insert_self j s')\n    \u00b7 exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 1,
          "pos": {
            "line": 39,
            "column": 2
          },
          "goals": "R : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\ns : Finset \u03b9\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 s, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 s, a i) (\u2211 i \u2208 s, b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "RingCon.instFunLikeForallProp",
            "Finset",
            "RingCon",
            "id",
            "Finset.instEmptyCollection",
            "AddCommSemigroup.toAddCommMagma",
            "EmptyCollection.emptyCollection",
            "AddCommMonoid.toAddCommSemigroup",
            "DFunLike.coe",
            "Finset.sum",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp only [Finset.sum_empty]",
          "proofState": 2,
          "pos": {
            "line": 41,
            "column": 4
          },
          "goals": "case empty\nR : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 \u2205, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 \u2205, a i) (\u2211 i \u2208 \u2205, b i)",
          "endPos": {
            "line": 41,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "AddMonoid.toAddZeroClass",
            "RingCon.refl",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "OfNat.ofNat",
            "AddCommMonoid.toAddCommSemigroup",
            "AddCommMagma.toAdd"
          ],
          "tactic": "exact r.refl 0",
          "proofState": 3,
          "pos": {
            "line": 42,
            "column": 4
          },
          "goals": "case empty\nR : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nh : \u2200 i \u2208 \u2205, r (a i) (b i)\n\u22a2 r 0 0",
          "endPos": {
            "line": 42,
            "column": 18
          }
        },
        {
          "usedConstants": [],
          "tactic": "next h' j s' =>\n  simp_rw [Finset.sum_insert hj]\n  apply RingCon.add\n  \u00b7 exact h j (Finset.mem_insert_self j s')\n  \u00b7 exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 4,
          "pos": {
            "line": 44,
            "column": 4
          },
          "goals": "case insert\nR : Type u\ninst\u271d\u00b9 : AddCommMonoid R\ninst\u271d : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\na\u271d : \u03b9\ns\u271d : Finset \u03b9\nhj : a\u271d \u2209 s\u271d\nih : (\u2200 i \u2208 s\u271d, r (a i) (b i)) \u2192 r (\u2211 i \u2208 s\u271d, a i) (\u2211 i \u2208 s\u271d, b i)\nh : \u2200 i \u2208 insert a\u271d s\u271d, r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 insert a\u271d s\u271d, a i) (\u2211 i \u2208 insert a\u271d s\u271d, b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Finset",
            "AddMonoid.toAddZeroClass",
            "Classical.propDecidable",
            "RingCon",
            "id",
            "Insert.insert",
            "Finset.instInsert",
            "AddCommMonoid",
            "instHAdd",
            "HAdd.hAdd",
            "congr",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "Finset.sum_insert",
            "AddCommMonoid.toAddCommSemigroup",
            "AddZeroClass.toAdd",
            "Eq",
            "DFunLike.coe",
            "Finset.sum",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp_rw [Finset.sum_insert hj]",
          "proofState": 5,
          "pos": {
            "line": 45,
            "column": 6
          },
          "goals": "R : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 insert j s', a i) (\u2211 i \u2208 insert j s', b i)",
          "endPos": {
            "line": 45,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "RingCon.add"
          ],
          "tactic": "apply RingCon.add",
          "proofState": 6,
          "pos": {
            "line": 46,
            "column": 6
          },
          "goals": "R : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (a j + \u2211 i \u2208 s', a i) (b j + \u2211 i \u2208 s', b i)",
          "endPos": {
            "line": 46,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Finset.mem_insert_self",
            "Classical.propDecidable",
            "Eq"
          ],
          "tactic": "exact h j (Finset.mem_insert_self j s')",
          "proofState": 7,
          "pos": {
            "line": 47,
            "column": 8
          },
          "goals": "case a\nR : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (a j) (b j)",
          "endPos": {
            "line": 47,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Finset",
            "Classical.propDecidable",
            "Membership.mem",
            "Finset.instMembership",
            "Finset.mem_insert_of_mem",
            "Eq"
          ],
          "tactic": "exact ih fun i hi \u21a6 h i (Finset.mem_insert_of_mem hi)",
          "proofState": 8,
          "pos": {
            "line": 48,
            "column": 8
          },
          "goals": "case a\nR : Type u\ninst\u271d : AddCommMonoid R\nh' : Mul R\n\u03b9 : Type v\na b : \u03b9 \u2192 R\nr : RingCon R\nj : \u03b9\ns' : Finset \u03b9\nhj : j \u2209 s'\nih : (\u2200 i \u2208 s', r (a i) (b i)) \u2192 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)\nh : \u2200 i \u2208 insert j s', r (a i) (b i)\n\u22a2 r (\u2211 i \u2208 s', a i) (\u2211 i \u2208 s', b i)",
          "endPos": {
            "line": 48,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "Subring.mem_center_iff",
            "HMul.hMul",
            "Subring.instSetLike",
            "Ring.toNonAssocRing",
            "congrArg",
            "Matrix",
            "Subring.center",
            "Matrix.instRing",
            "Membership.mem",
            "Field.toDivisionRing",
            "Eq.mp",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Distrib.toMul",
            "Subring",
            "propext",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq",
            "SetLike.instMembership",
            "instHMul"
          ],
          "tactic": "rw [Subring.mem_center_iff] at hd",
          "proofState": 9,
          "pos": {
            "line": 54,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nd : Matrix \u03b9 \u03b9 K\nhd : d \u2208 Subring.center (Matrix \u03b9 \u03b9 K)\n\u22a2 \u2203 k, d = (algebraMap K (Matrix \u03b9 \u03b9 K)) k",
          "endPos": {
            "line": 54,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Matrix.scalar",
            "CommSemiring.toSemiring",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Matrix.instRing",
            "Membership.mem",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "Matrix.instAlgebra",
            "Algebra.id",
            "Ne",
            "DivisionRing.toRing",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Matrix.stdBasisMatrix",
            "Field.toSemifield",
            "Matrix.nonAssocSemiring",
            "AddMonoidWithOne.toOne",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Matrix.mem_range_scalar_of_commute_stdBasisMatrix",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "Semifield.toCommSemiring",
            "Set.range",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "Set"
          ],
          "tactic": "convert mem_range_scalar_of_commute_stdBasisMatrix (M := d) fun i j _ => hd _",
          "proofState": 10,
          "pos": {
            "line": 55,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nd : Matrix \u03b9 \u03b9 K\nhd : \u2200 (g : Matrix \u03b9 \u03b9 K), g * d = d * g\n\u22a2 \u2203 k, d = (algebraMap K (Matrix \u03b9 \u03b9 K)) k",
          "endPos": {
            "line": 55,
            "column": 81
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Matrix.scalar",
            "congrArg",
            "CommSemiring.toSemiring",
            "Matrix",
            "_auxLemma.1",
            "RingHom",
            "Matrix.instRing",
            "Membership.mem",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "Matrix.instAlgebra",
            "Algebra.id",
            "id",
            "DivisionRing.toRing",
            "Field.toSemifield",
            "Matrix.nonAssocSemiring",
            "Iff",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "DivisionSemiring.toSemiring",
            "Semifield.toCommSemiring",
            "Set.range",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Set"
          ],
          "tactic": "simp_rw [Set.mem_range, eq_comm, algebraMap_eq_diagonal, Pi.algebraMap_def, Algebra.id.map_eq_self, scalar_apply]",
          "proofState": 11,
          "pos": {
            "line": 56,
            "column": 4
          },
          "goals": "case a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nd : Matrix \u03b9 \u03b9 K\nhd : \u2200 (g : Matrix \u03b9 \u03b9 K), g * d = d * g\n\u22a2 (\u2203 k, d = (algebraMap K (Matrix \u03b9 \u03b9 K)) k) \u2194 d \u2208 Set.range \u21d1(scalar \u03b9)",
          "endPos": {
            "line": 57,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Ring.toNonAssocRing",
            "Matrix",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Distrib.toMul",
            "NonUnitalNonAssocSemiring.toDistrib"
          ],
          "tactic": "intro r",
          "proofState": 12,
          "pos": {
            "line": 59,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\n\u22a2 \u2200 (a : RingCon (Matrix \u03b9 \u03b9 K)), a = \u22a5 \u2228 a = \u22a4",
          "endPos": {
            "line": 59,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Iff",
            "Distrib.toMul",
            "forall_or_exists_not",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "obtain h | h := _root_.forall_or_exists_not (fun x \u21a6 r 0 x \u2194 x = 0)",
          "proofState": 13,
          "pos": {
            "line": 60,
            "column": 4
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\n\u22a2 r = \u22a5 \u2228 r = \u22a4",
          "endPos": {
            "line": 60,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "Or.inl"
          ],
          "tactic": "left",
          "proofState": 14,
          "pos": {
            "line": 61,
            "column": 6
          },
          "goals": "case inl\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\n\u22a2 r = \u22a5 \u2228 r = \u22a4",
          "endPos": {
            "line": 61,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "RingCon.ext"
          ],
          "tactic": "apply RingCon.ext",
          "proofState": 15,
          "pos": {
            "line": 62,
            "column": 6
          },
          "goals": "case inl.h\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\n\u22a2 r = \u22a5",
          "endPos": {
            "line": 62,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Matrix"
          ],
          "tactic": "intro x y",
          "proofState": 16,
          "pos": {
            "line": 63,
            "column": 6
          },
          "goals": "case inl.h.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\n\u22a2 \u2200 (x y : Matrix \u03b9 \u03b9 K), r x y \u2194 \u22a5 x y",
          "endPos": {
            "line": 63,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "Matrix",
            "OrderBot.toBot",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Bot.bot",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "Matrix.sub",
            "BoundedOrder.toOrderBot",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have : r x y \u2194 r 0 (y - x) := by\n  constructor\n  \u00b7 convert RingCon.add r (r.refl (-x)) using 1\n    rw [neg_add_cancel, sub_eq_add_neg, add_comm]\n  \u00b7 convert RingCon.add r (r.refl x) using 1\n    rw [add_sub_cancel, add_zero]",
          "proofState": 17,
          "pos": {
            "line": 64,
            "column": 6
          },
          "goals": "case inl.h.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r x y \u2194 \u22a5 x y",
          "endPos": {
            "line": 69,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Iff.intro"
          ],
          "tactic": "constructor",
          "proofState": 18,
          "pos": {
            "line": 65,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r x y \u2194 r 0 (y - x)",
          "endPos": {
            "line": 65,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "Matrix",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "RingCon.refl",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Matrix.sub",
            "Ring.toAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Matrix.neg",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "RingCon.add"
          ],
          "tactic": "convert RingCon.add r (r.refl (-x)) using 1",
          "proofState": 19,
          "pos": {
            "line": 66,
            "column": 10
          },
          "goals": "case mp\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r x y \u2192 r 0 (y - x)",
          "endPos": {
            "line": 66,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Matrix",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "neg_add_cancel",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Matrix.addGroup",
            "Matrix.sub",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "SubNegMonoid.toNeg",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Matrix.neg",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [neg_add_cancel, sub_eq_add_neg, add_comm]",
          "proofState": 20,
          "pos": {
            "line": 67,
            "column": 10
          },
          "goals": "case h'.a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\na\u271d : r x y\n\u22a2 r 0 (y - x) \u2194 r (-x + x) (-x + y)",
          "endPos": {
            "line": 67,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "Matrix",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "RingCon.refl",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Matrix.sub",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "RingCon.add"
          ],
          "tactic": "convert RingCon.add r (r.refl x) using 1",
          "proofState": 21,
          "pos": {
            "line": 68,
            "column": 10
          },
          "goals": "case mpr\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\n\u22a2 r 0 (y - x) \u2192 r x y",
          "endPos": {
            "line": 68,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Matrix",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommGroup.toAddGroup",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "instHAdd",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "add_sub_cancel",
            "HAdd.hAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [add_sub_cancel, add_zero]",
          "proofState": 22,
          "pos": {
            "line": 69,
            "column": 10
          },
          "goals": "case h'.a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\na\u271d : r 0 (y - x)\n\u22a2 r x y \u2194 r (x + 0) (x + (y - x))",
          "endPos": {
            "line": 69,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Matrix",
            "OrderBot.toBot",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Bot.bot",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "Iff",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "Matrix.sub",
            "BoundedOrder.toOrderBot",
            "propext",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [this, h, sub_eq_zero, eq_comm, RingCon.coe_bot]",
          "proofState": 23,
          "pos": {
            "line": 70,
            "column": 6
          },
          "goals": "case inl.h.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a \u2194 a = 0\nx y : Matrix \u03b9 \u03b9 K\nthis : r x y \u2194 r 0 (y - x)\n\u22a2 r x y \u2194 \u22a5 x y",
          "endPos": {
            "line": 70,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "Or.inr"
          ],
          "tactic": "right",
          "proofState": 24,
          "pos": {
            "line": 71,
            "column": 6
          },
          "goals": "case inr\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2203 a, \u00ac(r 0 a \u2194 a = 0)\n\u22a2 r = \u22a5 \u2228 r = \u22a4",
          "endPos": {
            "line": 71,
            "column": 11
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8x, hx\u27e9 := h",
          "proofState": 25,
          "pos": {
            "line": 72,
            "column": 6
          },
          "goals": "case inr.h\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nh : \u2203 a, \u00ac(r 0 a \u2194 a = 0)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 72,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have x_ne_zero : x \u2260 0 := by\n  rintro rfl\n  simp [eq_true (r.refl 0)] at hx",
          "proofState": 26,
          "pos": {
            "line": 73,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 75,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "rintro rfl",
          "proofState": 27,
          "pos": {
            "line": 74,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\n\u22a2 x \u2260 0",
          "endPos": {
            "line": 74,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "False",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Matrix",
            "False.elim",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Eq.mp",
            "not_true_eq_false",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "RingCon.refl",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "iff_self",
            "Iff",
            "Distrib.toMul",
            "congr",
            "True",
            "eq_self",
            "eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Not",
            "Field.toEuclideanDomain",
            "Eq.trans",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp [eq_true (r.refl 0)] at hx",
          "proofState": 28,
          "pos": {
            "line": 75,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nhx : \u00ac(r 0 0 \u2194 0 = 0)\n\u22a2 False",
          "endPos": {
            "line": 75,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have r_zero_x : r 0 x := by tauto",
          "proofState": 29,
          "pos": {
            "line": 76,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 76,
            "column": 39
          }
        },
        {
          "usedConstants": [],
          "tactic": "tauto",
          "proofState": 30,
          "pos": {
            "line": 76,
            "column": 34
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\n\u22a2 r 0 x",
          "endPos": {
            "line": 76,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Exists",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have : \u2203 i j, x i j \u2260 0 := by simpa using x_ne_zero \u2218 Matrix.ext",
          "proofState": 31,
          "pos": {
            "line": 77,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 77,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "id",
            "Ne",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "OfNat.ofNat",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "simpa using x_ne_zero \u2218 Matrix.ext",
          "proofState": 32,
          "pos": {
            "line": 77,
            "column": 36
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\n\u22a2 \u2203 i j, x i j \u2260 0",
          "endPos": {
            "line": 77,
            "column": 70
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8i, j, hij\u27e9 := this",
          "proofState": 33,
          "pos": {
            "line": 78,
            "column": 6
          },
          "goals": "case inr.h.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\nthis : \u2203 i j, x i j \u2260 0\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 78,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "Finset",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "Membership.mem",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Finset.instMembership",
            "Matrix.stdBasisMatrix",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "have (k : \u03b9) (_ : k \u2208 Finset.univ) : r 0 ((stdBasisMatrix k i 1) * x * (stdBasisMatrix j k 1)) := by\n  simpa using r.mul (r.mul (r.refl (stdBasisMatrix k i 1)) r_zero_x) (r.refl (stdBasisMatrix j k 1))",
          "proofState": 34,
          "pos": {
            "line": 79,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 82,
            "column": 96
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using r.mul (r.mul (r.refl (stdBasisMatrix k i 1)) r_zero_x) (r.refl (stdBasisMatrix j k 1))",
          "proofState": 35,
          "pos": {
            "line": 81,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nk : \u03b9\nx\u271d : k \u2208 Finset.univ\n\u22a2 r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)",
          "endPos": {
            "line": 82,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "RingCon.sum",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Matrix.addCommMonoid",
            "Matrix.stdBasisMatrix",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "AddCommSemigroup.toAddCommMagma",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "AddCommMonoid.toAddCommSemigroup",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "instHMul"
          ],
          "tactic": "have r_zero_sum := RingCon.sum this",
          "proofState": 36,
          "pos": {
            "line": 83,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 83,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Matrix.scalar",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "Ring.toNonAssocRing",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "Matrix.addCommMonoid",
            "Matrix.stdBasisMatrix",
            "Field.toSemifield",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Matrix.nonAssocSemiring",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "have sum_eq_scalar : \u2211 k, (stdBasisMatrix k i 1) * x * (stdBasisMatrix j k 1) = scalar \u03b9 (x i j) :=\n  by\n  ext i' j'\n  simp [diagonal, sum_apply, mul_apply, stdBasisMatrix, ite_and, eq_comm]",
          "proofState": 37,
          "pos": {
            "line": 84,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 87,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Matrix.ext"
          ],
          "tactic": "ext i' j'",
          "proofState": 38,
          "pos": {
            "line": 86,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\n\u22a2 \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)",
          "endPos": {
            "line": 86,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Finset.univ",
            "congrArg",
            "Matrix.instMulOfFintypeOfAddCommMonoid",
            "Matrix",
            "Finset",
            "MulZeroClass.zero_mul",
            "Matrix.sum_apply",
            "Matrix.of",
            "AddMonoid.toAddZeroClass",
            "Finset.sum_ite_irrel",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Membership.mem",
            "Field.toDivisionRing",
            "mul_ite",
            "Equiv",
            "DivisionRing.toRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "Matrix.addCommMonoid",
            "Finset.instMembership",
            "ite_cond_eq_true",
            "Matrix.stdBasisMatrix",
            "Field.toSemifield",
            "Finset.sum_const_zero",
            "MulZeroClass.mul_zero",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "funext",
            "And",
            "Semifield.toDivisionSemiring",
            "Distrib.toMul",
            "ite_mul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "AddCommMonoid.toAddMonoid",
            "instDecidableAnd",
            "Mathlib.Data.Fintype.Basic._auxLemma.1",
            "EuclideanDomain.toCommRing",
            "mul_one",
            "ite_and",
            "ite_congr",
            "Finset.decidableMem",
            "OfNat.ofNat",
            "_auxLemma.2",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Not",
            "Finset.sum_congr",
            "Finset.sum",
            "Finset.sum_ite_eq",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "ite"
          ],
          "tactic": "simp [diagonal, sum_apply, mul_apply, stdBasisMatrix, ite_and, eq_comm]",
          "proofState": 39,
          "pos": {
            "line": 87,
            "column": 8
          },
          "goals": "case a\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\ni' j' : \u03b9\n\u22a2 (\u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1) i' j' = (scalar \u03b9) (x i j) i' j'",
          "endPos": {
            "line": 87,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "AddMonoidWithOne.toOne",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Matrix.one",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have r_zero_one : r 0 1 := by\n  simpa [hij, Finset.sum_const_zero, sum_eq_scalar] using r.mul r_zero_sum (r.refl (scalar \u03b9 (x i j)\u207b\u00b9))",
          "proofState": 40,
          "pos": {
            "line": 88,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 90,
            "column": 56
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa [hij, Finset.sum_const_zero, sum_eq_scalar] using r.mul r_zero_sum (r.refl (scalar \u03b9 (x i j)\u207b\u00b9))",
          "proofState": 41,
          "pos": {
            "line": 89,
            "column": 8
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\n\u22a2 r 0 1",
          "endPos": {
            "line": 90,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "EuclideanDomain.toCommRing",
            "Top.top",
            "OfNat.ofNat",
            "Eq",
            "Matrix.zero",
            "DFunLike.coe",
            "letFun",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "have forall_r_zero a : r 0 a := by simpa using r.mul r_zero_one (r.refl a)",
          "proofState": 42,
          "pos": {
            "line": 91,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 91,
            "column": 80
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using r.mul r_zero_one (r.refl a)",
          "proofState": 43,
          "pos": {
            "line": 91,
            "column": 41
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\na : Matrix \u03b9 \u03b9 K\n\u22a2 r 0 a",
          "endPos": {
            "line": 91,
            "column": 80
          }
        },
        {
          "usedConstants": [
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "Matrix",
            "Matrix.instRing",
            "RingCon.instCompleteLattice",
            "RingCon.instLE",
            "RingCon",
            "Field.toDivisionRing",
            "CompleteLattice.toBoundedOrder",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "OrderTop.toTop",
            "Distrib.toMul",
            "BoundedOrder.toOrderTop",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Top.top",
            "Eq",
            "DFunLike.coe",
            "letFun"
          ],
          "tactic": "have forall_forall_r a b : r a b := by simpa using r.add (forall_r_zero (b - a)) (r.refl a)",
          "proofState": 44,
          "pos": {
            "line": 92,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 92,
            "column": 97
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using r.add (forall_r_zero (b - a)) (r.refl a)",
          "proofState": 45,
          "pos": {
            "line": 92,
            "column": 45
          },
          "goals": "K : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\na b : Matrix \u03b9 \u03b9 K\n\u22a2 r a b",
          "endPos": {
            "line": 92,
            "column": 97
          }
        },
        {
          "usedConstants": [
            "RingCon.ext"
          ],
          "tactic": "apply RingCon.ext",
          "proofState": 46,
          "pos": {
            "line": 93,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\nforall_forall_r : \u2200 (a b : Matrix \u03b9 \u03b9 K), r a b\n\u22a2 r = \u22a4",
          "endPos": {
            "line": 93,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Ring.toNonAssocRing",
            "RingCon.instFunLikeForallProp",
            "congrArg",
            "Matrix",
            "Matrix.instRing",
            "RingCon",
            "Field.toDivisionRing",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "iff_self",
            "Iff",
            "Distrib.toMul",
            "True",
            "eq_true",
            "of_eq_true",
            "NonUnitalNonAssocSemiring.toDistrib",
            "implies_true",
            "DFunLike.coe",
            "Eq.trans",
            "forall_congr"
          ],
          "tactic": "simp [forall_forall_r]",
          "proofState": 47,
          "pos": {
            "line": 94,
            "column": 6
          },
          "goals": "case inr.h.intro.intro.intro.H\nK : Type u\ninst\u271d\u00b2 : Field K\n\u03b9 : Type v\nh\u03b9 : Fintype \u03b9\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : DecidableEq \u03b9\nr : RingCon (Matrix \u03b9 \u03b9 K)\nx : Matrix \u03b9 \u03b9 K\nhx : \u00ac(r 0 x \u2194 x = 0)\nx_ne_zero : x \u2260 0\nr_zero_x : r 0 x\ni j : \u03b9\nhij : x i j \u2260 0\nthis : \u2200 k \u2208 Finset.univ, r 0 (stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1)\nr_zero_sum : r (\u2211 i : \u03b9, 0) (\u2211 i_1 : \u03b9, stdBasisMatrix i_1 i 1 * x * stdBasisMatrix j i_1 1)\nsum_eq_scalar : \u2211 k : \u03b9, stdBasisMatrix k i 1 * x * stdBasisMatrix j k 1 = (scalar \u03b9) (x i j)\nr_zero_one : r 0 1\nforall_r_zero : \u2200 (a : Matrix \u03b9 \u03b9 K), r 0 a\nforall_forall_r : \u2200 (a b : Matrix \u03b9 \u03b9 K), r a b\n\u22a2 \u2200 (x y : Matrix \u03b9 \u03b9 K), r x y \u2194 \u22a4 x y",
          "endPos": {
            "line": 94,
            "column": 28
          }
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/HaarMeasure/MeasurableSpacePadics.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [],
          "tactic": "simpa only [Metric.closedBall, dist_zero_right] using isCompact_closedBall (0 : \u211a_[p]) 1",
          "proofState": 1,
          "pos": {
            "line": 29,
            "column": 19
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 IsCompact {y | \u2016y\u2016 \u2264 1}",
          "endPos": {
            "line": 30,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "SeminormedAddGroup.toAddGroup",
            "congrArg",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "Eq.mp",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "TopologicalSpace.Compacts.carrier",
            "TopologicalSpace.Compacts.mk",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "funext",
            "Padic.instZero",
            "Set.Nonempty",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "interior",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "ProperSpace.isCompact_closedBall",
            "NormedField.toNormedCommRing",
            "IsOpen.interior_eq",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "dist_zero_right",
            "UniformSpace.toTopologicalSpace",
            "NegZeroClass.toZero",
            "Eq",
            "Padic.instProperSpace",
            "IsCompact",
            "Set"
          ],
          "tactic": "rw [IsOpen.interior_eq]",
          "proofState": 2,
          "pos": {
            "line": 32,
            "column": 4
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 (interior { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier).Nonempty",
          "endPos": {
            "line": 32,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "SeminormedAddGroup.toAddGroup",
            "Real.instZero",
            "Real.orderedSemiring",
            "congrArg",
            "norm_zero",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "Membership.mem",
            "OrderedSemiring.zeroLEOneClass",
            "Eq.mp",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "TopologicalSpace.Compacts.carrier",
            "TopologicalSpace.Compacts.mk",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "funext",
            "Padic.instZero",
            "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.1",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "True",
            "Exists.intro",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "ProperSpace.isCompact_closedBall",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "dist_zero_right",
            "UniformSpace.toTopologicalSpace",
            "NegZeroClass.toZero",
            "Set.instMembership",
            "Padic.instProperSpace",
            "Eq.trans",
            "IsCompact",
            "Set"
          ],
          "tactic": "exact \u27e80, by simp\u27e9",
          "proofState": 3,
          "pos": {
            "line": 33,
            "column": 6
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier.Nonempty",
          "endPos": {
            "line": 33,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "SeminormedAddGroup.toAddGroup",
            "Real.instZero",
            "Real.orderedSemiring",
            "congrArg",
            "norm_zero",
            "OrderedSemiring.zeroLEOneClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.1",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "True",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 4,
          "pos": {
            "line": 33,
            "column": 19
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 0 \u2208 { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier",
          "endPos": {
            "line": 33,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "id",
            "IsOpen"
          ],
          "tactic": "simpa only [Metric.closedBall, dist_zero_right] using IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero",
          "proofState": 5,
          "pos": {
            "line": 34,
            "column": 6
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 IsOpen { carrier := {y | \u2016y\u2016 \u2264 1}, isCompact' := \u22ef }.carrier",
          "endPos": {
            "line": 35,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "PseudoMetricSpace.toUniformSpace",
            "Subtype",
            "LE.le",
            "Real.instOne",
            "Padic.normedField",
            "Topology.IsOpenEmbedding.measurableEmbedding",
            "Padic.instBorelSpace",
            "SeminormedCommRing.toSeminormedRing",
            "MeasurableEmbedding",
            "Padic",
            "One.toOfNat1",
            "Subtype.instMeasurableSpace",
            "instTopologicalSpaceSubtype",
            "Padic.instMeasurableSpace",
            "SeminormedRing.toPseudoMetricSpace",
            "PadicInt.isOpenEmbedding_coe",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "Subtype.val",
            "UniformSpace.toTopologicalSpace"
          ],
          "tactic": "convert isOpenEmbedding_coe.measurableEmbedding",
          "proofState": 6,
          "pos": {
            "line": 53,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 MeasurableEmbedding Subtype.val",
          "endPos": {
            "line": 53,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toSeminormedCommRing",
            "PadicInt",
            "inferInstanceAs",
            "PseudoMetricSpace.toUniformSpace",
            "BorelSpace",
            "PadicInt.instMeasurableSpace",
            "PadicInt.instNormedCommRing",
            "SeminormedCommRing.toSeminormedRing",
            "PadicInt.instBorelSpace",
            "SeminormedRing.toPseudoMetricSpace",
            "UniformSpace.toTopologicalSpace"
          ],
          "tactic": "exact inferInstanceAs (BorelSpace \u2124_[p])",
          "proofState": 7,
          "pos": {
            "line": 54,
            "column": 2
          },
          "goals": "case convert_3\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 BorelSpace { x // \u2016x\u2016 \u2264 1 }",
          "endPos": {
            "line": 54,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure",
            "Preorder.toLT",
            "PadicInt",
            "CompleteLattice.instOmegaCompletePartialOrder",
            "Mathlib.Data.ENNReal.Basic._auxLemma.40",
            "congrArg",
            "CompletelyDistribLattice.toCompleteLattice",
            "Set.univ",
            "MeasureTheory.MeasureSpace.toMeasurableSpace",
            "PartialOrder.toPreorder",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "PadicInt.instMeasureSpace",
            "instENNRealTop",
            "AddMonoidWithOne.toOne",
            "MeasureTheory.MeasureSpace.volume",
            "PadicInt.volume_univ",
            "LT.lt",
            "True",
            "OmegaCompletePartialOrder.toPartialOrder",
            "ENNReal",
            "of_eq_true",
            "One.toOfNat1",
            "instENNRealAddCommMonoidWithOne",
            "ENNReal.instCompleteLinearOrder",
            "CompleteLinearOrder.toCompletelyDistribLattice",
            "Top.top",
            "OfNat.ofNat",
            "DFunLike.coe",
            "Eq.trans",
            "MeasureTheory.Measure.instFunLike",
            "Set"
          ],
          "tactic": "simp\n  -- https://github.com/ImperialCollegeLondon/FLT/issues/278",
          "proofState": 8,
          "pos": {
            "line": 64,
            "column": 28
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 volume Set.univ < \u22a4",
          "endPos": {
            "line": 64,
            "column": 32
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 67,
            "column": 87
          },
          "goal": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\ns : Set \u2124_[p]\n\u22a2 volume (Subtype.val '' s) = volume s",
          "endPos": {
            "line": 67,
            "column": 92
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 67,
            "column": 14
          },
          "endPos": {
            "line": 67,
            "column": 24
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/GlobalLanglandsConjectures/GLnDefs.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "DedekindDomain.FiniteAdeleRing.mul_nonZeroDivisor_mem_finiteIntegralAdeles"
          ],
          "tactic": "exact mul_nonZeroDivisor_mem_finiteIntegralAdeles a",
          "proofState": 4,
          "pos": {
            "line": 86,
            "column": 2
          },
          "goals": "R : Type u_1\nK : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\na : FiniteAdeleRing R K\n\u22a2 \u2203 b c, a * \u2191\u2191b = \u2191c",
          "endPos": {
            "line": 86,
            "column": 53
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction x using TensorProduct.induction_on generalizing y",
          "proofState": 5,
          "pos": {
            "line": 118,
            "column": 4
          },
          "goals": "S : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx y : A \u2297[R] L\n\u22a2 \u2045x, a \u2022 y\u2046 = a \u2022 \u2045x, y\u2046",
          "endPos": {
            "line": 118,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "smul_zero",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "congr",
            "True",
            "eq_self",
            "zero_lie",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "NegZeroClass.toZero",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 6,
          "pos": {
            "line": 119,
            "column": 6
          },
          "goals": "case zero\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\ny : A \u2297[R] L\n\u22a2 \u20450, a \u2022 y\u2046 = a \u2022 \u20450, y\u2046",
          "endPos": {
            "line": 119,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction y using TensorProduct.induction_on",
          "proofState": 7,
          "pos": {
            "line": 120,
            "column": 6
          },
          "goals": "case tmul\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d : A\ny\u271d : L\ny : A \u2297[R] L\n\u22a2 \u2045x\u271d \u2297\u209c[R] y\u271d, a \u2022 y\u2046 = a \u2022 \u2045x\u271d \u2297\u209c[R] y\u271d, y\u2046",
          "endPos": {
            "line": 120,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "smul_zero",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "congr",
            "True",
            "eq_self",
            "lie_zero",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "TensorProduct.tmul",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "NegZeroClass.toZero",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 8,
          "pos": {
            "line": 121,
            "column": 8
          },
          "goals": "case tmul.zero\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d : A\ny\u271d : L\n\u22a2 \u2045x\u271d \u2297\u209c[R] y\u271d, a \u2022 0\u2046 = a \u2022 \u2045x\u271d \u2297\u209c[R] y\u271d, 0\u2046",
          "endPos": {
            "line": 121,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Algebra.mul_smul_comm",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "Algebra.toSMul",
            "DistribSMul.toSMulZeroClass",
            "LieRingModule.toBracket",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp [TensorProduct.smul_tmul']",
          "proofState": 9,
          "pos": {
            "line": 122,
            "column": 8
          },
          "goals": "case tmul.tmul\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d : A\ny\u271d : L\n\u22a2 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 x\u271d \u2297\u209c[R] y\u271d\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d \u2297\u209c[R] y\u271d\u2046",
          "endPos": {
            "line": 122,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "DistribSMul.toSMulZeroClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "TensorProduct.leftDistribMulAction",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "TensorProduct.addZeroClass",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "AddCommSemigroup.toAddCommMagma",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "AddCommMonoid.toAddCommSemigroup",
            "AddZeroClass.toAdd",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "smul_add",
            "MonoidWithZero.toMonoid",
            "lie_add",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 10,
          "pos": {
            "line": 123,
            "column": 8
          },
          "goals": "case tmul.add\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 x\u271d\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d\u2046\na\u271d : \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 y\u271d\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, y\u271d\u2046\n\u22a2 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, a \u2022 (x\u271d + y\u271d)\u2046 = a \u2022 \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d + y\u271d\u2046",
          "endPos": {
            "line": 123,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addMonoid",
            "Bracket.bracket",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "DistribSMul.toSMulZeroClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "TensorProduct.leftDistribMulAction",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "TensorProduct.addZeroClass",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "AddCommSemigroup.toAddCommMagma",
            "CommRing.toRing",
            "AddCommMonoid.toAddCommSemigroup",
            "AddZeroClass.toAdd",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "smul_add",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "AddCommMagma.toAdd",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero",
            "add_lie"
          ],
          "tactic": "simp_all [add_lie]",
          "proofState": 11,
          "pos": {
            "line": 124,
            "column": 6
          },
          "goals": "case add\nS : Type u_1\nR : Type u_2\nA : Type u_3\nL : Type u_4\ninst\u271d\u2077 : CommRing S\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : Algebra S A\ninst\u271d : SMulCommClass R S A\na : S\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : \u2200 (y : A \u2297[R] L), \u2045x\u271d, a \u2022 y\u2046 = a \u2022 \u2045x\u271d, y\u2046\na\u271d : \u2200 (y : A \u2297[R] L), \u2045y\u271d, a \u2022 y\u2046 = a \u2022 \u2045y\u271d, y\u2046\ny : A \u2297[R] L\n\u22a2 \u2045x\u271d + y\u271d, a \u2022 y\u2046 = a \u2022 \u2045x\u271d + y\u271d, y\u2046",
          "endPos": {
            "line": 124,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Bracket.ext"
          ],
          "tactic": "ext x y",
          "proofState": 12,
          "pos": {
            "line": 131,
            "column": 2
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\n\u22a2 LieAlgebra.ExtendScalars.instBracketTensorProduct R A B B = Ring.instBracket",
          "endPos": {
            "line": 131,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.bracketBilin_apply_apply",
            "Algebra.to_smulCommClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "Ring.instBracket",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Eq.rec",
            "Algebra.toModule",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap.module",
            "LinearMap",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieAlgebra.ExtendScalars.instBracketTensorProduct",
            "MulActionWithZero.toSMulWithZero",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "Algebra.TensorProduct.instNonUnitalNonAssocRing",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "conv_lhs => rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 13,
          "pos": {
            "line": 132,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 \u2045x, y\u2046 = \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DedekindDomain.bracketBilin_apply_apply",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LieRingModule.toBracket",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 14,
          "pos": {
            "line": 132,
            "column": 14
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n| \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DedekindDomain.bracketBilin_apply_apply",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LieRingModule.toBracket",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 15,
          "pos": {
            "line": 132,
            "column": 14
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n| \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DedekindDomain.bracketBilin_apply_apply",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LieRingModule.toBracket",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ _]",
          "proofState": 16,
          "pos": {
            "line": 132,
            "column": 14
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n| \u2045x, y\u2046",
          "endPos": {
            "line": 132,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.bracketBilin_apply_apply",
            "Algebra.to_smulCommClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "Ring.instBracket",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.toModule",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap.module",
            "LinearMap",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "Algebra.TensorProduct.instRing",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "Algebra.TensorProduct.instNonUnitalNonAssocRing",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "MulZeroClass.toZero",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 @bracketBilin_apply_apply R _ _ _ (_) (.ofAssociativeAlgebra) _ _ (_) (_) x y]",
          "proofState": 17,
          "pos": {
            "line": 133,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = \u2045x, y\u2046",
          "endPos": {
            "line": 133,
            "column": 86
          }
        },
        {
          "usedConstants": [],
          "tactic": "rotate_left",
          "proofState": 18,
          "pos": {
            "line": 134,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 LieModule R (A \u2297[R] B) (A \u2297[R] B)",
          "endPos": {
            "line": 134,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "lieAlgebraSelfModule",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "CommRing.toRing",
            "Ring.toSemiring",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "exact @lieAlgebraSelfModule ..",
          "proofState": 19,
          "pos": {
            "line": 135,
            "column": 2
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 LieModule R (A \u2297[R] B) (A \u2297[R] B)\ncase bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y",
          "endPos": {
            "line": 135,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.toModule",
            "LieAlgebra.ExtendScalars.instLieRing",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "LinearMap.congr_fun\u2082",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "AddZeroClass.toZero",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "TensorProduct.instModule",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "refine LinearMap.congr_fun\u2082 ?_ x y",
          "proofState": 20,
          "pos": {
            "line": 136,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y = ((bracketBilin R (A \u2297[R] B) (A \u2297[R] B)) x) y",
          "endPos": {
            "line": 136,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "TensorProduct.AlgebraTensorModule.curry_injective"
          ],
          "tactic": "ext xa xb ya yb",
          "proofState": 21,
          "pos": {
            "line": 137,
            "column": 2
          },
          "goals": "case bracket.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\n\u22a2 bracketBilin R (A \u2297[R] B) (A \u2297[R] B) = bracketBilin R (A \u2297[R] B) (A \u2297[R] B)",
          "endPos": {
            "line": 137,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "LinearMap.instFunLike",
            "id",
            "LinearMap",
            "Eq",
            "DFunLike.coe"
          ],
          "tactic": "change @Bracket.bracket _ _ _ (xa \u2297\u209c[R] xb) (ya \u2297\u209c[R] yb) = _",
          "proofState": 22,
          "pos": {
            "line": 138,
            "column": 2
          },
          "goals": "case bracket.h.h.a.h.h.a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\nxa : A\nxb : B\nya : A\nyb : B\n\u22a2 ((TensorProduct.AlgebraTensorModule.curry\n          (((TensorProduct.AlgebraTensorModule.curry (bracketBilin R (A \u2297[R] B) (A \u2297[R] B))) xa) xb))\n        ya)\n      yb =\n    ((TensorProduct.AlgebraTensorModule.curry\n          (((TensorProduct.AlgebraTensorModule.curry (bracketBilin R (A \u2297[R] B) (A \u2297[R] B))) xa) xb))\n        ya)\n      yb",
          "endPos": {
            "line": 138,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.toSMul",
            "Algebra.toModule",
            "Algebra.id",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "LinearMap.module",
            "LinearMap",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "IsScalarTower.left",
            "smulCommClass_self",
            "DedekindDomain.bracketBilin",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "LinearMap.instIsScalarTower",
            "IsScalarTower.to_smulCommClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Module.toDistribMulAction",
            "Algebra.TensorProduct.instRing",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieAlgebra.ExtendScalars.instBracketTensorProduct",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "TensorProduct.AlgebraTensorModule.curry",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "TensorProduct.isScalarTower",
            "MonoidWithZero.toMonoid",
            "TensorProduct.instModule.proof_1",
            "TensorProduct.instModule",
            "TensorProduct.smulCommClass_left",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "dsimp [Ring.lie_def]",
          "proofState": 23,
          "pos": {
            "line": 139,
            "column": 2
          },
          "goals": "case bracket.h.h.a.h.h.a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\nxa : A\nxb : B\nya : A\nyb : B\n\u22a2 \u2045xa \u2297\u209c[R] xb, ya \u2297\u209c[R] yb\u2046 =\n    ((TensorProduct.AlgebraTensorModule.curry\n          (((TensorProduct.AlgebraTensorModule.curry (bracketBilin R (A \u2297[R] B) (A \u2297[R] B))) xa) xb))\n        ya)\n      yb",
          "endPos": {
            "line": 139,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.tmul_sub",
            "NonUnitalNonAssocRing.toAddCommGroup",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Eq",
            "LieAlgebra.ofAssociativeAlgebra",
            "instHMul"
          ],
          "tactic": "rw [TensorProduct.tmul_sub, mul_comm]",
          "proofState": 24,
          "pos": {
            "line": 140,
            "column": 2
          },
          "goals": "case bracket.h.h.a.h.h.a.h.h\nR : Type u_1\nA : Type u_2\nB : Type u_5\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\nx y : A \u2297[R] B\nxa : A\nxb : B\nya : A\nyb : B\n\u22a2 (xa * ya) \u2297\u209c[R] (xb * yb - yb * xb) = (xa * ya) \u2297\u209c[R] (xb * yb) - (ya * xa) \u2297\u209c[R] (yb * xb)",
          "endPos": {
            "line": 140,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.id",
            "id",
            "LinearMap.toAddHom",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "AddZeroClass.toZero",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "LieAlgebra.ofAssociativeAlgebra",
            "AddHom.toFun",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]",
          "proofState": 25,
          "pos": {
            "line": 189,
            "column": 8
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\n\u22a2 \u2200 {x : A \u2297[R] L} {m : A \u2297[R] M}, __spread\u271d\u207b\u2070.toFun \u2045x, m\u2046 = \u2045x, __spread\u271d\u207b\u2070.toFun m\u2046",
          "endPos": {
            "line": 189,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "intro x m",
          "proofState": 26,
          "pos": {
            "line": 190,
            "column": 8
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\n\u22a2 \u2200 {x : A \u2297[R] L} {m : A \u2297[R] M}, (LinearMap.baseChange A \u2191f) \u2045x, m\u2046 = \u2045x, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 190,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction x using TensorProduct.induction_on",
          "proofState": 27,
          "pos": {
            "line": 191,
            "column": 8
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx : A \u2297[R] L\nm : A \u2297[R] M\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x, m\u2046 = \u2045x, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 191,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "RingHom",
            "map_zero",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "zero_lie",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddMonoidHomClass.toZeroHomClass",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [zero_lie, map_zero]",
          "proofState": 28,
          "pos": {
            "line": 192,
            "column": 10
          },
          "goals": "case zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nm : A \u2297[R] M\n\u22a2 (LinearMap.baseChange A \u2191f) \u20450, m\u2046 = \u20450, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 192,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction m using TensorProduct.induction_on",
          "proofState": 29,
          "pos": {
            "line": 193,
            "column": 10
          },
          "goals": "case tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nm : A \u2297[R] M\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, m\u2046 = \u2045x\u271d \u2297\u209c[R] y\u271d, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 193,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "RingHom",
            "map_zero",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "lie_zero",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "AddMonoidHomClass.toZeroHomClass",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 30,
          "pos": {
            "line": 193,
            "column": 59
          },
          "goals": "case tmul.zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, 0\u2046 = \u2045x\u271d \u2297\u209c[R] y\u271d, (LinearMap.baseChange A \u2191f) 0\u2046",
          "endPos": {
            "line": 193,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LieModuleHom",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "Algebra.toModule",
            "LieRingModule.toBracket",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "TensorProduct.tmul",
            "LieModuleHom.map_lie",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieModuleHom.instFunLike",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp_all",
          "proofState": 31,
          "pos": {
            "line": 193,
            "column": 59
          },
          "goals": "case tmul.tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d : A\ny\u271d : M\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d \u2297\u209c[R] y\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d)\u2046",
          "endPos": {
            "line": 193,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "map_add",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "TensorProduct.tmul",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "lie_add",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 32,
          "pos": {
            "line": 193,
            "column": 59
          },
          "goals": "case tmul.add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d y\u271d : A \u2297[R] M\na\u271d\u00b9 : (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) x\u271d\u2046\na\u271d : (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, y\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) y\u271d\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d + y\u271d\u2046 = \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, (LinearMap.baseChange A \u2191f) (x\u271d + y\u271d)\u2046",
          "endPos": {
            "line": 193,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "TensorProduct.addCommGroup",
            "Algebra.id",
            "LieModuleHom.toLinearMap",
            "map_add",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero",
            "add_lie"
          ],
          "tactic": "simp_all only [add_lie, map_add]",
          "proofState": 33,
          "pos": {
            "line": 194,
            "column": 10
          },
          "goals": "case add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : Group G\nE : Type\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : ChartedSpace E G\ninst\u271d\u00b9\u00b3 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : CommRing A\ninst\u271d\u00b9\u2070 : Algebra R A\ninst\u271d\u2079 : LieRing L\ninst\u271d\u2078 : LieAlgebra R L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : LieRingModule L M\ninst\u271d\u2074 : LieModule R L M\ninst\u271d\u00b3 : AddCommGroup N\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : LieRingModule L N\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nm : A \u2297[R] M\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : (LinearMap.baseChange A \u2191f) \u2045x\u271d, m\u2046 = \u2045x\u271d, (LinearMap.baseChange A \u2191f) m\u2046\na\u271d : (LinearMap.baseChange A \u2191f) \u2045y\u271d, m\u2046 = \u2045y\u271d, (LinearMap.baseChange A \u2191f) m\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d + y\u271d, m\u2046 = \u2045x\u271d + y\u271d, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 194,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "Algebra.toSMul",
            "Algebra.id",
            "id",
            "LinearMap.toAddHom",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "AddCommSemigroup.toAddCommMagma",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "AddHom.toFun",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom]",
          "proofState": 34,
          "pos": {
            "line": 204,
            "column": 4
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\n\u22a2 \u2200 {x y : A \u2297[R] L}, __spread\u271d\u207b\u2070.toFun \u2045x, y\u2046 = \u2045__spread\u271d\u207b\u2070.toFun x, __spread\u271d\u207b\u2070.toFun y\u2046",
          "endPos": {
            "line": 204,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "intro x m",
          "proofState": 35,
          "pos": {
            "line": 205,
            "column": 4
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\n\u22a2 \u2200 {x y : A \u2297[R] L},\n    (LinearMap.baseChange A \u2191f) \u2045x, y\u2046 = \u2045(LinearMap.baseChange A \u2191f) x, (LinearMap.baseChange A \u2191f) y\u2046",
          "endPos": {
            "line": 205,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction x using TensorProduct.induction_on",
          "proofState": 36,
          "pos": {
            "line": 206,
            "column": 4
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx m : A \u2297[R] L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) x, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 206,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "RingHom",
            "Algebra.toSMul",
            "map_zero",
            "Algebra.id",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "congr",
            "True",
            "eq_self",
            "zero_lie",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "AddCommMonoid.toAddMonoid",
            "AddMonoidHomClass.toZeroHomClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "LieHom.toLinearMap",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [zero_lie, map_zero]",
          "proofState": 37,
          "pos": {
            "line": 207,
            "column": 6
          },
          "goals": "case zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nm : A \u2297[R] L\n\u22a2 (LinearMap.baseChange A \u2191f) \u20450, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) 0, (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 207,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "AddCommGroup.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra"
          ],
          "tactic": "induction m using TensorProduct.induction_on",
          "proofState": 38,
          "pos": {
            "line": 208,
            "column": 6
          },
          "goals": "case tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nm : A \u2297[R] L\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, m\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d), (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 208,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SemilinearMapClass.distribMulActionSemiHomClass",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "TensorProduct.addCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "RingHom",
            "Algebra.toSMul",
            "map_zero",
            "Algebra.toModule",
            "Algebra.id",
            "LinearMap.semilinearMapClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "TensorProduct.zero",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "True",
            "eq_self",
            "lie_zero",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Module.toDistribMulAction",
            "AddCommMonoid.toAddMonoid",
            "TensorProduct.tmul",
            "LieHom.instFunLike",
            "AddMonoidHomClass.toZeroHomClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "LieHom.toLinearMap",
            "RingHom.id",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "MonoidWithZero.toMonoid",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "DistribMulActionSemiHomClass.toAddMonoidHomClass",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_all",
          "proofState": 39,
          "pos": {
            "line": 208,
            "column": 55
          },
          "goals": "case tmul.zero\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d \u2297\u209c[R] y\u271d, 0\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d), (LinearMap.baseChange A \u2191f) 0\u2046",
          "endPos": {
            "line": 208,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "LieHom.map_lie",
            "Algebra.toModule",
            "LieRingModule.toBracket",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "TensorProduct.tmul",
            "LieHom.instFunLike",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp_all",
          "proofState": 40,
          "pos": {
            "line": 208,
            "column": 55
          },
          "goals": "case tmul.tmul\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d : A\ny\u271d : L\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d \u2297\u209c[R] y\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) (x\u271d \u2297\u209c[R] y\u271d)\u2046",
          "endPos": {
            "line": 208,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "Algebra.toSMul",
            "Algebra.toModule",
            "Algebra.id",
            "map_add",
            "id",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "AddCommSemigroup.toAddCommMagma",
            "TensorProduct.tmul",
            "LieHom.instFunLike",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieHom.toLinearMap",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "lie_add",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd"
          ],
          "tactic": "simp_all",
          "proofState": 41,
          "pos": {
            "line": 208,
            "column": 55
          },
          "goals": "case tmul.add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nx\u271d\u00b9 : A\ny\u271d\u00b9 : L\nx\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 :\n  (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) x\u271d\u2046\na\u271d :\n  (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, y\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) y\u271d\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9, x\u271d + y\u271d\u2046 =\n    \u2045(LinearMap.baseChange A \u2191f) (x\u271d\u00b9 \u2297\u209c[R] y\u271d\u00b9), (LinearMap.baseChange A \u2191f) (x\u271d + y\u271d)\u2046",
          "endPos": {
            "line": 208,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearMap.baseChange",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Bracket.bracket",
            "LinearMap.instFunLike",
            "lieAlgebraSelfModule",
            "TensorProduct.addCommGroup",
            "Algebra.toSMul",
            "Algebra.id",
            "map_add",
            "LinearMap.semilinearMapClass",
            "LieRingModule.toBracket",
            "LieAlgebra.ExtendScalars.instLieRing",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instLieAlgebra'",
            "congr",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "AddCommSemigroup.toAddCommMagma",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "LieHom.toLinearMap",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "lieRingSelfModule",
            "LieAlgebra.ofAssociativeAlgebra",
            "LieAlgebra.ExtendScalars.instLieRingModule",
            "Eq.trans",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "add_lie"
          ],
          "tactic": "simp_all only [add_lie, map_add]",
          "proofState": 42,
          "pos": {
            "line": 209,
            "column": 6
          },
          "goals": "case add\nn : \u2115\nG : Type\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\nE : Type\ninst\u271d\u00b9\u2070 : NormedAddCommGroup E\ninst\u271d\u2079 : NormedSpace \u211d E\ninst\u271d\u2078 : ChartedSpace E G\ninst\u271d\u2077 : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nA : Type u_1\nR : Type u_2\nL : Type u_3\nL' : Type u_4\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\nf : L \u2192\u2097\u2045R\u2046 L'\nm x\u271d y\u271d : A \u2297[R] L\na\u271d\u00b9 : (LinearMap.baseChange A \u2191f) \u2045x\u271d, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) x\u271d, (LinearMap.baseChange A \u2191f) m\u2046\na\u271d : (LinearMap.baseChange A \u2191f) \u2045y\u271d, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) y\u271d, (LinearMap.baseChange A \u2191f) m\u2046\n\u22a2 (LinearMap.baseChange A \u2191f) \u2045x\u271d + y\u271d, m\u2046 = \u2045(LinearMap.baseChange A \u2191f) (x\u271d + y\u271d), (LinearMap.baseChange A \u2191f) m\u2046",
          "endPos": {
            "line": 209,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "instInnerProductSpaceRealComplex",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "IsScalarTower.right",
            "LeftInvariantDerivation.instLieAlgebra",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AlgHom",
            "NormedSpace.toModule",
            "instNormedSpaceLieAddGroup",
            "AddMonoid.toAddZeroClass",
            "Complex.instNormedField",
            "PseudoMetricSpace.toUniformSpace",
            "Module.toMulActionWithZero",
            "Algebra.toSMul",
            "NormedRing.toNonUnitalNormedRing",
            "Real.semiring",
            "Algebra.toModule",
            "Algebra.id",
            "UniversalEnvelopingAlgebra.instAlgebra",
            "DivInvMonoid.toMonoid",
            "UniversalEnvelopingAlgebra",
            "Real.normedAddCommGroup",
            "Module.End.semiring",
            "Complex.instRCLike",
            "Real.instMonoidWithZero",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "Real.commRing",
            "ContMDiffMap.algebra",
            "Real.instAddCommGroup",
            "LinearMap.module",
            "LeftInvariantDerivation.instAddCommGroup",
            "WithTop.some",
            "Algebra.TensorProduct.leftAlgebra",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonUnitalNormedRing.toNormedAddCommGroup",
            "Real.instMonoid",
            "LeftInvariantDerivation.instModule",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "Real.normedCommRing",
            "ContMDiffMap.semiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "CommMonoid.toMonoid",
            "SeminormedAddCommGroup.toAddCommGroup",
            "NormedAlgebra.toNormedSpace",
            "DedekindDomain.instLieAlgebra'",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "ContMDiffMap.addCommMonoid",
            "ENat",
            "instLieGroupOfTopWithTopENat",
            "AddZeroClass.toZero",
            "Algebra.TensorProduct.instSemiring",
            "NormedRing.toSeminormedRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "IsScalarTower.complexToReal",
            "Real.instAddCommMonoid",
            "Monoid.toMulAction",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "NormedAddCommGroup.toAddCommGroup",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "Module.End.ring",
            "SeminormedRing.toPseudoMetricSpace",
            "AutomorphicForm.GLn.actionTensorC",
            "NormedField.toNormedCommRing",
            "Module.End",
            "Complex",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Top.top",
            "instFieldContMDiffRing",
            "ContMDiffMap.module",
            "RCLike.innerProductSpace",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "LieAlgebra.ofAssociativeAlgebra",
            "letFun",
            "LeftInvariantDerivation.instLieRing",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "LieGroup.toContMDiffMul",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Real.instCommMonoid",
            "Semiring.toMonoidWithZero",
            "ContMDiffMap.addCommGroup"
          ],
          "tactic": "have := actionTensorC G E",
          "proofState": 43,
          "pos": {
            "line": 218,
            "column": 2
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n    \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef",
          "endPos": {
            "line": 218,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "revert this",
          "proofState": 44,
          "pos": {
            "line": 218,
            "column": 29
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nthis : \u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef\n\u22a2 UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n    \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef",
          "endPos": {
            "line": 218,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "LieHom",
            "instInnerProductSpaceRealComplex",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "IsScalarTower.right",
            "UniversalEnvelopingAlgebra.lift",
            "LeftInvariantDerivation.instLieAlgebra",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AlgHom",
            "NormedSpace.toModule",
            "instNormedSpaceLieAddGroup",
            "AddMonoid.toAddZeroClass",
            "Complex.instNormedField",
            "PseudoMetricSpace.toUniformSpace",
            "Module.toMulActionWithZero",
            "SeminormedRing.toRing",
            "Algebra.toSMul",
            "NormedRing.toNonUnitalNormedRing",
            "Real.semiring",
            "Algebra.toModule",
            "Algebra.id",
            "Equiv",
            "UniversalEnvelopingAlgebra.instAlgebra",
            "DivInvMonoid.toMonoid",
            "UniversalEnvelopingAlgebra",
            "Real.normedAddCommGroup",
            "Module.End.semiring",
            "Complex.instRCLike",
            "Real.instMonoidWithZero",
            "LieAlgebra.ExtendScalars.instLieRing",
            "MulAction.toSMul",
            "Real.commRing",
            "ContMDiffMap.algebra",
            "Real.instAddCommGroup",
            "LinearMap.module",
            "LeftInvariantDerivation.instAddCommGroup",
            "WithTop.some",
            "Algebra.TensorProduct.leftAlgebra",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonUnitalNormedRing.toNormedAddCommGroup",
            "Real.instMonoid",
            "LeftInvariantDerivation.instModule",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "Real.normedCommRing",
            "ContMDiffMap.semiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "CommMonoid.toMonoid",
            "SeminormedAddCommGroup.toAddCommGroup",
            "NormedAlgebra.toNormedSpace",
            "DedekindDomain.instLieAlgebra'",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "ContMDiffMap.addCommMonoid",
            "ENat",
            "instLieGroupOfTopWithTopENat",
            "AddZeroClass.toZero",
            "Algebra.TensorProduct.instSemiring",
            "NormedRing.toSeminormedRing",
            "LinearMap.addCommMonoid",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "IsScalarTower.complexToReal",
            "Real.instAddCommMonoid",
            "Monoid.toMulAction",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "NormedAddCommGroup.toAddCommGroup",
            "NontriviallyNormedField.toNormedField",
            "Algebra.TensorProduct.instRing",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "Module.End.ring",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Module.End",
            "Complex",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Top.top",
            "instFieldContMDiffRing",
            "ContMDiffMap.module",
            "RCLike.innerProductSpace",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "LeftInvariantDerivation.instLieRing",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "LieGroup.toContMDiffMul",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Real.instCommMonoid",
            "Semiring.toMonoidWithZero",
            "ContMDiffMap.addCommGroup"
          ],
          "tactic": "convert\n  \u21d1(UniversalEnvelopingAlgebra.lift \u2102 (L := \u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) (A :=\n      \u2102 \u2297[\u211d] (Module.End \u211d C^\u221e\u27ee\ud835\udcd8(\u211d, E), G; \u211d\u27ef))) using\n  0",
          "proofState": 45,
          "pos": {
            "line": 219,
            "column": 2
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) \u2192\n    UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n      \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef",
          "endPos": {
            "line": 221,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "_private.Mathlib.Tactic.CongrExclamation.0.implies_congr'"
          ],
          "tactic": "congr!",
          "proofState": 46,
          "pos": {
            "line": 222,
            "column": 2
          },
          "goals": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 ((\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) \u2192\n      UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n        \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) =\n    ((\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G \u2192\u2097\u2045\u2102\u2046 \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) \u2192\n      UniversalEnvelopingAlgebra \u2102 (\u2102 \u2297[\u211d] LeftInvariantDerivation \ud835\udcd8(\u211d, E) G) \u2192\u2090[\u2102]\n        \u2102 \u2297[\u211d] Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef)",
          "endPos": {
            "line": 222,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "id",
            "LieRing",
            "Eq"
          ],
          "tactic": "dsimp [LieAlgebra.ExtendScalars.instLieRing, LieRing.ofAssociativeRing]",
          "proofState": 47,
          "pos": {
            "line": 223,
            "column": 4
          },
          "goals": "case h.h.e'_7\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 LieAlgebra.ExtendScalars.instLieRing \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) = LieRing.ofAssociativeRing",
          "endPos": {
            "line": 223,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "AddMonoid.toAddSemigroup",
            "AddMonoid.toZero",
            "Bracket.bracket",
            "AddCommGroup.toAddGroup",
            "Eq.rec",
            "AddCommGroup",
            "Bracket",
            "instHAdd",
            "LieRing",
            "AddSemigroup.toAdd",
            "LieRing.mk",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Eq.ndrec",
            "Zero.toOfNat0",
            "Eq.refl",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "congr",
          "proofState": 48,
          "pos": {
            "line": 223,
            "column": 77
          },
          "goals": "case h.h.e'_7\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 LieRing.mk \u22ef \u22ef \u22ef \u22ef = LieRing.mk \u22ef \u22ef \u22ef \u22ef",
          "endPos": {
            "line": 223,
            "column": 82
          }
        },
        {
          "usedConstants": [
            "DedekindDomain.diamond_fix"
          ],
          "tactic": "apply diamond_fix",
          "proofState": 49,
          "pos": {
            "line": 224,
            "column": 4
          },
          "goals": "case h.h.e'_7.e_toBracket\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 LieAlgebra.ExtendScalars.instBracketTensorProduct \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef)\n      (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) =\n    Ring.instBracket",
          "endPos": {
            "line": 224,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "id",
            "HEq",
            "LieAlgebra"
          ],
          "tactic": "change HEq ({ .. } : LieAlgebra ..) (@LieAlgebra.mk _ _ _ (_) _ _)",
          "proofState": 50,
          "pos": {
            "line": 225,
            "column": 4
          },
          "goals": "case h.h.e'_8\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\ne_7\u271d : LieAlgebra.ExtendScalars.instLieRing \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) = LieRing.ofAssociativeRing\n\u22a2 HEq (instLieAlgebra' \u2102 \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef)) LieAlgebra.ofAssociativeAlgebra",
          "endPos": {
            "line": 225,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "CommRing",
            "instHSMul",
            "LieAlgebra.mk",
            "LieRing.toAddCommGroup",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "HEq.refl",
            "Bracket.bracket",
            "Eq.casesOn",
            "MulAction.toSMul",
            "LieRing",
            "CommRing.toCommSemiring",
            "HEq.casesOn",
            "eq_of_heq",
            "Eq.ndrec",
            "Eq.refl",
            "HEq",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "AddCommMonoid.toAddMonoid",
            "LieRing.toBracket",
            "LieAlgebra",
            "Module",
            "Eq.symm",
            "Eq",
            "MonoidWithZero.toMonoid",
            "DistribMulAction.toMulAction",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "congr!",
          "proofState": 51,
          "pos": {
            "line": 225,
            "column": 70
          },
          "goals": "case h.h.e'_8\nn : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\ne_7\u271d : LieAlgebra.ExtendScalars.instLieRing \u211d \u2102 (Module.End \u211d C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef) = LieRing.ofAssociativeRing\n\u22a2 HEq (LieAlgebra.mk \u22ef) (LieAlgebra.mk \u22ef)",
          "endPos": {
            "line": 225,
            "column": 76
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Pi.Function.module",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "instHSMul",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Complex.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "Module.toMulActionWithZero",
            "RingHom",
            "Membership.mem",
            "Field.toDivisionRing",
            "AutomorphicForm.GLn.preweight.d",
            "id",
            "Subtype",
            "AutomorphicForm.GLn.preweight.rho",
            "Submonoid.toMulOneClass",
            "DivisionRing.toRing",
            "Complex.instRCLike",
            "Real.commRing",
            "Complex.addCommGroup",
            "Fin.fintype",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "Matrix.mulVec_add",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "AddZeroClass.toZero",
            "Pi.addCommGroup",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "Submonoid.instSetLike",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "AddHom.mk",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Complex.instRing",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RCLike.innerProductSpace",
            "Fin",
            "Matrix.orthogonalGroup",
            "RingHom.id",
            "Matrix.mulVec",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "SetLike.instMembership",
            "Submonoid",
            "MonoidWithZero.toMonoid",
            "Complex.instField",
            "MulZeroClass.toZero",
            "Units.instMulOneClass",
            "AddCommMagma.toAdd",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simpa using Matrix.mulVec_smul ..",
          "proofState": 52,
          "pos": {
            "line": 291,
            "column": 32
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\nA : \u21a5(orthogonalGroup (Fin n) \u211d)\nx\u271d\u00b9 : \u2102\nx\u271d : Fin w.d \u2192 \u2102\n\u22a2 { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef }.toFun (x\u271d\u00b9 \u2022 x\u271d) =\n    (RingHom.id \u2102) x\u271d\u00b9 \u2022 { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef }.toFun x\u271d",
          "endPos": {
            "line": 291,
            "column": 65
          }
        },
        {
          "usedConstants": [],
          "tactic": "aesop",
          "proofState": 53,
          "pos": {
            "line": 292,
            "column": 19
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\n\u22a2 (fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef }) 1 = 1",
          "endPos": {
            "line": 292,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "Pi.Function.module",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "MonoidHom.instMonoidHomClass",
            "Real",
            "instHSMul",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "IsScalarTower.right",
            "Complex.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "AddHom",
            "Matrix",
            "OneHom.mk",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "instLargeCategoryFGModuleCat",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "Module.toMulActionWithZero",
            "NormedDivisionRing.toDivisionRing",
            "RingHom",
            "Membership.mem",
            "MonoidHomClass.toOneHomClass",
            "NormedField.toField",
            "Field.toDivisionRing",
            "CategoryTheory.CategoryStruct.id",
            "Units",
            "Eq.rec",
            "Algebra.id",
            "AutomorphicForm.GLn.preweight.d",
            "id",
            "Subtype",
            "DistribSMul.toSMulZeroClass",
            "Submonoid.toMonoid",
            "AutomorphicForm.GLn.preweight.rho",
            "Submonoid.toMulOneClass",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "FGModuleCat.of",
            "Complex.instRCLike",
            "CategoryTheory.End.monoid",
            "Module.instIsReflexiveOfFiniteOfProjective",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap",
            "FiniteDimensional.finiteDimensional_self",
            "CategoryTheory.End",
            "Complex.addCommGroup",
            "AddCommMonoid",
            "Fin.fintype",
            "FiniteDimensional.finiteDimensional_pi'",
            "Matrix.mulVec_smul",
            "Units.instOne",
            "NonUnitalCommSemiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "map_mul",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Module.Projective.of_free",
            "MonoidWithZero.toMulZeroOneClass",
            "Matrix.mulVec_add",
            "OneHom.toFun",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "NonUnitalCommRing.toNonUnitalCommSemiring",
            "SeminormedAddCommGroup.toAddCommGroup",
            "map_one",
            "Complex.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "AddZeroClass.toZero",
            "Module.instFiniteDimensionalOfIsReflexive",
            "Pi.addCommGroup",
            "MulOneClass.toOne",
            "LinearMap.mk",
            "MonoidHomClass.toMulHomClass",
            "Module.Free.self",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Eq.ndrec",
            "Semiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Eq.refl",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "CategoryTheory.Category.toCategoryStruct",
            "Units.instMul",
            "AddCommMonoid.toAddMonoid",
            "FGModuleCat",
            "AddCommSemigroup.toAddCommMagma",
            "Submonoid.instSetLike",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "AddHom.mk",
            "ModuleCat.ofHom",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "EuclideanDomain.toCommRing",
            "Complex",
            "Module",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Complex.instRing",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RCLike.innerProductSpace",
            "Fin",
            "Matrix.orthogonalGroup",
            "_auxLemma.2",
            "RingHom.id",
            "Matrix.mulVec",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "SetLike.instMembership",
            "Matrix.one_mulVec",
            "Field.toEuclideanDomain",
            "Submonoid",
            "Add",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instField",
            "MulZeroClass.toZero",
            "Units.instMulOneClass",
            "AddCommMagma.toAdd",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp only [obj_carrier, MonCat.mul_of, _root_.map_mul, Units.val_mul, \u2190 Matrix.mulVec_mulVec]",
          "proofState": 54,
          "pos": {
            "line": 294,
            "column": 6
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\nx\u271d\u00b9 x\u271d : \u21a5(orthogonalGroup (Fin n) \u211d)\n\u22a2 { toFun := fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef },\n          map_one' := \u22ef }.toFun\n      (x\u271d\u00b9 * x\u271d) =\n    { toFun := fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef },\n            map_one' := \u22ef }.toFun\n        x\u271d\u00b9 *\n      { toFun := fun A => ModuleCat.ofHom { toFun := fun x => \u2191(w.rho A) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef },\n            map_one' := \u22ef }.toFun\n        x\u271d",
          "endPos": {
            "line": 294,
            "column": 99
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Pi.Function.module",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "MonoidHom.instMonoidHomClass",
            "Real",
            "instHSMul",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "IsScalarTower.right",
            "Complex.commRing",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DistribMulAction.toDistribSMul",
            "AddCommGroup.toAddCommMonoid",
            "AddHom",
            "Matrix",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "instLargeCategoryFGModuleCat",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "Module.toMulActionWithZero",
            "NormedDivisionRing.toDivisionRing",
            "RingHom",
            "Membership.mem",
            "NormedField.toField",
            "Field.toDivisionRing",
            "Units",
            "Eq.rec",
            "Algebra.id",
            "AutomorphicForm.GLn.preweight.d",
            "id",
            "Subtype",
            "DistribSMul.toSMulZeroClass",
            "Submonoid.toMonoid",
            "AutomorphicForm.GLn.preweight.rho",
            "Submonoid.toMulOneClass",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "DivisionRing.toRing",
            "FGModuleCat.of",
            "Complex.instRCLike",
            "Module.instIsReflexiveOfFiniteOfProjective",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "FiniteDimensional.finiteDimensional_self",
            "CategoryTheory.End",
            "Complex.addCommGroup",
            "Fin.fintype",
            "FiniteDimensional.finiteDimensional_pi'",
            "Matrix.mulVec_smul",
            "NonUnitalCommSemiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "map_mul",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Module.Projective.of_free",
            "MonoidWithZero.toMulZeroOneClass",
            "Matrix.mulVec_add",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "NonUnitalCommRing.toNonUnitalCommSemiring",
            "SeminormedAddCommGroup.toAddCommGroup",
            "Complex.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "AddZeroClass.toZero",
            "Module.instFiniteDimensionalOfIsReflexive",
            "Pi.addCommGroup",
            "LinearMap.mk",
            "MonoidHomClass.toMulHomClass",
            "Module.Free.self",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Eq.ndrec",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Eq.refl",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "CategoryTheory.Category.toCategoryStruct",
            "Units.instMul",
            "AddCommMonoid.toAddMonoid",
            "FGModuleCat",
            "AddCommSemigroup.toAddCommMagma",
            "Submonoid.instSetLike",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "AddHom.mk",
            "ModuleCat.ofHom",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "EuclideanDomain.toCommRing",
            "Complex",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Complex.instRing",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RCLike.innerProductSpace",
            "Fin",
            "Matrix.orthogonalGroup",
            "_auxLemma.2",
            "RingHom.id",
            "Matrix.mulVec",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "SetLike.instMembership",
            "Field.toEuclideanDomain",
            "Submonoid",
            "Add",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instField",
            "MulZeroClass.toZero",
            "Units.instMulOneClass",
            "AddCommMagma.toAdd",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rfl",
          "proofState": 55,
          "pos": {
            "line": 295,
            "column": 6
          },
          "goals": "n\u271d\u00b9 : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\nn\u271d n : \u2115\nw : preweight n\nx\u271d\u00b9 x\u271d : \u21a5(orthogonalGroup (Fin n) \u211d)\n\u22a2 ModuleCat.ofHom { toFun := fun x => \u2191(w.rho x\u271d\u00b9) *\u1d65 \u2191(w.rho x\u271d) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef } =\n    ModuleCat.ofHom { toFun := fun x => \u2191(w.rho x\u271d\u00b9) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef } *\n      ModuleCat.ofHom { toFun := fun x => \u2191(w.rho x\u271d) *\u1d65 x, map_add' := \u22ef, map_smul' := \u22ef }",
          "endPos": {
            "line": 295,
            "column": 9
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 91,
            "column": 53
          },
          "goal": "R : Type u_1\nK : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nv : HeightOneSpectrum R\n\u22a2 TopologicalSpace (FiniteAdeleRing \u2124 \u211a)",
          "endPos": {
            "line": 91,
            "column": 58
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 94,
            "column": 87
          },
          "goal": "R : Type u_1\nK : Type u_2\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nv : HeightOneSpectrum R\n\u22a2 TopologicalRing (FiniteAdeleRing \u2124 \u211a)",
          "endPos": {
            "line": 94,
            "column": 92
          }
        },
        {
          "proofState": 2,
          "pos": {
            "line": 238,
            "column": 51
          },
          "goal": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 Module \u2102 C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u2102), \u2102\u27ef",
          "endPos": {
            "line": 238,
            "column": 56
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 248,
            "column": 81
          },
          "goal": "n : \u2115\nG : Type\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\nE : Type\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : ChartedSpace E G\ninst\u271d : LieGroup \ud835\udcd8(\u211d, E) \u22a4 G\n\u22a2 \u21a5(Z G E) \u2192\u2090[\u2102] Module.End \u2102 C^\u2191\u22a4\u27ee\ud835\udcd8(\u211d, E), G; \ud835\udcd8(\u211d, \u2102), \u2102\u27ef",
          "endPos": {
            "line": 248,
            "column": 86
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 91,
            "column": 0
          },
          "endPos": {
            "line": 91,
            "column": 58
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 94,
            "column": 9
          },
          "endPos": {
            "line": 94,
            "column": 43
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 238,
            "column": 0
          },
          "endPos": {
            "line": 238,
            "column": 56
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 248,
            "column": 4
          },
          "endPos": {
            "line": 248,
            "column": 22
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/GlobalLanglandsConjectures/GLzero.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "continuous_const",
            "Complex.instNormedField",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "PseudoMetricSpace.toUniformSpace",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "SeminormedCommRing.toSeminormedRing",
            "Int.instAddGroup",
            "Real.pseudoMetricSpace",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "UniformSpace.toTopologicalSpace",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "continuity",
          "proofState": 10,
          "pos": {
            "line": 61,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 Continuous fun x => c",
          "endPos": {
            "line": 61,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "Eq.mpr",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "Set.preimage",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "IsOpen",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "OfNat.ofNat",
            "Fin",
            "IsLocallyConstant.eq_1",
            "Eq",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "rw [IsLocallyConstant]",
          "proofState": 11,
          "pos": {
            "line": 63,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 GL (Fin 0) \u211d \u2192 IsLocallyConstant fun x => c",
          "endPos": {
            "line": 63,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Units.instDiscreteTopology",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Mathlib.Topology.Order._auxLemma.6",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "Set.preimage",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "of_eq_true",
            "Int.instAddGroup",
            "Subsingleton.discreteTopology",
            "IsOpen",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "aesop",
          "proofState": 12,
          "pos": {
            "line": 64,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 GL (Fin 0) \u211d \u2192 \u2200 (s : Set \u2102), IsOpen ((fun x => c) \u207b\u00b9' s)",
          "endPos": {
            "line": 64,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "InnerProductSpace.toNormedSpace",
            "NormedCommRing.toSeminormedCommRing",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "Units.instTopologicalSpaceUnits",
            "instENatTop",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "ContMDiff",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "PseudoMetricSpace.toUniformSpace",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "DivisionRing.toDivisionSemiring",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "Finite.of_fintype",
            "Real.commRing",
            "Matrix.linftyOpNormedSpace",
            "WithTop.some",
            "Fin.fintype",
            "Rat.isFractionRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "Real.normedCommRing",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "Ring.toIntAlgebra",
            "Module.Free.self",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "Semiring.toNonUnitalSemiring",
            "Units.instChartedSpace",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "Top.top",
            "OfNat.ofNat",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "UniformSpace.toTopologicalSpace",
            "Ring.toSemiring",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [contMDiff_const]",
          "proofState": 13,
          "pos": {
            "line": 65,
            "column": 19
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a) \u2192\n    ContMDiff (modelWithCornersSelf \u211d (Matrix (Fin 0) (Fin 0) \u211d)) (modelWithCornersSelf \u211d \u2102) \u2191\u22a4 fun y => c",
          "endPos": {
            "line": 65,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Int.euclideanDomain",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Rat.commRing",
            "Eq.trans",
            "forall_congr"
          ],
          "tactic": "simp",
          "proofState": 14,
          "pos": {
            "line": 67,
            "column": 22
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 (g : GL (Fin 0) \u211a) (x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) (y : GL (Fin 0) \u211d),\n    (fun x => c)\n        (((algebraMap \u211a (DedekindDomain.FiniteAdeleRing \u2124 \u211a)).GL (Fin 0)) g * x, ((algebraMap \u211a \u211d).GL (Fin 0)) g * y) =\n      (fun x => c) (x, y)",
          "endPos": {
            "line": 67,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Int.euclideanDomain",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Fin"
          ],
          "tactic": "intros x",
          "proofState": 15,
          "pos": {
            "line": 69,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 (x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)), IsSlowlyIncreasing fun y => (fun x => c) (x, y)",
          "endPos": {
            "line": 69,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "Norm.norm",
            "Units.val",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.instLE",
            "Real",
            "NormedRing.toRing",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.IsSlowlyIncreasing.mk",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Exists",
            "Monoid.toNatPow",
            "Complex.instNorm",
            "Real.semiring",
            "id",
            "AutomorphicForm.GLn.s",
            "Prod.mk",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "Int",
            "LE.le",
            "Real.commRing",
            "Mathlib.Order.Defs.PartialOrder._auxLemma.1",
            "pow_zero",
            "Fin.fintype",
            "MulZeroOneClass.toMulOneClass",
            "Rat.isFractionRing",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "HPow.hPow",
            "Int.instCommRing",
            "Complex.abs",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "Real.instMul",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "AbsoluteValue.funLike",
            "Exists.intro",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "mul_one",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "Real.instPreorder",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "AbsoluteValue"
          ],
          "tactic": "exact\n  {\n    bounded_by := by\n      simp\n      apply Exists.intro (Complex.abs c)\n      apply Exists.intro 0\n      simp }",
          "proofState": 16,
          "pos": {
            "line": 70,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 IsSlowlyIncreasing fun y => (fun x => c) (x, y)",
          "endPos": {
            "line": 76,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "Norm.norm",
            "Units.val",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.instLE",
            "Real",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Exists",
            "Monoid.toNatPow",
            "Complex.instNorm",
            "id",
            "AutomorphicForm.GLn.s",
            "Prod.mk",
            "instOfNatNat",
            "Int",
            "LE.le",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "HPow.hPow",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "Real.instMul",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 17,
          "pos": {
            "line": 72,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2203 C N, \u2200 (M : GL (Fin 0) \u211d), \u2016(fun x => c) (x, M)\u2016 \u2264 C * s \u2191M ^ N",
          "endPos": {
            "line": 72,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "Real.instLE",
            "Real",
            "HMul.hMul",
            "Real.orderedSemiring",
            "CommSemiring.toSemiring",
            "Matrix",
            "instDecidableEqFin",
            "Exists",
            "Monoid.toNatPow",
            "AutomorphicForm.GLn.s",
            "instOfNatNat",
            "LE.le",
            "Real.commRing",
            "Fin.fintype",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Complex.abs",
            "Nat",
            "Real.instMul",
            "AbsoluteValue.funLike",
            "Exists.intro",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "AbsoluteValue"
          ],
          "tactic": "apply Exists.intro (Complex.abs c)",
          "proofState": 18,
          "pos": {
            "line": 73,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2203 C N, \u2200 (M : GL (Fin 0) \u211d), Complex.abs c \u2264 C * s \u2191M ^ N",
          "endPos": {
            "line": 73,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "Real.instLE",
            "Real",
            "HMul.hMul",
            "Real.orderedSemiring",
            "CommSemiring.toSemiring",
            "Matrix",
            "instDecidableEqFin",
            "Monoid.toNatPow",
            "AutomorphicForm.GLn.s",
            "instOfNatNat",
            "LE.le",
            "Real.commRing",
            "Fin.fintype",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Complex.abs",
            "Nat",
            "Real.instMul",
            "AbsoluteValue.funLike",
            "Exists.intro",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "AbsoluteValue"
          ],
          "tactic": "apply Exists.intro 0",
          "proofState": 19,
          "pos": {
            "line": 74,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2203 N, \u2200 (M : GL (Fin 0) \u211d), Complex.abs c \u2264 Complex.abs c * s \u2191M ^ N",
          "endPos": {
            "line": 74,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "Real.instLE",
            "Real",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "Matrix",
            "instDecidableEqFin",
            "Monoid.toNatPow",
            "Real.semiring",
            "AutomorphicForm.GLn.s",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "LE.le",
            "Real.commRing",
            "Mathlib.Order.Defs.PartialOrder._auxLemma.1",
            "pow_zero",
            "Fin.fintype",
            "MulZeroOneClass.toMulOneClass",
            "Real.instMonoid",
            "CommRing.toCommSemiring",
            "HPow.hPow",
            "Complex.abs",
            "Nat",
            "Real.instMul",
            "True",
            "MulOneClass.toOne",
            "AbsoluteValue.funLike",
            "of_eq_true",
            "One.toOfNat1",
            "implies_true",
            "instHPow",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "mul_one",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "Real.instPreorder",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "AbsoluteValue"
          ],
          "tactic": "simp",
          "proofState": 20,
          "pos": {
            "line": 75,
            "column": 8
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u2200 (M : GL (Fin 0) \u211d), Complex.abs c \u2264 Complex.abs c * s \u2191M ^ 0",
          "endPos": {
            "line": 75,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "InvOneClass.toOne",
            "NormedRing.toRing",
            "HMul.hMul",
            "Mathlib.Algebra.Group.Basic._auxLemma.19",
            "DivInvOneMonoid.toInvOneClass",
            "and_true",
            "Init.Core._auxLemma.4",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "CancelMonoid.toLeftCancelMonoid",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "Group.toDivisionMonoid",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionMonoid.toDivInvOneMonoid",
            "Units",
            "Subgroup.mk",
            "Set.instSingletonSet",
            "LeftCancelMonoid.toMonoid",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "Mathlib.Algebra.Group.Units.Basic._auxLemma.12",
            "Unique.instSubsingleton",
            "And",
            "instUniqueUnitsOfSubsingleton",
            "CommRing.toCommSemiring",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "Eq.refl",
            "InvOneClass.toInv",
            "Submonoid.mk",
            "Init.PropLemmas._auxLemma.50",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "Group.toCancelMonoid",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "Set"
          ],
          "tactic": "let U : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := { 1 }, one_mem' := by simp, mul_mem' := by simp\n    inv_mem' := by simp }",
          "proofState": 21,
          "pos": {
            "line": 86,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2203 U, IsConstantOn U fun x => c",
          "endPos": {
            "line": 91,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "HMul.hMul",
            "and_true",
            "Init.Core._auxLemma.4",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "CancelMonoid.toLeftCancelMonoid",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "Units",
            "Set.instSingletonSet",
            "LeftCancelMonoid.toMonoid",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "Mathlib.Algebra.Group.Units.Basic._auxLemma.12",
            "Unique.instSubsingleton",
            "And",
            "instUniqueUnitsOfSubsingleton",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "Eq.refl",
            "Init.PropLemmas._auxLemma.50",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "Group.toCancelMonoid",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "forall_congr",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 22,
          "pos": {
            "line": 89,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 {a b : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)}, a \u2208 {1} \u2192 b \u2208 {1} \u2192 a * b \u2208 {1}",
          "endPos": {
            "line": 89,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Monoid.toMulOneClass",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "Set.instSingletonSet",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 23,
          "pos": {
            "line": 88,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 1 \u2208 { carrier := {1}, mul_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 88,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Mathlib.Data.Set.Basic._auxLemma.51",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "InvOneClass.toOne",
            "NormedRing.toRing",
            "Mathlib.Algebra.Group.Basic._auxLemma.19",
            "DivInvOneMonoid.toInvOneClass",
            "Init.Core._auxLemma.4",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "Group.toDivisionMonoid",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionMonoid.toDivInvOneMonoid",
            "Set.instSingletonSet",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Inv.inv",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "InvOneClass.toInv",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Set.instMembership",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "forall_congr",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 24,
          "pos": {
            "line": 90,
            "column": 23
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 {x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)},\n    x \u2208 { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef }.carrier \u2192\n      x\u207b\u00b9 \u2208 { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 90,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Subgroup",
            "instOfNatNat",
            "Int",
            "AutomorphicForm.GLn.IsConstantOn",
            "Units.instGroup",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Exists.intro",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "apply Exists.intro U",
          "proofState": 25,
          "pos": {
            "line": 92,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 \u2203 U, IsConstantOn U fun x => c",
          "endPos": {
            "line": 92,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Mathlib.Topology.Compactness.Compact._auxLemma.24",
            "Submonoid.toSubsemigroup",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Units.instDiscreteTopology",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Set.Elem",
            "Set.instSingletonSet",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Real.commRing",
            "AutomorphicForm.GLn.IsConstantOn.mk",
            "Mathlib.Topology.Order._auxLemma.6",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "eq_self",
            "Subsemigroup.carrier",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "Subsingleton.discreteTopology",
            "Eq.refl",
            "IsOpen",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "Prod",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "IsCompact",
            "Subgroup.toSubmonoid",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "exact\n  { is_open := by simp\n    is_compact := by aesop\n    finite_level := by simp }",
          "proofState": 26,
          "pos": {
            "line": 93,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 IsConstantOn U fun x => c",
          "endPos": {
            "line": 97,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Submonoid.toSubsemigroup",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Units.instDiscreteTopology",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Mathlib.Topology.Order._auxLemma.6",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Subsemigroup.carrier",
            "of_eq_true",
            "Int.instAddGroup",
            "Subsingleton.discreteTopology",
            "IsOpen",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "instTopologicalSpaceMatrix",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "Subgroup.toSubmonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 27,
          "pos": {
            "line": 94,
            "column": 24
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 IsOpen U.carrier",
          "endPos": {
            "line": 94,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Units.instTopologicalSpaceUnits",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Mathlib.Topology.Compactness.Compact._auxLemma.24",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Set.instSingletonSet",
            "instOfNatNat",
            "Int",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "of_eq_true",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "instTopologicalSpaceMatrix",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Fin",
            "MonoidWithZero.toMonoid",
            "IsCompact",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "aesop",
          "proofState": 28,
          "pos": {
            "line": 95,
            "column": 27
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 IsCompact U.carrier",
          "endPos": {
            "line": 95,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Submonoid.toSubsemigroup",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Set.Elem",
            "DivInvMonoid.toMonoid",
            "instOfNatNat",
            "Int",
            "Units.instGroup",
            "Real.commRing",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "implies_congr",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "True",
            "Ring.toIntAlgebra",
            "eq_self",
            "Subsemigroup.carrier",
            "of_eq_true",
            "Int.instAddGroup",
            "Eq.refl",
            "implies_true",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Subgroup.toSubmonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 29,
          "pos": {
            "line": 96,
            "column": 29
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nU : Subgroup (GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) :=\n  { carrier := {1}, mul_mem' := \u22ef, one_mem' := \u22ef, inv_mem' := \u22ef }\n\u22a2 \u2191U.carrier \u2192 GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a) \u2192 GL (Fin 0) \u211d \u2192 c = c",
          "endPos": {
            "line": 96,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "NormedRing.toRing",
            "Int.euclideanDomain",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Fin.fintype",
            "Rat.isFractionRing",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Fin"
          ],
          "tactic": "intros x",
          "proofState": 30,
          "pos": {
            "line": 78,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\n\u22a2 \u2200 (x : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)),\n    FiniteDimensional \u2102\n      (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n        Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n          (annihilator \u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 78,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "FiniteDimensional.eq_1",
            "Algebra.id",
            "id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Int",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "FiniteDimensional",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Module.Finite",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.annihilator",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "IsLocallyConstant.eq_1",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "rw [FiniteDimensional]",
          "proofState": 31,
          "pos": {
            "line": 79,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 FiniteDimensional \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        (annihilator \u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 79,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "AutomorphicForm.GLn.annihilator.eq_1",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Module.Finite",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.annihilator",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "IsLocallyConstant.eq_1",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "rw [annihilator]",
          "proofState": 32,
          "pos": {
            "line": 80,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 Module.Finite \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        (annihilator \u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 80,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "IsLocallyConstant",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Module.Finite",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "IsLocallyConstant.eq_1",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 33,
          "pos": {
            "line": 81,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 Module.Finite \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        ((Submodule.span \u2102 {\u27e8fun y => (fun x => c) (x, y), \u22ef\u27e9}).compatibleMaps \u22a5))",
          "endPos": {
            "line": 81,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "sorryAx",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "Submodule.instTop",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Lean.Name.num",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "Submodule.FG",
            "Lean.Name.str",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Lean.Name.anonymous",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Lean.Name",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Bool.false",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Module.Finite.mk",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "exact { fg_top := by sorry }",
          "proofState": 34,
          "pos": {
            "line": 82,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 Module.Finite \u2102\n    (\u21a5(Z (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)) \u29f8\n      Submodule.comap (actionTensorCAlg'3 (GL (Fin 0) \u211d) (Matrix (Fin 0) (Fin 0) \u211d)).toLinearMap\n        ((Submodule.span \u2102 {\u27e8fun y => c, \u22ef\u27e9}).compatibleMaps \u22a5))",
          "endPos": {
            "line": 84,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "AutomorphicForm.GLn.IsSmooth.mk",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "_auxLemma.1",
            "continuous_const",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Units.instDiscreteTopology",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "sorryAx",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Set.instSingletonSet",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "instOfNatNat",
            "Complex.instRCLike",
            "Bot.bot",
            "Int",
            "Submodule.instTop",
            "LieAlgebra.ExtendScalars.instLieRing",
            "Lean.Name.num",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "Mathlib.Topology.Order._auxLemma.6",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "IsScalarTower.left",
            "Submodule.FG",
            "Lean.Name.str",
            "smulCommClass_self",
            "Fin.fintype",
            "Subtype.mk",
            "Lean.Name.anonymous",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "Submodule.instBot",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "Set.preimage",
            "DedekindDomain.instLieAlgebra'",
            "implies_congr",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.instTopologicalSpaceFiniteAdeleRingIntRat_fLT",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "Subalgebra.algebra",
            "Module.Free.self",
            "Submodule.span",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Lean.Name",
            "Subsingleton.discreteTopology",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "implies_true",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Submodule.compatibleMaps",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Bool.false",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Subalgebra.toSemiring",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "WithTop",
            "Set"
          ],
          "tactic": "sorry",
          "proofState": 35,
          "pos": {
            "line": 83,
            "column": 21
          },
          "goals": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u22a4.FG",
          "endPos": {
            "line": 83,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "Eq.mpr",
            "AutomorphicForm.GL0.ofComplex",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "Function.LeftInverse",
            "NormedRing.toRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Function.LeftInverse.eq_1",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [Function.LeftInverse]",
          "proofState": 36,
          "pos": {
            "line": 105,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 Function.LeftInverse (fun c => ofComplex \u03c1 c) fun f => f.toFun 1",
          "endPos": {
            "line": 105,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "AutomorphicForm.GL0.ofComplex",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [ofComplex]",
          "proofState": 37,
          "pos": {
            "line": 106,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 \u2200 (x : AutomorphicFormForGLnOverQ 0 \u03c1), ofComplex \u03c1 (x.toFun 1) = x",
          "endPos": {
            "line": 106,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "instOfNatNat",
            "Nat",
            "OfNat.ofNat"
          ],
          "tactic": "intro x",
          "proofState": 38,
          "pos": {
            "line": 107,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 \u2200 (x : AutomorphicFormForGLnOverQ 0 \u03c1),\n    { toFun := fun x_1 => x.toFun 1, is_smooth := \u22ef, is_periodic := \u22ef, is_slowly_increasing := \u22ef, has_finite_level := \u22ef,\n        is_finite_cod := \u22ef } =\n      x",
          "endPos": {
            "line": 107,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "AutomorphicForm.GL0.ofComplex.proof_1",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "AutomorphicForm.GL0.ofComplex.proof_2",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GL0.ofComplex.proof_3",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "AutomorphicForm.GL0.ofComplex.proof_6",
            "instOfNatNat",
            "Int",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.mk",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "AutomorphicForm.GL0.ofComplex.proof_5",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "letFun",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "AutomorphicForm.GL0.ofComplex.proof_4",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have h : x.toFun = fun _ => x.toFun 1 := by exact funext fun g \u21a6 congrArg x.toFun <| Subsingleton.eq_one g",
          "proofState": 39,
          "pos": {
            "line": 108,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\nx : AutomorphicFormForGLnOverQ 0 \u03c1\n\u22a2 { toFun := fun x_1 => x.toFun 1, is_smooth := \u22ef, is_periodic := \u22ef, is_slowly_increasing := \u22ef, has_finite_level := \u22ef,\n      is_finite_cod := \u22ef } =\n    x",
          "endPos": {
            "line": 109,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NormedRing.toRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "Matrix.subsingleton_of_empty_right",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "instOfNatNat",
            "Int",
            "Subsingleton.eq_one",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "instSubsingletonProd",
            "funext",
            "Unique.instSubsingleton",
            "instUniqueUnitsOfSubsingleton",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Fin.isEmpty'",
            "EuclideanDomain.to_principal_ideal_domain",
            "Ring.toIntAlgebra",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "exact funext fun g \u21a6 congrArg x.toFun <| Subsingleton.eq_one g",
          "proofState": 40,
          "pos": {
            "line": 109,
            "column": 6
          },
          "goals": "\u03c1 : Weight 0\nx : AutomorphicFormForGLnOverQ 0 \u03c1\n\u22a2 x.toFun = fun x_1 => x.toFun 1",
          "endPos": {
            "line": 109,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "instInnerProductSpaceRealComplex",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Subalgebra.instSetLike",
            "NormedCommRing.toNormedRing",
            "AlgHom.toLinearMap",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "AutomorphicForm.GL0.ofComplex.proof_1",
            "Matrix.linftyOpNormedAlgebra",
            "AutomorphicForm.GLn.IsSmooth.smooth",
            "InnerProductSpace.toNormedSpace",
            "AutomorphicForm.GLn.instAlgebraComplexAlg",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "complete_of_proper",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "UniversalEnvelopingAlgebra.instRing",
            "MonoidHom.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "RCLike.toNormedAlgebra",
            "HMul.hMul",
            "chartedSpaceSelf",
            "Complex.instNormedAddCommGroup",
            "LeftInvariantDerivation.instLieAlgebra",
            "Units.instTopologicalSpaceUnits",
            "Complex.commRing",
            "instContMDiffAddSelf",
            "instENatTop",
            "MonoidHom",
            "LieRing.toAddCommGroup",
            "Real.denselyNormedField",
            "Real.instRCLike",
            "Submodule.Quotient.addCommGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "AddCommGroup.toAddCommMonoid",
            "Matrix",
            "ContMDiff",
            "AutomorphicForm.GLn.actionTensorCAlg'3",
            "OrderedAddCommMonoid.toPartialOrder",
            "AutomorphicForm.GLn.Alg.proof_2",
            "IsPrincipalIdealRing.isDedekindDomain",
            "NormedSpace.toModule",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "Complex.instNormedField",
            "FiniteDimensional.rclike_to_real",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearMap.instFunLike",
            "PseudoMetricSpace.toUniformSpace",
            "Module.toMulActionWithZero",
            "Preorder.toLE",
            "NormedDivisionRing.toDivisionRing",
            "AutomorphicForm.GLn.instModuleComplexContMDiffMapRealModelWithCornersSelfSomeENatTop_fLT",
            "Algebra.toSMul",
            "Submodule.hasQuotient",
            "AutomorphicForm.GL0.ofComplex.proof_2",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "AutomorphicForm.GL0.ofComplex.proof_3",
            "Exists",
            "algebraMap",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "Eq.rec",
            "DivisionRing.toDivisionSemiring",
            "Algebra.toModule",
            "Algebra.id",
            "Units.instLieGroupModelWithCornersSelf",
            "Subtype",
            "LinearMap.semilinearMapClass",
            "DivInvMonoid.toMonoid",
            "Prod.mk",
            "Subgroup",
            "Real.normedAddCommGroup",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "Module.End.semiring",
            "AutomorphicForm.GL0.ofComplex.proof_6",
            "instOfNatNat",
            "Complex.instRCLike",
            "Int",
            "AutomorphicForm.GLn.IsConstantOn",
            "LieAlgebra.ExtendScalars.instLieRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.mk",
            "Units.instGroup",
            "Submodule.Quotient.module",
            "NormedField.toNormedDivisionRing",
            "Finite.of_fintype",
            "Real.commRing",
            "LinearMap.module",
            "LeftInvariantDerivation.instAddCommGroup",
            "AutomorphicForm.GLn.Z",
            "Matrix.linftyOpNormedSpace",
            "LinearMap",
            "WithTop.some",
            "Field.toCommRing",
            "IsScalarTower.left",
            "DivisionRing.toRatAlgebra",
            "AutomorphicForm.GLn.IsSmooth",
            "smulCommClass_self",
            "Fin.fintype",
            "Units.instOne",
            "Subtype.mk",
            "Rat.isFractionRing",
            "Group.toDivInvMonoid",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AutomorphicForm.GLn.Alg",
            "HasQuotient.Quotient",
            "LeftInvariantDerivation.instModule",
            "Subalgebra.toRing",
            "CommRing.toCommSemiring",
            "FiniteDimensional",
            "ContMDiffMap",
            "Rat.instNormedField",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "WithTop.top",
            "Real.normedCommRing",
            "Int.instCommRing",
            "Submodule.comap",
            "DedekindDomain.instLieAlgebra'",
            "Complex.instCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "ContMDiffMap.addCommMonoid",
            "Nat",
            "ENat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "AddZeroClass.toZero",
            "Real.instDivisionRing",
            "NormedRing.toSeminormedRing",
            "True",
            "LinearMap.addCommMonoid",
            "Ring.toIntAlgebra",
            "CommSemiring.toCommMonoid",
            "eq_self",
            "Subalgebra.algebra",
            "Module.Free.self",
            "LieRing.ofAssociativeRing",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "Eq.ndrec",
            "AutomorphicForm.GLn.instSemiringAlg",
            "Matrix.linftyOpNormedAddCommGroup",
            "Int.instAddGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Units.instChartedSpace",
            "MulActionWithZero.toMulAction",
            "TensorProduct",
            "Eq.refl",
            "NontriviallyNormedField.toNormedField",
            "Units.instMul",
            "Real.pseudoMetricSpace",
            "AddCommMonoid.toAddMonoid",
            "Real.normedField",
            "DenselyNormedField.toNontriviallyNormedField",
            "modelWithCornersSelf",
            "Matrix.linftyOpNormedRing",
            "LinearOrderedRing.isDomain",
            "SeminormedRing.toPseudoMetricSpace",
            "Matrix.GeneralLinearGroup",
            "Module.Finite.matrix",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "FiniteDimensional.proper_real",
            "NormedField.toNormedCommRing",
            "AutomorphicForm.GLn.IsSlowlyIncreasing",
            "AutomorphicForm.GLn.Weight",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "Module.End",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "instTopologicalSpaceMatrix",
            "LeftInvariantDerivation",
            "CommRing.toCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Subalgebra",
            "AutomorphicForm.GL0.ofComplex.proof_5",
            "Prod",
            "Top.top",
            "Complex.instRing",
            "OfNat.ofNat",
            "Eq.symm",
            "AutomorphicForm.GLn.annihilator",
            "AutomorphicForm.GLn.Alg.proof_1",
            "Fin",
            "NormedAddCommGroup.toSeminormedAddCommGroup",
            "RingHom.id",
            "Module.End.instAlgebra",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "RCLike.charZero_rclike",
            "SetLike.instMembership",
            "LeftInvariantDerivation.instLieRing",
            "Rat.commRing",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "RCLike.toInnerProductSpaceReal",
            "NormedAlgebra.toAlgebra",
            "Eq.trans",
            "Units.instMulOneClass",
            "Subalgebra.toSemiring",
            "AutomorphicForm.GL0.ofComplex.proof_4",
            "RingHom.GL",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "WithTop"
          ],
          "tactic": "simp_rw [\u2190 h]",
          "proofState": 41,
          "pos": {
            "line": 110,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\nx : AutomorphicFormForGLnOverQ 0 \u03c1\nh : x.toFun = fun x_1 => x.toFun 1\n\u22a2 { toFun := fun x_1 => x.toFun 1, is_smooth := \u22ef, is_periodic := \u22ef, is_slowly_increasing := \u22ef, has_finite_level := \u22ef,\n      is_finite_cod := \u22ef } =\n    x",
          "endPos": {
            "line": 110,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NormedCommRing.toNormedRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ.toFun",
            "Eq.mpr",
            "AutomorphicForm.GL0.ofComplex",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "Function.LeftInverse",
            "NormedRing.toRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "Int.euclideanDomain",
            "Matrix",
            "OrderedAddCommMonoid.toPartialOrder",
            "IsPrincipalIdealRing.isDedekindDomain",
            "Rat",
            "PartialOrder.toPreorder",
            "instDecidableEqFin",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Preorder.toLE",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "AutomorphicForm.GLn.AutomorphicFormForGLnOverQ",
            "id",
            "instOfNatNat",
            "Int",
            "Real.commRing",
            "Fin.fintype",
            "Units.instOne",
            "Rat.isFractionRing",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Int.instCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "EuclideanDomain.to_principal_ideal_domain",
            "Function.RightInverse.eq_1",
            "Ring.toIntAlgebra",
            "Function.RightInverse",
            "Int.instAddGroup",
            "One.toOfNat1",
            "LinearOrderedRing.isDomain",
            "Matrix.GeneralLinearGroup",
            "Matrix.semiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Complex",
            "Prod",
            "OfNat.ofNat",
            "Fin",
            "Eq",
            "Prod.instOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [Function.RightInverse, Function.LeftInverse]",
          "proofState": 42,
          "pos": {
            "line": 112,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 Function.RightInverse (fun c => ofComplex \u03c1 c) fun f => f.toFun 1",
          "endPos": {
            "line": 112,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "True",
            "eq_self",
            "of_eq_true",
            "implies_true",
            "Complex",
            "Eq",
            "Eq.trans",
            "forall_congr"
          ],
          "tactic": "simp [ofComplex]",
          "proofState": 43,
          "pos": {
            "line": 113,
            "column": 4
          },
          "goals": "\u03c1 : Weight 0\n\u22a2 \u2200 (x : \u2102), (ofComplex \u03c1 x).toFun 1 = x",
          "endPos": {
            "line": 113,
            "column": 20
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 50,
            "column": 58
          },
          "goal": "n : \u2115\n\u03c1 : Weight n\n\u22a2 Prop",
          "endPos": {
            "line": 50,
            "column": 63
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 83,
            "column": 21
          },
          "goal": "\u03c1 : Weight 0\nc : \u2102\nx : GL (Fin 0) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)\n\u22a2 \u22a4.FG",
          "endPos": {
            "line": 83,
            "column": 26
          }
        },
        {
          "proofState": 2,
          "pos": {
            "line": 127,
            "column": 19
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 IsSmooth fun x => z",
          "endPos": {
            "line": 127,
            "column": 24
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 128,
            "column": 21
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2200 (g : GL (Fin n) \u211a) (x : GL (Fin n) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)) (y : GL (Fin n) \u211d),\n    (fun x => z)\n        (((algebraMap \u211a (DedekindDomain.FiniteAdeleRing \u2124 \u211a)).GL (Fin n)) g * x, ((algebraMap \u211a \u211d).GL (Fin n)) g * y) =\n      (fun x => z) (x, y)",
          "endPos": {
            "line": 128,
            "column": 26
          }
        },
        {
          "proofState": 4,
          "pos": {
            "line": 129,
            "column": 30
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2200 (x : GL (Fin n) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)), IsSlowlyIncreasing fun y => (fun x => z) (x, y)",
          "endPos": {
            "line": 129,
            "column": 35
          }
        },
        {
          "proofState": 5,
          "pos": {
            "line": 131,
            "column": 26
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2203 U, IsConstantOn U fun x => z",
          "endPos": {
            "line": 131,
            "column": 31
          }
        },
        {
          "proofState": 6,
          "pos": {
            "line": 130,
            "column": 23
          },
          "goal": "z : \u2102\nn : \u2115\n\u03c1 : Weight n\nh\u03c1 : \u03c1.IsTrivial\n\u22a2 \u2200 (x : GL (Fin n) (DedekindDomain.FiniteAdeleRing \u2124 \u211a)),\n    FiniteDimensional \u2102\n      (\u21a5(Z (GL (Fin n) \u211d) (Matrix (Fin n) (Fin n) \u211d)) \u29f8\n        Submodule.comap (actionTensorCAlg'3 (GL (Fin n) \u211d) (Matrix (Fin n) (Fin n) \u211d)).toLinearMap\n          (annihilator \u27e8fun y => (fun x => z) (x, y), \u22ef\u27e9))",
          "endPos": {
            "line": 130,
            "column": 28
          }
        },
        {
          "proofState": 7,
          "pos": {
            "line": 136,
            "column": 28
          },
          "goal": "\u03c1 : Weight 0\nz : \u2102\n\u22a2 \u03c1.IsTrivial",
          "endPos": {
            "line": 136,
            "column": 33
          }
        },
        {
          "proofState": 8,
          "pos": {
            "line": 137,
            "column": 14
          },
          "goal": "\u03c1 : Weight 0\n\u22a2 Function.LeftInverse (fun z => ofComplex z \u03c1 \u22ef) fun f => f.toFun 1",
          "endPos": {
            "line": 137,
            "column": 19
          }
        },
        {
          "proofState": 9,
          "pos": {
            "line": 138,
            "column": 15
          },
          "goal": "\u03c1 : Weight 0\n\u22a2 Function.RightInverse (fun z => ofComplex z \u03c1 \u22ef) fun f => f.toFun 1",
          "endPos": {
            "line": 138,
            "column": 20
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 50,
            "column": 4
          },
          "endPos": {
            "line": 50,
            "column": 24
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 58,
            "column": 4
          },
          "endPos": {
            "line": 58,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 124,
            "column": 4
          },
          "endPos": {
            "line": 124,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 134,
            "column": 18
          },
          "endPos": {
            "line": 134,
            "column": 32
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 134,
            "column": 18
          },
          "endPos": {
            "line": 134,
            "column": 32
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 134,
            "column": 18
          },
          "endPos": {
            "line": 134,
            "column": 32
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/NumberField/InfiniteAdeleRing.lean",
    "output": {
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 28,
            "column": 2
          },
          "goal": "K : Type u_1\nL : Type u_2\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : NumberField K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : NumberField L\ninst\u271d : Algebra K L\n\u22a2 L \u2297[K] InfiniteAdeleRing K \u2243A[L]InfiniteAdeleRing L",
          "endPos": {
            "line": 28,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 26,
            "column": 4
          },
          "endPos": {
            "line": 26,
            "column": 49
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/NumberField/AdeleRing.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use {f | \u2200 v, f v \u2208 (Metric.ball 0 1)} \u00d7\u02e2 {f | \u2200 v, f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "proofState": 7,
          "pos": {
            "line": 26,
            "column": 2
          },
          "goals": "\u22a2 \u2203 U, IsOpen U \u2227 \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9' U = {0}",
          "endPos": {
            "line": 27,
            "column": 83
          }
        },
        {
          "usedConstants": [
            "NumberField.AdeleRing.instTopologicalSpace",
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Rat.commSemiring",
            "Membership.mem",
            "Exists",
            "algebraMap",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "Set.instSingletonSet",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "NumberField.AdeleRing.instAlgebra",
            "Real.instOne",
            "Rat.numberField",
            "CommRing.toCommSemiring",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "Set.preimage",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "And.intro",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NumberField.AdeleRing",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "NumberField.AdeleRing.instCommRing",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "IsOpen",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "Singleton.singleton",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "SetLike.instMembership",
            "NumberField.place",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "refine \u27e8?_, ?_\u27e9",
          "proofState": 8,
          "pos": {
            "line": 28,
            "column": 2
          },
          "goals": "case h\n\u22a2 IsOpen\n      ({f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n        {f |\n          \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n            (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}) \u2227\n    \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9'\n        {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n          {f |\n            \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n              (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v} =\n      {0}",
          "endPos": {
            "line": 28,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "id"
          ],
          "tactic": "dsimp",
          "proofState": 9,
          "pos": {
            "line": 29,
            "column": 4
          },
          "goals": "case h.refine_1\n\u22a2 IsOpen\n    ({f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v})",
          "endPos": {
            "line": 29,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "NumberField.AdeleRing.instTopologicalSpace",
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Membership.mem",
            "Exists",
            "sorryAx",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "instOfNatNat",
            "Lean.Name.num",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "Real.instOne",
            "Rat.numberField",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "Nat",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NumberField.AdeleRing",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Lean.Name",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "IsOpen",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Bool.false",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "SetLike.instMembership",
            "NumberField.place",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "sorry\n  -- issue #252 -- should be easy (product of opens is open, product of integers is surely\n            -- known to be open)",
          "proofState": 10,
          "pos": {
            "line": 30,
            "column": 4
          },
          "goals": "case h.refine_1\n\u22a2 IsOpen\n    ({f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v})",
          "endPos": {
            "line": 30,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "subset_antisymm"
          ],
          "tactic": "apply subset_antisymm",
          "proofState": 11,
          "pos": {
            "line": 32,
            "column": 4
          },
          "goals": "case h.refine_2\n\u22a2 \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9'\n      {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n        {f |\n          \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n            (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v} =\n    {0}",
          "endPos": {
            "line": 32,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "Rat"
          ],
          "tactic": "intro x hx",
          "proofState": 12,
          "pos": {
            "line": 33,
            "column": 6
          },
          "goals": "case h.refine_2.a\n\u22a2 \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9'\n      {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n        {f |\n          \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n            (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v} \u2286\n    {0}",
          "endPos": {
            "line": 33,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Rat.commSemiring",
            "Membership.mem",
            "Exists",
            "algebraMap",
            "Eq.mp",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "NumberField.AdeleRing.instAlgebra",
            "Real.instOne",
            "Rat.numberField",
            "CommRing.toCommSemiring",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "Set.preimage",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "propext",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NumberField.AdeleRing",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "NumberField.AdeleRing.instCommRing",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "SetLike.instMembership",
            "NumberField.place",
            "Set.mem_preimage",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "rw [Set.mem_preimage] at hx",
          "proofState": 13,
          "pos": {
            "line": 34,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\nhx :\n  x \u2208\n    \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9'\n      {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n        {f |\n          \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n            (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 x \u2208 {0}",
          "endPos": {
            "line": 34,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Eq.mpr",
            "Rat",
            "_auxLemma.1",
            "Membership.mem",
            "Set.instSingletonSet",
            "id",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Eq",
            "Set.instMembership",
            "Set"
          ],
          "tactic": "simp only [Set.mem_singleton_iff]",
          "proofState": 14,
          "pos": {
            "line": 35,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\nhx :\n  (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 x \u2208 {0}",
          "endPos": {
            "line": 35,
            "column": 39
          }
        },
        {
          "usedConstants": [],
          "tactic": "have :\n  (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x =\n    (algebraMap \u211a (InfiniteAdeleRing \u211a) x, algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a) x)",
          "proofState": 15,
          "pos": {
            "line": 36,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\nhx :\n  (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 x = 0",
          "endPos": {
            "line": 37,
            "column": 88
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "CommSemiring.toSemiring",
            "Rat",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "RingHom",
            "Rat.commSemiring",
            "algebraMap",
            "Algebra.id",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NumberField.RingOfIntegers.instCommRing",
            "Field.toSemifield",
            "NumberField.AdeleRing.instAlgebra",
            "Rat.numberField",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "Rat.instField",
            "NumberField.AdeleRing",
            "Eq.refl",
            "NumberField.AdeleRing.instCommRing",
            "Semifield.toCommSemiring",
            "NormedField.toNormedCommRing",
            "NumberField.RingOfIntegers",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe"
          ],
          "tactic": "rfl",
          "proofState": 16,
          "pos": {
            "line": 38,
            "column": 8
          },
          "goals": "case this\nx : \u211a\nhx :\n  (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x =\n    ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x)",
          "endPos": {
            "line": 38,
            "column": 11
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [this] at hx",
          "proofState": 17,
          "pos": {
            "line": 39,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\nhx :\n  (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\nthis :\n  (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x =\n    ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x)\n\u22a2 x = 0",
          "endPos": {
            "line": 39,
            "column": 21
          }
        },
        {
          "usedConstants": [],
          "tactic": "clear this",
          "proofState": 18,
          "pos": {
            "line": 40,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\nhx :\n  ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\nthis :\n  (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x =\n    ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x)\n\u22a2 x = 0",
          "endPos": {
            "line": 40,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Rat.commSemiring",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "Exists",
            "algebraMap",
            "Eq.mp",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "Prod.mk",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Prod.fst",
            "Real.instOne",
            "Rat.numberField",
            "Set.mem_prod",
            "And",
            "CommRing.toCommSemiring",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "NumberField.InfiniteAdeleRing.instAlgebra",
            "WithAbs.normedField",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "propext",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "Prod.snd",
            "DFunLike.coe",
            "SetLike.instMembership",
            "NumberField.InfiniteAdeleRing.instCommRing",
            "NumberField.place",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "rw [Set.mem_prod] at hx",
          "proofState": 19,
          "pos": {
            "line": 41,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\nhx :\n  ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 x = 0",
          "endPos": {
            "line": 41,
            "column": 29
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8h1, h2\u27e9 := hx",
          "proofState": 20,
          "pos": {
            "line": 42,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\nhx :\n  ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x).1 \u2208\n      {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u2227\n    ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x).2 \u2208\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 x = 0",
          "endPos": {
            "line": 42,
            "column": 27
          }
        },
        {
          "usedConstants": [],
          "tactic": "dsimp only at h1 h2",
          "proofState": 21,
          "pos": {
            "line": 43,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh1 :\n  ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x).1 \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1}\nh2 :\n  ((algebraMap \u211a (InfiniteAdeleRing \u211a)) x, (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x).2 \u2208\n    {f |\n      \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n        (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 x = 0",
          "endPos": {
            "line": 43,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "UniformSpace.Completion.coe'",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "SeminormedAddGroup.toAddGroup",
            "instZeroCompletion",
            "WithAbs",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "Real.instLT",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Rat.commSemiring",
            "Membership.mem",
            "Exists",
            "algebraMap",
            "Eq.mp",
            "NumberField.InfinitePlace.Completion",
            "Metric.ball",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NormedField.toNormedDivisionRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Field.toSemifield",
            "UniformSpace.Completion.norm_coe",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "SeminormedAddCommGroup.toNorm",
            "funext",
            "CommRing.toCommSemiring",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instField",
            "SeminormedAddCommGroup.toPseudoMetricSpace",
            "NumberField.InfiniteAdeleRing.instAlgebra",
            "WithAbs.normedField",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "UniformSpace.Completion.instNormedCommRing",
            "UniformSpace.Completion.instNorm",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "LT.lt",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Subtype.val",
            "dist_zero_right",
            "_auxLemma.2",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "NumberField.InfiniteAdeleRing.instCommRing",
            "NumberField.place",
            "UniformSpace.Completion",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "forall_congr",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "simp only [Metric.mem_ball, dist_zero_right, Set.mem_setOf_eq, InfiniteAdeleRing.algebraMap_apply,\n  UniformSpace.Completion.norm_coe] at h1",
          "proofState": 22,
          "pos": {
            "line": 44,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh1 : (algebraMap \u211a (InfiniteAdeleRing \u211a)) x \u2208 {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1}\nh2 :\n  (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x \u2208\n    {f |\n      \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n        \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\n\u22a2 x = 0",
          "endPos": {
            "line": 45,
            "column": 83
          }
        },
        {
          "usedConstants": [],
          "tactic": "simp only [Set.mem_setOf_eq] at h2",
          "proofState": 23,
          "pos": {
            "line": 46,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh2 :\n  (algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x \u2208\n    {f |\n      \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n        \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}\nh1 : \u2200 (v : InfinitePlace \u211a), \u2016x\u2016 < 1\n\u22a2 x = 0",
          "endPos": {
            "line": 46,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "Rat.infinitePlace"
          ],
          "tactic": "specialize h1 Rat.infinitePlace",
          "proofState": 24,
          "pos": {
            "line": 47,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : \u2200 (v : InfinitePlace \u211a), \u2016x\u2016 < 1\n\u22a2 x = 0",
          "endPos": {
            "line": 47,
            "column": 37
          }
        },
        {
          "usedConstants": [],
          "tactic": "change \u2016(x : \u2102)\u2016 < 1 at h1",
          "proofState": 25,
          "pos": {
            "line": 48,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : \u2016x\u2016 < 1\n\u22a2 x = 0",
          "endPos": {
            "line": 48,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Real",
            "Real.lattice",
            "abs",
            "congrArg",
            "Real.instRatCast",
            "Real.instLT",
            "Complex.instNorm",
            "Eq.mp",
            "Rat.cast",
            "Real.instAddGroup",
            "Complex.norm_ratCast",
            "Complex.instRatCast",
            "Real.instOne",
            "LT.lt",
            "One.toOfNat1",
            "Complex",
            "OfNat.ofNat"
          ],
          "tactic": "simp at h1",
          "proofState": 26,
          "pos": {
            "line": 49,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : \u2016\u2191x\u2016 < 1\n\u22a2 x = 0",
          "endPos": {
            "line": 49,
            "column": 16
          }
        },
        {
          "usedConstants": [],
          "tactic": "have intx : \u2203 (y : \u2124), y = x",
          "proofState": 27,
          "pos": {
            "line": 50,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\n\u22a2 x = 0",
          "endPos": {
            "line": 50,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "IsDedekindDomain.HeightOneSpectrum.mem_integers_of_valuation_le_one",
            "Rat",
            "IsDedekindDomain.HeightOneSpectrum"
          ],
          "tactic": "obtain \u27e8z, hz\u27e9 :=\n  IsDedekindDomain.HeightOneSpectrum.mem_integers_of_valuation_le_one \u211a x <| fun v \u21a6\n    by\n    specialize h2 v\n    letI : UniformSpace \u211a := v.adicValued.toUniformSpace\n    rw [IsDedekindDomain.HeightOneSpectrum.mem_adicCompletionIntegers] at h2\n    rwa [\u2190 IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_eq_valuation']",
          "proofState": 28,
          "pos": {
            "line": 51,
            "column": 8
          },
          "goals": "case intx\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\n\u22a2 \u2203 y, \u2191y = x",
          "endPos": {
            "line": 56,
            "column": 87
          }
        },
        {
          "usedConstants": [],
          "tactic": "specialize h2 v",
          "proofState": 29,
          "pos": {
            "line": 53,
            "column": 10
          },
          "goals": "x : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nv : IsDedekindDomain.HeightOneSpectrum ?m.10590\n\u22a2 v.valuation x \u2264 1",
          "endPos": {
            "line": 53,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Rat",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "Field.toDivisionRing",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Algebra.id",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "DivisionRing.toRing",
            "Int",
            "NumberField.RingOfIntegers.instCommRing",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "Rat.numberField",
            "Rat.instNormedField",
            "Rat.instField",
            "WithZero",
            "Semifield.toCommSemiring",
            "NormedField.toNormedCommRing",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "NumberField.RingOfIntegers"
          ],
          "tactic": "letI : UniformSpace \u211a := v.adicValued.toUniformSpace",
          "proofState": 30,
          "pos": {
            "line": 54,
            "column": 10
          },
          "goals": "x : \u211a\nh2\u271d :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nv : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)\nh2 : \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\n\u22a2 v.valuation x \u2264 1",
          "endPos": {
            "line": 54,
            "column": 62
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [IsDedekindDomain.HeightOneSpectrum.mem_adicCompletionIntegers] at h2",
          "proofState": 31,
          "pos": {
            "line": 55,
            "column": 10
          },
          "goals": "x : \u211a\nh2\u271d :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nv : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)\nh2 : \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nthis : UniformSpace \u211a := Valued.toUniformSpace\n\u22a2 v.valuation x \u2264 1",
          "endPos": {
            "line": 55,
            "column": 82
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "UniformSpace.Completion.coe'",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Valued.topologicalDivisionRing",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Rat",
            "Valued.v",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Field.toDivisionRing",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "id",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_eq_valuation'",
            "DivisionRing.toRing",
            "Int",
            "LE.le",
            "NumberField.RingOfIntegers.instCommRing",
            "LinearOrderedRing.toStrictOrderedRing",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "WithZero.preorder",
            "WithZero.one",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "Valued.toUniformSpace",
            "Rat.instField",
            "Int.instCommRing",
            "UniformSpace.Completion.ring",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Multiplicative.preorder",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "Valued.valuedCompletion",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Eq.symm",
            "NumberField.RingOfIntegers",
            "UniformSpace.toTopologicalSpace",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "TopologicalDivisionRing.toTopologicalRing",
            "OrderedAddCommGroup.toPartialOrder",
            "Valuation",
            "UniformSpace.Completion",
            "Valued.toUniformAddGroup",
            "MulZeroClass.toZero"
          ],
          "tactic": "rwa [\u2190 IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_eq_valuation']",
          "proofState": 32,
          "pos": {
            "line": 56,
            "column": 10
          },
          "goals": "x : \u211a\nh2\u271d :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nv : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)\nh2 : Valued.v (\u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v) \u2264 1\nthis : UniformSpace \u211a := Valued.toUniformSpace\n\u22a2 v.valuation x \u2264 1",
          "endPos": {
            "line": 56,
            "column": 87
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use Rat.ringOfIntegersEquiv z",
          "proofState": 33,
          "pos": {
            "line": 57,
            "column": 8
          },
          "goals": "case intx.intro\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nz : \ud835\udcde \u211a\nhz : (algebraMap (\ud835\udcde \u211a) \u211a) z = x\n\u22a2 \u2203 y, \u2191y = x",
          "endPos": {
            "line": 57,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "RingEquiv.instEquivLike",
            "Rat",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "Rat.ringOfIntegersEquiv",
            "RingHom",
            "Field.toDivisionRing",
            "algebraMap",
            "Algebra.id",
            "Rat.instIntCast",
            "id",
            "Distrib.toAdd",
            "DivisionRing.toRing",
            "Int",
            "NumberField.RingOfIntegers.instCommRing",
            "Field.toSemifield",
            "Int.instMul",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "Distrib.toMul",
            "DivisionSemiring.toSemiring",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Semifield.toCommSemiring",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "RingEquiv",
            "Eq.symm",
            "NumberField.RingOfIntegers",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "EquivLike.toFunLike"
          ],
          "tactic": "rw [\u2190 hz]",
          "proofState": 34,
          "pos": {
            "line": 58,
            "column": 8
          },
          "goals": "case h\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nz : \ud835\udcde \u211a\nhz : (algebraMap (\ud835\udcde \u211a) \u211a) z = x\n\u22a2 \u2191(ringOfIntegersEquiv z) = x",
          "endPos": {
            "line": 58,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Rat.ringOfIntegersEquiv_eq_algebraMap"
          ],
          "tactic": "apply Rat.ringOfIntegersEquiv_eq_algebraMap",
          "proofState": 35,
          "pos": {
            "line": 59,
            "column": 8
          },
          "goals": "case h\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nz : \ud835\udcde \u211a\nhz : (algebraMap (\ud835\udcde \u211a) \u211a) z = x\n\u22a2 \u2191(ringOfIntegersEquiv z) = (algebraMap (\ud835\udcde \u211a) \u211a) z",
          "endPos": {
            "line": 59,
            "column": 51
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8y, rfl\u27e9 := intx",
          "proofState": 36,
          "pos": {
            "line": 60,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro\nx : \u211a\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) x) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191x| < 1\nintx : \u2203 y, \u2191y = x\n\u22a2 x = 0",
          "endPos": {
            "line": 60,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Real",
            "Preorder.toLT",
            "OrderedAddCommGroup.toAddLeftMono",
            "abs",
            "covariant_swap_add_of_covariant_add",
            "Real.instRatCast",
            "Rat",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "SemilatticeInf.toPartialOrder",
            "Eq.mp",
            "DistribLattice.toLattice",
            "Rat.instIntCast",
            "Rat.cast",
            "Real.instAddGroup",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommSemigroup",
            "Real.instOne",
            "And",
            "Real.orderedAddCommGroup",
            "LT.lt",
            "One.toOfNat1",
            "OfNat.ofNat",
            "instDistribLatticeOfLinearOrder",
            "Neg.neg",
            "Real.linearOrder",
            "Lattice.toSemilatticeInf",
            "_auxLemma.3"
          ],
          "tactic": "simp only [abs_lt] at h1",
          "proofState": 37,
          "pos": {
            "line": 61,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro.intro\ny : \u2124\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) \u2191y) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : |\u2191\u2191y| < 1\n\u22a2 \u2191y = 0",
          "endPos": {
            "line": 61,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "Rat.instOfNat",
            "Int.cast",
            "Eq.mpr",
            "NormedRing.toRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Int.cast_zero",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Rat.instIntCast",
            "id",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.cast",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "Int.instRing",
            "Nat",
            "AddZeroClass.toZero",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Eq.symm",
            "NegZeroClass.toZero",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3"
          ],
          "tactic": "norm_cast at h1 \u22a2\n    -- We need the next line because `norm_cast` is for some reason producing a `negSucc 0`.\n          -- I haven't been able to isolate this behaviour even in a standalone lemma.\n          -- We could also make `omega` more robust against accidental appearances of `negSucc`.",
          "proofState": 38,
          "pos": {
            "line": 62,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro.intro\ny : \u2124\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) \u2191y) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : -1 < \u2191\u2191y \u2227 \u2191\u2191y < 1\n\u22a2 \u2191y = 0",
          "endPos": {
            "line": 62,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Eq.mp",
            "Int.instNegInt",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Int.instLTInt",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "And",
            "instOfNat",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "LT.lt",
            "Int.negSucc_eq",
            "Int.instAdd",
            "One.toOfNat1",
            "instNatCastInt",
            "Int.negSucc",
            "OfNat.ofNat",
            "Ring.toAddGroupWithOne",
            "Neg.neg"
          ],
          "tactic": "rw [Int.negSucc_eq] at h1",
          "proofState": 39,
          "pos": {
            "line": 66,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro.intro\ny : \u2124\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) \u2191y) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : Int.negSucc 0 < y \u2227 y < 1\n\u22a2 y = 0",
          "endPos": {
            "line": 66,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega",
          "proofState": 40,
          "pos": {
            "line": 67,
            "column": 6
          },
          "goals": "case h.refine_2.a.intro.intro\ny : \u2124\nh2 :\n  \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u2191((algebraMap \u211a (FiniteAdeleRing (\ud835\udcde \u211a) \u211a)) \u2191y) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v\nh1 : -(\u21910 + 1) < y \u2227 y < 1\n\u22a2 y = 0",
          "endPos": {
            "line": 67,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Rat"
          ],
          "tactic": "intro x",
          "proofState": 41,
          "pos": {
            "line": 68,
            "column": 6
          },
          "goals": "case h.refine_2.a\n\u22a2 {0} \u2286\n    \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9'\n      {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n        {f |\n          \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n            (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 68,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "_auxLemma.1",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Rat.commSemiring",
            "Membership.mem",
            "Exists",
            "algebraMap",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "Set.instSingletonSet",
            "id",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "NumberField.AdeleRing.instAlgebra",
            "Real.instOne",
            "Rat.numberField",
            "CommRing.toCommSemiring",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "Set.preimage",
            "implies_congr",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NumberField.AdeleRing",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "_auxLemma.4",
            "NumberField.AdeleRing.instCommRing",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "Singleton.singleton",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "SetLike.instMembership",
            "NumberField.place",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "simp only [Set.mem_singleton_iff, Set.mem_preimage]",
          "proofState": 42,
          "pos": {
            "line": 69,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\n\u22a2 x \u2208 {0} \u2192\n    x \u2208\n      \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9'\n        {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n          {f |\n            \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n              (fun v => \u2191f v) v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 69,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "Rat",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rintro rfl",
          "proofState": 43,
          "pos": {
            "line": 70,
            "column": 6
          },
          "goals": "case h.refine_2.a\nx : \u211a\n\u22a2 x = 0 \u2192\n    (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) x \u2208\n      {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n        {f |\n          \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n            \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 70,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Rat.commSemiring",
            "Membership.mem",
            "Exists",
            "algebraMap",
            "map_zero",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "id",
            "RingHomClass.toMonoidWithZeroHomClass",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NonAssocSemiring.toMulZeroOneClass",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "NumberField.AdeleRing.instAlgebra",
            "Real.instOne",
            "Rat.numberField",
            "CommRing.toCommSemiring",
            "Complex.instNontrivial",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NumberField.AdeleRing",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "NumberField.AdeleRing.instCommRing",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "MonoidWithZeroHomClass.toZeroHomClass",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Rat.semiring",
            "SetLike.instMembership",
            "NumberField.place",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "simp only [map_zero]",
          "proofState": 44,
          "pos": {
            "line": 71,
            "column": 6
          },
          "goals": "case h.refine_2.a\n\u22a2 (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) 0 \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 71,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Membership.mem",
            "Exists",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "id",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Real.instOne",
            "Rat.numberField",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NumberField.AdeleRing",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "NumberField.AdeleRing.instCommRing",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "SetLike.instMembership",
            "NumberField.place",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "change (0, 0) \u2208 _",
          "proofState": 45,
          "pos": {
            "line": 72,
            "column": 6
          },
          "goals": "case h.refine_2.a\n\u22a2 0 \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 72,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Set.instSProd",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "SProd.sprod",
            "Real.orderedSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "NumberField.InfiniteAdeleRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "Complex.instNormedField",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "Exists",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "id",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "Prod.mk",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Real.instOne",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Rat.numberField",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "UniformSpace.Completion.instNormedCommRing",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NumberField.AdeleRing",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "SetLike.instMembership",
            "NumberField.InfiniteAdeleRing.instCommRing",
            "NumberField.place",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "ValuationSubring",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "simp only [Prod.mk_zero_zero, Set.mem_prod, Prod.fst_zero, Prod.snd_zero]",
          "proofState": 46,
          "pos": {
            "line": 73,
            "column": 6
          },
          "goals": "case h.refine_2.a\n\u22a2 (0, 0) \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 73,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "And.intro"
          ],
          "tactic": "constructor",
          "proofState": 47,
          "pos": {
            "line": 74,
            "column": 6
          },
          "goals": "case h.refine_2.a\n\u22a2 0 \u2208\n    {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 74,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "SeminormedAddGroup.toAddGroup",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "instZeroCompletion",
            "WithAbs",
            "Real.orderedSemiring",
            "congrArg",
            "NumberField.InfiniteAdeleRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "Complex.instNormedField",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "Real.instLT",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "Membership.mem",
            "Exists",
            "NumberField.InfinitePlace.Completion",
            "Algebra.id",
            "id",
            "Metric.ball",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NumberField.RingOfIntegers.instCommRing",
            "NormedField.toNormedDivisionRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Field.toSemifield",
            "Prod.fst",
            "Real.instOne",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Rat.numberField",
            "funext",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instField",
            "WithAbs.normedField",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "Prod.instZero",
            "UniformSpace.Completion.instNormedCommRing",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "LT.lt",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "NumberField.InfinitePlace",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Prod",
            "OfNat.ofNat",
            "NumberField.RingOfIntegers",
            "Subtype.val",
            "dist_zero_right",
            "_auxLemma.2",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "NumberField.InfiniteAdeleRing.instCommRing",
            "NumberField.place",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Complex.instSemiring",
            "forall_congr",
            "AbsoluteValue",
            "Set"
          ],
          "tactic": "simp only [Metric.mem_ball, dist_zero_right, Set.mem_setOf_eq]",
          "proofState": 48,
          "pos": {
            "line": 75,
            "column": 8
          },
          "goals": "case h.refine_2.a.left\n\u22a2 0.1 \u2208 {f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1}",
          "endPos": {
            "line": 75,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "Rat",
            "Rat.instField",
            "NumberField.InfinitePlace"
          ],
          "tactic": "intro v",
          "proofState": 49,
          "pos": {
            "line": 76,
            "column": 8
          },
          "goals": "case h.refine_2.a.left\n\u22a2 \u2200 (v : InfinitePlace \u211a), \u20160.1 v\u2016 < 1",
          "endPos": {
            "line": 76,
            "column": 15
          }
        },
        {
          "usedConstants": [],
          "tactic": "have : \u2016(0 : InfiniteAdeleRing \u211a) v\u2016 = 0",
          "proofState": 50,
          "pos": {
            "line": 77,
            "column": 8
          },
          "goals": "case h.refine_2.a.left\nv : InfinitePlace \u211a\n\u22a2 \u20160.1 v\u2016 < 1",
          "endPos": {
            "line": 77,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Norm.norm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "WithAbs",
            "Real.instZero",
            "Real.orderedSemiring",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "PseudoMetricSpace.toUniformSpace",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Exists",
            "NumberField.InfinitePlace.Completion",
            "NormedField.toNorm",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NormedAddGroup.toAddGroup",
            "NormedField.toNormedDivisionRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Field.toSemifield",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "Rat.instField",
            "WithAbs.normedField",
            "_auxLemma.6",
            "UniformSpace.Completion.instNorm",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "NormedAddCommGroup.toNormedAddGroup",
            "UniformSpace.Completion.instNormedAddCommGroup",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Subtype.val",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "NumberField.InfiniteAdeleRing.instCommRing",
            "NumberField.place",
            "MulZeroClass.toZero",
            "Complex.instSemiring",
            "AbsoluteValue"
          ],
          "tactic": "simp only [norm_eq_zero]",
          "proofState": 51,
          "pos": {
            "line": 78,
            "column": 10
          },
          "goals": "case this\nv : InfinitePlace \u211a\n\u22a2 \u20160 v\u2016 = 0",
          "endPos": {
            "line": 78,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "NumberField.InfinitePlace.Completion",
            "Rat.instField",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "OfNat.ofNat",
            "NumberField.InfiniteAdeleRing.instCommRing",
            "MulZeroClass.toZero"
          ],
          "tactic": "rfl",
          "proofState": 52,
          "pos": {
            "line": 79,
            "column": 10
          },
          "goals": "case this\nv : InfinitePlace \u211a\n\u22a2 0 v = 0",
          "endPos": {
            "line": 79,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Norm.norm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instStarOrderedRing",
            "Real.partialOrder",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "instStarRingReal",
            "CommRing.toNonUnitalCommRing",
            "WithAbs",
            "Real.instZero",
            "Real.instRCLike",
            "Real.orderedSemiring",
            "congrArg",
            "NeZero.charZero_one",
            "NumberField.InfiniteAdeleRing",
            "Rat",
            "Complex.instNormedField",
            "AddGroupWithOne.toAddMonoidWithOne",
            "PseudoMetricSpace.toUniformSpace",
            "Real.instLT",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Exists",
            "Real.semiring",
            "NumberField.InfinitePlace.Completion",
            "NormedField.toNorm",
            "Real.instRing",
            "NormedField.toNormedDivisionRing",
            "Field.toSemifield",
            "Real.instOne",
            "instZeroLEOneClass",
            "Complex.instNontrivial",
            "Semifield.toDivisionSemiring",
            "Rat.instField",
            "WithAbs.normedField",
            "UniformSpace.Completion.instNorm",
            "LT.lt",
            "True",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Complex",
            "OfNat.ofNat",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "NumberField.InfiniteAdeleRing.instCommRing",
            "NumberField.place",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Complex.instSemiring",
            "AbsoluteValue",
            "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2"
          ],
          "tactic": "simp [this, zero_lt_one]",
          "proofState": 53,
          "pos": {
            "line": 80,
            "column": 8
          },
          "goals": "case h.refine_2.a.left\nv : InfinitePlace \u211a\nthis : \u20160 v\u2016 = 0\n\u22a2 \u20160.1 v\u2016 < 1",
          "endPos": {
            "line": 80,
            "column": 32
          }
        },
        {
          "usedConstants": [
            "id"
          ],
          "tactic": "simp only [Set.mem_setOf_eq]",
          "proofState": 54,
          "pos": {
            "line": 81,
            "column": 8
          },
          "goals": "case h.refine_2.a.right\n\u22a2 0.2 \u2208\n    {f |\n      \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n        \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v}",
          "endPos": {
            "line": 81,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Rat",
            "IsDedekindDomain.HeightOneSpectrum",
            "NumberField.RingOfIntegers.instCommRing",
            "Rat.instField",
            "NumberField.RingOfIntegers"
          ],
          "tactic": "intro v",
          "proofState": 55,
          "pos": {
            "line": 82,
            "column": 8
          },
          "goals": "case h.refine_2.a.right\n\u22a2 \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n    \u21910.2 v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v",
          "endPos": {
            "line": 82,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "ZeroMemClass.zero_mem"
          ],
          "tactic": "apply zero_mem",
          "proofState": 56,
          "pos": {
            "line": 83,
            "column": 8
          },
          "goals": "case h.refine_2.a.right\nv : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)\n\u22a2 \u21910.2 v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v",
          "endPos": {
            "line": 83,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Rat.AdeleRing.zero_discrete"
          ],
          "tactic": "obtain \u27e8V, hV, hV0\u27e9 := zero_discrete",
          "proofState": 57,
          "pos": {
            "line": 90,
            "column": 2
          },
          "goals": "\u22a2 \u2200 (q : \u211a), \u2203 U, IsOpen U \u2227 \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9' U = {q}",
          "endPos": {
            "line": 90,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Rat"
          ],
          "tactic": "intro q",
          "proofState": 58,
          "pos": {
            "line": 91,
            "column": 2
          },
          "goals": "case intro.intro\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nhV0 : \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9' V = {0}\n\u22a2 \u2200 (q : \u211a), \u2203 U, IsOpen U \u2227 \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9' U = {q}",
          "endPos": {
            "line": 91,
            "column": 9
          }
        },
        {
          "usedConstants": [],
          "tactic": "set \u03b9 := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a) with h\u03b9",
          "proofState": 59,
          "pos": {
            "line": 92,
            "column": 2
          },
          "goals": "case intro.intro\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nhV0 : \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9' V = {0}\nq : \u211a\n\u22a2 \u2203 U, IsOpen U \u2227 \u21d1(algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)) \u207b\u00b9' U = {q}",
          "endPos": {
            "line": 92,
            "column": 55
          }
        },
        {
          "usedConstants": [],
          "tactic": "set q\u2090 := \u03b9 q with hq\u2090",
          "proofState": 60,
          "pos": {
            "line": 93,
            "column": 2
          },
          "goals": "case intro.intro\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\n\u22a2 \u2203 U, IsOpen U \u2227 \u21d1\u03b9 \u207b\u00b9' U = {q}",
          "endPos": {
            "line": 93,
            "column": 50
          }
        },
        {
          "usedConstants": [],
          "tactic": "set f := Homeomorph.subLeft q\u2090 with hf",
          "proofState": 61,
          "pos": {
            "line": 94,
            "column": 2
          },
          "goals": "case intro.intro\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\n\u22a2 \u2203 U, IsOpen U \u2227 \u21d1\u03b9 \u207b\u00b9' U = {q}",
          "endPos": {
            "line": 94,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use f \u207b\u00b9' V, f.isOpen_preimage.mpr hV",
          "proofState": 62,
          "pos": {
            "line": 95,
            "column": 2
          },
          "goals": "case intro.intro\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\nf : AdeleRing (\ud835\udcde \u211a) \u211a \u2243\u209c AdeleRing (\ud835\udcde \u211a) \u211a := Homeomorph.subLeft q\u2090\nhf : f = Homeomorph.subLeft q\u2090\n\u22a2 \u2203 U, IsOpen U \u2227 \u21d1\u03b9 \u207b\u00b9' U = {q}",
          "endPos": {
            "line": 95,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "NumberField.AdeleRing.instTopologicalSpace",
            "NormedCommRing.toNormedRing",
            "NormedCommRing.toSeminormedCommRing",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "CommSemiring.toSemiring",
            "Rat",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "PseudoMetricSpace.toUniformSpace",
            "RingHom",
            "Rat.commSemiring",
            "Function.comp",
            "Algebra.id",
            "Set.instSingletonSet",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "NumberField.RingOfIntegers.instCommRing",
            "Field.toSemifield",
            "Rat.numberField",
            "Homeomorph.instEquivLike",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "Rat.instField",
            "Set.preimage",
            "Homeomorph.subLeft",
            "Homeomorph",
            "SeminormedCommRing.toSeminormedRing",
            "NumberField.AdeleRing",
            "NumberField.AdeleRing.instCommRing",
            "Semifield.toCommSemiring",
            "Rat.addGroup",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Singleton.singleton",
            "NumberField.RingOfIntegers",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.instTopologicalAddGroup",
            "letFun",
            "EquivLike.toFunLike",
            "Set"
          ],
          "tactic": "have : f \u2218 \u03b9 = \u03b9 \u2218 Homeomorph.subLeft q := by ext; simp [hf, hq\u2090]",
          "proofState": 63,
          "pos": {
            "line": 96,
            "column": 2
          },
          "goals": "case right\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\nf : AdeleRing (\ud835\udcde \u211a) \u211a \u2243\u209c AdeleRing (\ud835\udcde \u211a) \u211a := Homeomorph.subLeft q\u2090\nhf : f = Homeomorph.subLeft q\u2090\n\u22a2 \u21d1\u03b9 \u207b\u00b9' (\u21d1f \u207b\u00b9' V) = {q}",
          "endPos": {
            "line": 96,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext",
          "proofState": 64,
          "pos": {
            "line": 96,
            "column": 48
          },
          "goals": "V : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\nf : AdeleRing (\ud835\udcde \u211a) \u211a \u2243\u209c AdeleRing (\ud835\udcde \u211a) \u211a := Homeomorph.subLeft q\u2090\nhf : f = Homeomorph.subLeft q\u2090\n\u22a2 \u21d1f \u2218 \u21d1\u03b9 = \u21d1\u03b9 \u2218 \u21d1(Homeomorph.subLeft q)",
          "endPos": {
            "line": 96,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "NumberField.AdeleRing.instTopologicalSpace",
            "NumberField.AdeleRing.instTopologicalRing",
            "NormedCommRing.toNormedRing",
            "RingHom.instRingHomClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "RingHomClass.toAddMonoidHomClass",
            "NormedRing.toRing",
            "map_sub",
            "CommRing.toNonUnitalCommRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "LieRing.toAddCommGroup",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Rat",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "HSub.hSub",
            "RingHom",
            "Rat.commSemiring",
            "Function.comp",
            "Eq.rec",
            "Algebra.id",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "SubtractionMonoid.toSubNegMonoid",
            "NumberField.RingOfIntegers.instCommRing",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Field.toSemifield",
            "SubNegMonoid.toSub",
            "TopologicalSpace",
            "Rat.numberField",
            "Homeomorph.instEquivLike",
            "AddGroup",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "instHSub",
            "Rat.instNormedField",
            "Rat.instField",
            "AddGroup.toSubNegMonoid",
            "Homeomorph.subLeft",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "eq_self",
            "LieRing.ofAssociativeRing",
            "Homeomorph",
            "of_eq_true",
            "TopologicalRing.to_topologicalAddGroup",
            "NumberField.AdeleRing",
            "Eq.refl",
            "NumberField.AdeleRing.instCommRing",
            "Semifield.toCommSemiring",
            "Rat.addGroup",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "NumberField.RingOfIntegers",
            "TopologicalAddGroup",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "EquivLike.toFunLike"
          ],
          "tactic": "simp [hf, hq\u2090]",
          "proofState": 65,
          "pos": {
            "line": 96,
            "column": 53
          },
          "goals": "case h\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\nf : AdeleRing (\ud835\udcde \u211a) \u211a \u2243\u209c AdeleRing (\ud835\udcde \u211a) \u211a := Homeomorph.subLeft q\u2090\nhf : f = Homeomorph.subLeft q\u2090\nx\u271d : \u211a\n\u22a2 (\u21d1f \u2218 \u21d1\u03b9) x\u271d = (\u21d1\u03b9 \u2218 \u21d1(Homeomorph.subLeft q)) x\u271d",
          "endPos": {
            "line": 96,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "NumberField.AdeleRing.instTopologicalSpace",
            "NormedCommRing.toNormedRing",
            "Eq.mpr",
            "NormedRing.toRing",
            "NumberField.RingOfIntegers.instIsFractionRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "Rat",
            "NumberField.RingOfIntegers.instAlgebra_1",
            "RingHom",
            "Rat.commSemiring",
            "Function.comp",
            "Algebra.id",
            "Set.instSingletonSet",
            "id",
            "NumberField.RingOfIntegers.instIsDedekindDomain",
            "Set.preimage_comp",
            "NumberField.RingOfIntegers.instCommRing",
            "Field.toSemifield",
            "Rat.numberField",
            "Homeomorph.instEquivLike",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "Rat.instField",
            "Set.preimage",
            "Homeomorph",
            "NumberField.AdeleRing",
            "NumberField.AdeleRing.instCommRing",
            "Semifield.toCommSemiring",
            "NormedField.toNormedCommRing",
            "Singleton.singleton",
            "Eq.symm",
            "NumberField.RingOfIntegers",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "EquivLike.toFunLike",
            "Set"
          ],
          "tactic": "rw [\u2190 Set.preimage_comp, this, Set.preimage_comp, hV0]",
          "proofState": 66,
          "pos": {
            "line": 97,
            "column": 2
          },
          "goals": "case right\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\nf : AdeleRing (\ud835\udcde \u211a) \u211a \u2243\u209c AdeleRing (\ud835\udcde \u211a) \u211a := Homeomorph.subLeft q\u2090\nhf : f = Homeomorph.subLeft q\u2090\nthis : \u21d1f \u2218 \u21d1\u03b9 = \u21d1\u03b9 \u2218 \u21d1(Homeomorph.subLeft q)\n\u22a2 \u21d1\u03b9 \u207b\u00b9' (\u21d1f \u207b\u00b9' V) = {q}",
          "endPos": {
            "line": 97,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "Set.ext"
          ],
          "tactic": "ext",
          "proofState": 67,
          "pos": {
            "line": 98,
            "column": 2
          },
          "goals": "case right\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\nf : AdeleRing (\ud835\udcde \u211a) \u211a \u2243\u209c AdeleRing (\ud835\udcde \u211a) \u211a := Homeomorph.subLeft q\u2090\nhf : f = Homeomorph.subLeft q\u2090\nthis : \u21d1f \u2218 \u21d1\u03b9 = \u21d1\u03b9 \u2218 \u21d1(Homeomorph.subLeft q)\n\u22a2 \u21d1(Homeomorph.subLeft q) \u207b\u00b9' {0} = {q}",
          "endPos": {
            "line": 98,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "Rat.instOfNat",
            "NormedCommRing.toSeminormedCommRing",
            "congrArg",
            "Rat",
            "_auxLemma.1",
            "HSub.hSub",
            "PseudoMetricSpace.toUniformSpace",
            "Membership.mem",
            "Set.instSingletonSet",
            "iff_self",
            "_auxLemma.8",
            "SubNegMonoid.toSub",
            "Homeomorph.instEquivLike",
            "Iff",
            "instHSub",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Set.preimage",
            "Homeomorph.subLeft",
            "congr",
            "True",
            "_auxLemma.9",
            "Homeomorph",
            "SeminormedCommRing.toSeminormedRing",
            "of_eq_true",
            "_auxLemma.4",
            "Rat.addGroup",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Singleton.singleton",
            "OfNat.ofNat",
            "UniformSpace.toTopologicalSpace",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Rat.instTopologicalAddGroup",
            "Eq.trans",
            "EquivLike.toFunLike",
            "Set"
          ],
          "tactic": "simp only [Set.mem_preimage, Homeomorph.subLeft_apply, Set.mem_singleton_iff, sub_eq_zero, eq_comm]",
          "proofState": 68,
          "pos": {
            "line": 99,
            "column": 2
          },
          "goals": "case right.h\nV : Set (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV : IsOpen V\nq : \u211a\n\u03b9 : \u211a \u2192+* AdeleRing (\ud835\udcde \u211a) \u211a := algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nhV0 : \u21d1\u03b9 \u207b\u00b9' V = {0}\nh\u03b9 : \u03b9 = algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)\nq\u2090 : AdeleRing (\ud835\udcde \u211a) \u211a := \u03b9 q\nhq\u2090 : q\u2090 = \u03b9 q\nf : AdeleRing (\ud835\udcde \u211a) \u211a \u2243\u209c AdeleRing (\ud835\udcde \u211a) \u211a := Homeomorph.subLeft q\u2090\nhf : f = Homeomorph.subLeft q\u2090\nthis : \u21d1f \u2218 \u21d1\u03b9 = \u21d1\u03b9 \u2218 \u21d1(Homeomorph.subLeft q)\nx\u271d : \u211a\n\u22a2 x\u271d \u2208 \u21d1(Homeomorph.subLeft q) \u207b\u00b9' {0} \u2194 x\u271d \u2208 {q}",
          "endPos": {
            "line": 99,
            "column": 101
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 16,
            "column": 2
          },
          "goal": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 LocallyCompactSpace (AdeleRing (\ud835\udcde K) K)",
          "endPos": {
            "line": 16,
            "column": 7
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 30,
            "column": 4
          },
          "goal": "case h.refine_1\n\u22a2 IsOpen\n    ({f | \u2200 (v : InfinitePlace \u211a), f v \u2208 Metric.ball 0 1} \u00d7\u02e2\n      {f |\n        \u2200 (v : IsDedekindDomain.HeightOneSpectrum (\ud835\udcde \u211a)),\n          \u2191f v \u2208 IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers \u211a v})",
          "endPos": {
            "line": 30,
            "column": 9
          }
        },
        {
          "proofState": 2,
          "pos": {
            "line": 105,
            "column": 65
          },
          "goal": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 \u2200 (k : K), \u2203 U, IsOpen U \u2227 \u21d1(algebraMap K (AdeleRing (\ud835\udcde K) K)) \u207b\u00b9' U = {k}",
          "endPos": {
            "line": 105,
            "column": 70
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 115,
            "column": 2
          },
          "goal": "\u22a2 CompactSpace (AdeleRing (\ud835\udcde \u211a) \u211a \u29f8 (algebraMap \u211a (AdeleRing (\ud835\udcde \u211a) \u211a)).toAddMonoidHom.range)",
          "endPos": {
            "line": 115,
            "column": 7
          }
        },
        {
          "proofState": 4,
          "pos": {
            "line": 121,
            "column": 2
          },
          "goal": "K : Type u_1\ninst\u271d\u00b9 : Field K\ninst\u271d : NumberField K\n\u22a2 CompactSpace (AdeleRing (\ud835\udcde K) K \u29f8 (algebraMap K (AdeleRing (\ud835\udcde K) K)).toAddMonoidHom.range)",
          "endPos": {
            "line": 121,
            "column": 7
          }
        },
        {
          "proofState": 5,
          "pos": {
            "line": 136,
            "column": 2
          },
          "goal": "K : Type u_1\nL : Type u_2\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : NumberField K\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : NumberField L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : Algebra K (AdeleRing (\ud835\udcde L) L)\ninst\u271d : IsScalarTower K L (AdeleRing (\ud835\udcde L) L)\n\u22a2 AdeleRing (\ud835\udcde K) K \u2192A[K] AdeleRing (\ud835\udcde L) L",
          "endPos": {
            "line": 136,
            "column": 7
          }
        },
        {
          "proofState": 6,
          "pos": {
            "line": 149,
            "column": 2
          },
          "goal": "K : Type u_1\nL : Type u_2\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : NumberField K\ninst\u271d\u2074 : Field L\ninst\u271d\u00b3 : NumberField L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : Algebra K (AdeleRing (\ud835\udcde L) L)\ninst\u271d : IsScalarTower K L (AdeleRing (\ud835\udcde L) L)\n\u22a2 L \u2297[K] AdeleRing (\ud835\udcde K) K \u2243A[L]AdeleRing (\ud835\udcde L) L",
          "endPos": {
            "line": 149,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 15,
            "column": 9
          },
          "endPos": {
            "line": 15,
            "column": 50
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 24,
            "column": 8
          },
          "endPos": {
            "line": 24,
            "column": 35
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 104,
            "column": 8
          },
          "endPos": {
            "line": 104,
            "column": 38
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 113,
            "column": 8
          },
          "endPos": {
            "line": 113,
            "column": 31
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 119,
            "column": 8
          },
          "endPos": {
            "line": 119,
            "column": 39
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 134,
            "column": 18
          },
          "endPos": {
            "line": 134,
            "column": 50
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 147,
            "column": 4
          },
          "endPos": {
            "line": 147,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/AutomorphicRepresentation/Example.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [],
          "tactic": "simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.mul_apply] at *",
          "proofState": 7,
          "pos": {
            "line": 32,
            "column": 4
          },
          "goals": "a b : (n : \u2115+) \u2192 ZMod \u2191n\nha : a \u2208 {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}\nhb : b \u2208 {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}\n\u22a2 a * b \u2208 {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}",
          "endPos": {
            "line": 32,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "PNat"
          ],
          "tactic": "intro D N hD",
          "proofState": 8,
          "pos": {
            "line": 33,
            "column": 4
          },
          "goals": "a b : (n : \u2115+) \u2192 ZMod \u2191n\nha : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (a N).cast = a D\nhb : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (b N).cast = b D\n\u22a2 \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (a N * b N).cast = a D * b D",
          "endPos": {
            "line": 33,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "ZMod.cast",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "Ring.toNonAssocRing",
            "congrArg",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "ZMod",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Distrib.toMul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "CommRing.toRing",
            "Eq",
            "Ring.toAddGroupWithOne",
            "ZMod.cast_mul",
            "instHMul"
          ],
          "tactic": "rw [ZMod.cast_mul hD, ha _ _ hD, hb _ _ hD]",
          "proofState": 9,
          "pos": {
            "line": 34,
            "column": 4
          },
          "goals": "a b : (n : \u2115+) \u2192 ZMod \u2191n\nha : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (a N).cast = a D\nhb : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (b N).cast = b D\nD N : \u2115+\nhD : \u2191D \u2223 \u2191N\n\u22a2 (a N * b N).cast = a D * b D",
          "endPos": {
            "line": 34,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "ZMod.cast",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "Ring.toNonAssocRing",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "setOf",
            "RingHom",
            "Membership.mem",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocSemiring.toMulZeroOneClass",
            "ZMod",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "MulZeroOneClass.toMulOneClass",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "ZMod.charP",
            "Nat.instDvd",
            "Distrib.toMul",
            "Nat",
            "Pi.ring",
            "MulOneClass.toOne",
            "Subsemigroup.carrier",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "ZMod.cast_mul",
            "instHMul",
            "PNat",
            "ZMod.castHom",
            "Set"
          ],
          "tactic": "simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.one_apply]",
          "proofState": 10,
          "pos": {
            "line": 28,
            "column": 4
          },
          "goals": "\u22a2 1 \u2208 { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 28,
            "column": 66
          }
        },
        {
          "usedConstants": [
            "PNat"
          ],
          "tactic": "intro D N hD",
          "proofState": 11,
          "pos": {
            "line": 29,
            "column": 4
          },
          "goals": "\u22a2 \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 ZMod.cast 1 = 1",
          "endPos": {
            "line": 29,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "ZMod.cast_one",
            "ZMod.cast",
            "ZMod.commRing",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "NonAssocSemiring.toMulZeroOneClass",
            "ZMod",
            "MulZeroOneClass.toMulOneClass",
            "AddMonoidWithOne.toOne",
            "MulOneClass.toOne",
            "One.toOfNat1",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "PNat"
          ],
          "tactic": "rw [ZMod.cast_one hD]",
          "proofState": 12,
          "pos": {
            "line": 30,
            "column": 4
          },
          "goals": "D N : \u2115+\nhD : \u2191D \u2223 \u2191N\n\u22a2 ZMod.cast 1 = 1",
          "endPos": {
            "line": 30,
            "column": 25
          }
        },
        {
          "usedConstants": [],
          "tactic": "simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.add_apply] at *",
          "proofState": 13,
          "pos": {
            "line": 24,
            "column": 4
          },
          "goals": "a b : (n : \u2115+) \u2192 ZMod \u2191n\nha :\n  a \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := \u22ef,\n        one_mem' := \u22ef }.carrier\nhb :\n  b \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := \u22ef,\n        one_mem' := \u22ef }.carrier\n\u22a2 a + b \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := \u22ef,\n        one_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 24,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "PNat"
          ],
          "tactic": "intro D N hD",
          "proofState": 14,
          "pos": {
            "line": 25,
            "column": 4
          },
          "goals": "a b : (n : \u2115+) \u2192 ZMod \u2191n\nha : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (a N).cast = a D\nhb : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (b N).cast = b D\n\u22a2 \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (a N + b N).cast = a D + b D",
          "endPos": {
            "line": 25,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "ZMod.cast",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "Ring.toNonAssocRing",
            "congrArg",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "ZMod",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "HAdd.hAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "CommRing.toRing",
            "Eq",
            "Ring.toAddGroupWithOne",
            "ZMod.cast_add"
          ],
          "tactic": "rw [ZMod.cast_add hD, ha _ _ hD, hb _ _ hD]",
          "proofState": 15,
          "pos": {
            "line": 26,
            "column": 4
          },
          "goals": "a b : (n : \u2115+) \u2192 ZMod \u2191n\nha : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (a N).cast = a D\nhb : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (b N).cast = b D\nD N : \u2115+\nhD : \u2191D \u2223 \u2191N\n\u22a2 (a N + b N).cast = a D + b D",
          "endPos": {
            "line": 26,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "ZMod.cast",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "ZMod",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "ZMod.cast_zero",
            "Nat.instDvd",
            "implies_congr",
            "Nat",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Semiring.toNonUnitalSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "AddCommMonoid.toAddMonoid",
            "implies_true",
            "CommRing.toRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Ring.toSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "forall_congr",
            "PNat"
          ],
          "tactic": "simp",
          "proofState": 16,
          "pos": {
            "line": 18,
            "column": 18
          },
          "goals": "\u22a2 0 \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := \u22ef,\n        one_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 18,
            "column": 22
          }
        },
        {
          "usedConstants": [],
          "tactic": "simp only [ZMod.castHom_apply, Set.mem_setOf_eq, Pi.neg_apply] at *",
          "proofState": 17,
          "pos": {
            "line": 20,
            "column": 4
          },
          "goals": "x : (n : \u2115+) \u2192 ZMod \u2191n\nhx :\n  x \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := \u22ef, one_mem' := \u22ef,\n        add_mem' := \u22ef, zero_mem' := \u22ef }.carrier\n\u22a2 -x \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := \u22ef, one_mem' := \u22ef,\n        add_mem' := \u22ef, zero_mem' := \u22ef }.carrier",
          "endPos": {
            "line": 20,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "forall_imp"
          ],
          "tactic": "peel hx with D N hD hx",
          "proofState": 18,
          "pos": {
            "line": 21,
            "column": 4
          },
          "goals": "x : (n : \u2115+) \u2192 ZMod \u2191n\nhx : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (x N).cast = x D\n\u22a2 \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (-x N).cast = -x D",
          "endPos": {
            "line": 21,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "ZMod.cast",
            "ZMod.commRing",
            "congrArg",
            "AddCommGroup.toAddGroup",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "ZMod",
            "AddGroup.toSubNegMonoid",
            "Ring.toAddCommGroup",
            "SubNegMonoid.toNeg",
            "ZMod.cast_neg",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg"
          ],
          "tactic": "rw [ZMod.cast_neg hD, hx]",
          "proofState": 19,
          "pos": {
            "line": 22,
            "column": 4
          },
          "goals": "case h.h.h\nx : (n : \u2115+) \u2192 ZMod \u2191n\nhx\u271d : \u2200 (D N : \u2115+), \u2191D \u2223 \u2191N \u2192 (x N).cast = x D\nD N : \u2115+\nhD : \u2191D \u2223 \u2191N\nhx : (x N).cast = x D\n\u22a2 (-x N).cast = -x D",
          "endPos": {
            "line": 22,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZHat.proof_1",
            "Dvd.dvd",
            "ZMod.cast",
            "Subring.instSetLike",
            "ZMod.commRing",
            "MulOneClass.toMul",
            "Subsemigroup.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "setOf",
            "RingHom",
            "Membership.mem",
            "Subtype",
            "NonAssocSemiring.toMulZeroOneClass",
            "ZHat.proof_6",
            "ZHat.proof_2",
            "ZMod",
            "MulZeroOneClass.toMulOneClass",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Nat.instDvd",
            "Subring",
            "Nat",
            "Pi.ring",
            "True",
            "Subsemiring.mk",
            "eq_self",
            "ZHat.proof_3",
            "of_eq_true",
            "Submonoid.mk",
            "implies_true",
            "ZHat",
            "CommRing.toRing",
            "ZHat.proof_4",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "ZHat.proof_5",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "implies_congr_ctx",
            "Subring.mk",
            "SetLike.instMembership",
            "Eq.trans",
            "Mathlib.Data.SetLike.Basic._auxLemma.4",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "simp_all",
          "proofState": 20,
          "pos": {
            "line": 42,
            "column": 27
          },
          "goals": "M N : ZHat\n\u22a2 (fun z => \u2191z) M = (fun z => \u2191z) N \u2192 M = N",
          "endPos": {
            "line": 42,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddMonoidWithOne.toOne",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero"
          ],
          "tactic": "intro h",
          "proofState": 21,
          "pos": {
            "line": 60,
            "column": 2
          },
          "goals": "\u22a2 0 \u2260 1",
          "endPos": {
            "line": 60,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "False",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "instOfNatPNatOfNeZeroNat",
            "instOfNatNat",
            "ZMod",
            "AddMonoidWithOne.toOne",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.instNeZeroSucc",
            "Nat",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "MulZeroClass.toZero",
            "PNat"
          ],
          "tactic": "have h2 : (0 : ZHat) 2 = (1 : ZHat) 2 := by simp [h]",
          "proofState": 22,
          "pos": {
            "line": 61,
            "column": 2
          },
          "goals": "h : 0 = 1\n\u22a2 False",
          "endPos": {
            "line": 61,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "instOfNatPNatOfNeZeroNat",
            "instOfNatNat",
            "ZMod",
            "AddMonoidWithOne.toOne",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.instNeZeroSucc",
            "Nat",
            "True",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "PNat"
          ],
          "tactic": "simp [h]",
          "proofState": 23,
          "pos": {
            "line": 61,
            "column": 46
          },
          "goals": "h : 0 = 1\n\u22a2 0 2 = 1 2",
          "endPos": {
            "line": 61,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Eq.mp",
            "instOfNatPNatOfNeZeroNat",
            "instOfNatNat",
            "ZMod",
            "AddMonoidWithOne.toOne",
            "instZHatCommRing",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.instNeZeroSucc",
            "Nat",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "ZHat.zero_val",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "PNat"
          ],
          "tactic": "rw [zero_val, one_val] at h2",
          "proofState": 24,
          "pos": {
            "line": 62,
            "column": 2
          },
          "goals": "h : 0 = 1\nh2 : 0 2 = 1 2\n\u22a2 False",
          "endPos": {
            "line": 62,
            "column": 30
          }
        },
        {
          "usedConstants": [],
          "tactic": "revert h2",
          "proofState": 25,
          "pos": {
            "line": 63,
            "column": 2
          },
          "goals": "h : 0 = 1\nh2 : 0 = 1\n\u22a2 False",
          "endPos": {
            "line": 63,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "False",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "of_decide_eq_true",
            "ZMod.commRing",
            "ZMod.decidableEq",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "instOfNatPNatOfNeZeroNat",
            "forall_prop_decidable",
            "instOfNatNat",
            "ZMod",
            "AddMonoidWithOne.toOne",
            "Bool.true",
            "Nat.instNeZeroSucc",
            "Nat",
            "instDecidableFalse",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Decidable.decide",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "PNat"
          ],
          "tactic": "decide",
          "proofState": 26,
          "pos": {
            "line": 63,
            "column": 14
          },
          "goals": "h : 0 = 1\n\u22a2 0 = 1 \u2192 False",
          "endPos": {
            "line": 63,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "ZHat.ext_iff",
            "Eq.mp",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "propext",
            "ZHat",
            "CommRing.toRing",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "PNat"
          ],
          "tactic": "rw [ZHat.ext_iff] at h",
          "proofState": 27,
          "pos": {
            "line": 68,
            "column": 2
          },
          "goals": "a b : \u2115\nh : \u2191a = \u2191b\n\u22a2 a = b",
          "endPos": {
            "line": 68,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Nat.instMax_mathlib",
            "instOfNatNat",
            "Subtype.mk",
            "Max.max",
            "Nat",
            "Nat.succ_pos",
            "LT.lt",
            "instLTNat",
            "OfNat.ofNat",
            "Nat.succ"
          ],
          "tactic": "specialize h \u27e8_, (max a b).succ_pos\u27e9",
          "proofState": 28,
          "pos": {
            "line": 69,
            "column": 2
          },
          "goals": "a b : \u2115\nh : \u2200 (n : \u2115+), \u2191a n = \u2191b n\n\u22a2 a = b",
          "endPos": {
            "line": 69,
            "column": 38
          }
        },
        {
          "usedConstants": [],
          "tactic": "apply_fun ZMod.val at h",
          "proofState": 29,
          "pos": {
            "line": 70,
            "column": 2
          },
          "goals": "a b : \u2115\nh : \u2191a \u27e8(a \u2294 b).succ, \u22ef\u27e9 = \u2191b \u27e8(a \u2294 b).succ, \u22ef\u27e9\n\u22a2 a = b",
          "endPos": {
            "line": 70,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZMod.commRing",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Eq.mp",
            "Nat.instMax_mathlib",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "ZMod",
            "Subtype.mk",
            "instZHatCommRing",
            "ZHat.instDFunLikePNatZModVal",
            "Max.max",
            "Nat",
            "Nat.succ_pos",
            "LT.lt",
            "ZHat",
            "instLTNat",
            "ZHat.natCast_val",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Nat.succ",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "rwa [natCast_val, ZMod.val_cast_of_lt, natCast_val, ZMod.val_cast_of_lt] at h",
          "proofState": 30,
          "pos": {
            "line": 71,
            "column": 2
          },
          "goals": "a b : \u2115\nh : (\u2191a \u27e8(a \u2294 b).succ, \u22ef\u27e9).val = (\u2191b \u27e8(a \u2294 b).succ, \u22ef\u27e9).val\n\u22a2 a = b",
          "endPos": {
            "line": 71,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Nat.instLattice",
            "Lattice.toSemilatticeSup",
            "_auxLemma.1",
            "Nat.instMax_mathlib",
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "Mathlib.Order.Lattice._auxLemma.2",
            "instHAdd",
            "HAdd.hAdd",
            "Max.max",
            "Nat",
            "LT.lt",
            "True",
            "of_eq_true",
            "instAddNat",
            "instLTNat",
            "OfNat.ofNat",
            "Eq.trans"
          ],
          "tactic": "simp [Nat.succ_eq_add_one, Nat.lt_add_one_iff]",
          "proofState": 31,
          "pos": {
            "line": 72,
            "column": 4
          },
          "goals": "a b : \u2115\nh : a = (\u2191b).val\n\u22a2 b < \u2191\u27e8(a \u2294 b).succ, \u22ef\u27e9",
          "endPos": {
            "line": 72,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "Nat.instLattice",
            "Lattice.toSemilatticeSup",
            "Mathlib.Order.Lattice._auxLemma.1",
            "_auxLemma.1",
            "Nat.instMax_mathlib",
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "instHAdd",
            "HAdd.hAdd",
            "Max.max",
            "Nat",
            "LT.lt",
            "True",
            "of_eq_true",
            "instAddNat",
            "instLTNat",
            "OfNat.ofNat",
            "Eq.trans"
          ],
          "tactic": "simp [Nat.succ_eq_add_one, Nat.lt_add_one_iff]",
          "proofState": 32,
          "pos": {
            "line": 73,
            "column": 4
          },
          "goals": "a b : \u2115\nh : (\u2191a).val = (\u2191b \u27e8(a \u2294 b).succ, \u22ef\u27e9).val\n\u22a2 a < \u2191\u27e8(a \u2294 b).succ, \u22ef\u27e9",
          "endPos": {
            "line": 73,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Dvd.dvd",
            "Nat.instDvd",
            "Nat",
            "PNat"
          ],
          "tactic": "intros D N hDN",
          "proofState": 33,
          "pos": {
            "line": 80,
            "column": 2
          },
          "goals": "\u22a2 (fun n => \u2211 i \u2208 range \u2191n, \u2191i !) \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := @proof_2,\n      one_mem' := proof_3, add_mem' := @proof_4, zero_mem' := proof_5, neg_mem' := @proof_6 }",
          "endPos": {
            "line": 80,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "ZHat.proof_1",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "RingHom",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "Finset.range",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Nat.factorial",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "dsimp only",
          "proofState": 34,
          "pos": {
            "line": 81,
            "column": 2
          },
          "goals": "D N : \u2115+\nhDN : \u2191D \u2223 \u2191N\n\u22a2 (ZMod.castHom hDN (ZMod \u2191D)) ((fun n => \u2211 i \u2208 range \u2191n, \u2191i !) N) = (fun n => \u2211 i \u2208 range \u2191n, \u2191i !) D",
          "endPos": {
            "line": 81,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "ExistsAddOfLE.exists_add_of_le",
            "PNat.pos",
            "Nat.le_of_dvd"
          ],
          "tactic": "obtain \u27e8k, hk\u27e9 := exists_add_of_le <| le_of_dvd N.pos hDN",
          "proofState": 35,
          "pos": {
            "line": 82,
            "column": 2
          },
          "goals": "D N : \u2115+\nhDN : \u2191D \u2223 \u2191N\n\u22a2 (ZMod.castHom hDN (ZMod \u2191D)) (\u2211 i \u2208 range \u2191N, \u2191i !) = \u2211 i \u2208 range \u2191D, \u2191i !",
          "endPos": {
            "line": 82,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "RingHom.instRingHomClass",
            "ZHat.proof_1",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "RingHomClass.toAddMonoidHomClass",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "RingHom",
            "id",
            "AddMonoidWithOne.toNatCast",
            "map_sum",
            "Nat.cast",
            "ZMod",
            "Finset.range",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Nat.factorial",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "ZMod.castHom"
          ],
          "tactic": "simp_rw [map_sum, map_natCast, hk, sum_range_add, add_right_eq_self]",
          "proofState": 36,
          "pos": {
            "line": 83,
            "column": 2
          },
          "goals": "case intro\nD N : \u2115+\nhDN : \u2191D \u2223 \u2191N\nk : \u2115\nhk : \u2191N = \u2191D + k\n\u22a2 (ZMod.castHom hDN (ZMod \u2191D)) (\u2211 i \u2208 range \u2191N, \u2191i !) = \u2211 i \u2208 range \u2191D, \u2191i !",
          "endPos": {
            "line": 83,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "Finset",
            "Finset.sum_eq_zero",
            "Membership.mem",
            "AddMonoidWithOne.toNatCast",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Finset.instMembership",
            "Nat.cast",
            "ZMod",
            "Finset.range",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "instAddNat",
            "Semiring.toNonAssocSemiring"
          ],
          "tactic": "refine sum_eq_zero (fun i _ => ?_)",
          "proofState": 37,
          "pos": {
            "line": 84,
            "column": 2
          },
          "goals": "case intro\nD N : \u2115+\nhDN : \u2191D \u2223 \u2191N\nk : \u2115\nhk : \u2191N = \u2191D + k\n\u22a2 \u2211 x \u2208 range k, \u2191(\u2191D + x)! = 0",
          "endPos": {
            "line": 84,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "instHAdd",
            "Nat.instDvd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "AddZeroClass.toZero",
            "propext",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "instAddNat",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "ZMod.natCast_zmod_eq_zero_iff_dvd",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [ZMod.natCast_zmod_eq_zero_iff_dvd]",
          "proofState": 38,
          "pos": {
            "line": 85,
            "column": 2
          },
          "goals": "case intro\nD N : \u2115+\nhDN : \u2191D \u2223 \u2191N\nk : \u2115\nhk : \u2191N = \u2191D + k\ni : \u2115\nx\u271d : i \u2208 range k\n\u22a2 \u2191(\u2191D + i)! = 0",
          "endPos": {
            "line": 85,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Nat.instCanonicallyOrderedAdd",
            "Nat.dvd_factorial",
            "instLENat",
            "instHAdd",
            "HAdd.hAdd",
            "PNat.pos",
            "Nat",
            "instAddNat",
            "le_self_add"
          ],
          "tactic": "exact Nat.dvd_factorial D.pos le_self_add",
          "proofState": 39,
          "pos": {
            "line": 86,
            "column": 2
          },
          "goals": "case intro\nD N : \u2115+\nhDN : \u2191D \u2223 \u2191N\nk : \u2115\nhk : \u2191N = \u2191D + k\ni : \u2115\nx\u271d : i \u2208 range k\n\u22a2 \u2191D \u2223 (\u2191D + i)!",
          "endPos": {
            "line": 86,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "instHSMul",
            "Trans.trans",
            "HMul.hMul",
            "congrArg",
            "Nat.factorial_succ",
            "Finset.card_range",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "Mul.toSMul",
            "Finset.card",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "AddMonoid.toNatSMul",
            "Eq.refl",
            "HSMul.hSMul",
            "AddCommMonoid.toAddMonoid",
            "instTransEq_1",
            "instLTNat",
            "smul_eq_mul",
            "OfNat.ofNat",
            "Eq",
            "Finset.sum",
            "Finset.sum_const",
            "instHMul"
          ],
          "tactic": "calc\n  \u2211 i \u2208 range (j + 1), i ! < \u2211 _i \u2208 range (j + 1), j ! := ?_\n  _ = (j + 1) * (j !) := by rw [sum_const, card_range, smul_eq_mul]\n  _ = (j + 1)! := Nat.factorial_succ _",
          "proofState": 40,
          "pos": {
            "line": 95,
            "column": 2
          },
          "goals": "j : \u2115\nhj : 1 < j\n\u22a2 \u2211 i \u2208 range (j + 1), i ! < (j + 1)!",
          "endPos": {
            "line": 98,
            "column": 40
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  \u2211 i \u2208 range (j + 1), i ! < \u2211 _i \u2208 range (j + 1), j ! := ?_\n  _ = (j + 1) * (j !) := by rw [sum_const, card_range, smul_eq_mul]\n  _ = (j + 1)! := Nat.factorial_succ _",
          "proofState": 41,
          "pos": {
            "line": 96,
            "column": 4
          },
          "goals": "no goals",
          "endPos": {
            "line": 98,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "instHSMul",
            "HMul.hMul",
            "congrArg",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "Finset.card",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "AddMonoid.toNatSMul",
            "HSMul.hSMul",
            "AddCommMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Eq",
            "Finset.sum",
            "Finset.sum_const",
            "instHMul"
          ],
          "tactic": "rw [sum_const, card_range, smul_eq_mul]",
          "proofState": 42,
          "pos": {
            "line": 97,
            "column": 30
          },
          "goals": "j : \u2115\nhj : 1 < j\n\u22a2 \u2211 _i \u2208 range (j + 1), j ! = (j + 1) * j !",
          "endPos": {
            "line": 97,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "Finset",
            "Membership.mem",
            "instOfNatNat",
            "Finset.instMembership",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "Nat.instStrictOrderedSemiring",
            "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
            "Nat.factorial_le",
            "instAddNat",
            "Finset.sum_lt_sum",
            "OfNat.ofNat"
          ],
          "tactic": "apply sum_lt_sum (fun i hi => factorial_le <| by simpa only [mem_range, lt_succ] using hi) ?_",
          "proofState": 43,
          "pos": {
            "line": 99,
            "column": 2
          },
          "goals": "j : \u2115\nhj : 1 < j\n\u22a2 \u2211 i \u2208 range (j + 1), i ! < \u2211 _i \u2208 range (j + 1), j !",
          "endPos": {
            "line": 99,
            "column": 95
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa only [mem_range, lt_succ] using hi",
          "proofState": 44,
          "pos": {
            "line": 99,
            "column": 51
          },
          "goals": "j : \u2115\nhj : 1 < j\ni : \u2115\nhi : i \u2208 range (j + 1)\n\u22a2 i \u2264 j",
          "endPos": {
            "line": 99,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use 0",
          "proofState": 45,
          "pos": {
            "line": 100,
            "column": 2
          },
          "goals": "j : \u2115\nhj : 1 < j\n\u22a2 \u2203 i \u2208 range (j + 1), i ! < j !",
          "endPos": {
            "line": 100,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
            "Preorder.toLT",
            "congrArg",
            "Finset",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "Membership.mem",
            "id",
            "instOfNatNat",
            "Finset.instMembership",
            "Finset.range",
            "instHAdd",
            "And",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "Nat.instStrictOrderedSemiring",
            "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
            "instAddNat",
            "Nat.factorial_zero",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [factorial_zero]",
          "proofState": 46,
          "pos": {
            "line": 101,
            "column": 2
          },
          "goals": "case h\nj : \u2115\nhj : 1 < j\n\u22a2 0 \u2208 range (j + 1) \u2227 0! < j !",
          "endPos": {
            "line": 101,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
            "Mathlib.Data.Nat.Factorial.Basic._auxLemma.1",
            "Eq.mpr",
            "Nat.instCanonicallyOrderedAdd",
            "Preorder.toLT",
            "OrderedAddCommMonoid.toAddLeftMono",
            "congrArg",
            "and_self",
            "Finset",
            "Init.Data.Nat.Basic._auxLemma.14",
            "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.17",
            "covariant_swap_add_of_covariant_add",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddCancelMonoid.toIsCancelAdd",
            "Preorder.toLE",
            "Nat.instAddMonoid",
            "Membership.mem",
            "Nat.instAddCancelCommMonoid",
            "instOfNatNat",
            "Finset.instMembership",
            "LE.le",
            "OrderedCancelAddCommMonoid.toAddLeftReflectLT",
            "Finset.range",
            "Mathlib.Algebra.Order.Monoid.Unbundled.Basic._auxLemma.25",
            "Mathlib.Algebra.Order.Monoid.Canonical.Defs._auxLemma.9",
            "instHAdd",
            "And",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat.instPreorder",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "LT.lt",
            "Nat.instStrictOrderedSemiring",
            "True",
            "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
            "Nat.instPartialOrder",
            "eq_true",
            "of_eq_true",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "Zero.toOfNat0",
            "contravariant_swap_add_of_contravariant_add",
            "AddCommMonoid.toAddMonoid",
            "Or",
            "instLTNat",
            "OfNat.ofNat",
            "or_true",
            "AddZeroClass.toAdd",
            "Mathlib.Data.Finset.Range._auxLemma.1",
            "Eq",
            "AddCancelCommMonoid.toAddCancelMonoid",
            "IsCancelAdd.toIsRightCancelAdd",
            "Nat.instAddCommSemigroup",
            "rfl",
            "Eq.trans",
            "Nat.instOrderedSemiring"
          ],
          "tactic": "simp [hj]",
          "proofState": 47,
          "pos": {
            "line": 102,
            "column": 2
          },
          "goals": "case h\nj : \u2115\nhj : 1 < j\n\u22a2 0 \u2208 range (j + 1) \u2227 1 < j !",
          "endPos": {
            "line": 102,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "Nat.le_induction",
            "Nat",
            "OfNat.ofNat"
          ],
          "tactic": "induction j, hj using Nat.le_induction with\n| base => simp [sum_range_succ, factorial_succ]\n| succ j hj ih =>\n  rw [two_mul] at ih \u22a2\n  rw [sum_range_succ]\n  gcongr\n  apply sum_factorial_lt_factorial_succ\n  omega",
          "proofState": 48,
          "pos": {
            "line": 106,
            "column": 2
          },
          "goals": "j : \u2115\nhj : 3 \u2264 j\n\u22a2 \u2211 i \u2208 range (j + 1), i ! < 2 * j !",
          "endPos": {
            "line": 113,
            "column": 9
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction j, hj using Nat.le_induction with\n| base => simp [sum_range_succ, factorial_succ]\n| succ j hj ih =>\n  rw [two_mul] at ih \u22a2\n  rw [sum_range_succ]\n  gcongr\n  apply sum_factorial_lt_factorial_succ\n  omega",
          "proofState": 49,
          "pos": {
            "line": 106,
            "column": 2
          },
          "goals": "j : \u2115\nhj : 3 \u2264 j\n\u22a2 \u2211 i \u2208 range (j + 1), i ! < 2 * j !",
          "endPos": {
            "line": 113,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "HMul.hMul",
            "congrArg",
            "Finset",
            "AddMonoid.toAddZeroClass",
            "Nat.instMulOneClass",
            "Nat.instAddMonoid",
            "instMulNat",
            "instOfNatNat",
            "zero_add",
            "Finset.sum_singleton",
            "Finset.range",
            "Bool.true",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "eq_true_of_decide",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "LT.lt",
            "True",
            "Bool",
            "of_eq_true",
            "Nat.decLt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "Zero.toOfNat0",
            "Eq.refl",
            "AddCommMonoid.toAddMonoid",
            "instLTNat",
            "mul_one",
            "Finset.instSingleton",
            "Singleton.singleton",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Finset.sum_range_succ",
            "Finset.sum",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp [sum_range_succ, factorial_succ]",
          "proofState": 50,
          "pos": {
            "line": 107,
            "column": 12
          },
          "goals": "case base\nj : \u2115\n\u22a2 \u2211 i \u2208 range (3 + 1), i ! < 2 * 3!",
          "endPos": {
            "line": 107,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "congrArg",
            "two_mul",
            "Eq.mp",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.instNonAssocSemiring",
            "Finset.range",
            "instHAdd",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat.factorial",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "LT.lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instLTNat",
            "OfNat.ofNat",
            "instOfNatAtLeastTwo",
            "Finset.sum",
            "instHMul"
          ],
          "tactic": "rw [two_mul] at ih \u22a2",
          "proofState": 51,
          "pos": {
            "line": 109,
            "column": 4
          },
          "goals": "case succ\nj\u271d j : \u2115\nhj : 3 \u2264 j\nih : \u2211 i \u2208 range (j + 1), i ! < 2 * j !\n\u22a2 \u2211 i \u2208 range (j + 1 + 1), i ! < 2 * (j + 1)!",
          "endPos": {
            "line": 109,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "id",
            "Distrib.toAdd",
            "instOfNatNat",
            "Nat.instNonAssocSemiring",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "LT.lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "AddCommMonoid.toAddMonoid",
            "instLTNat",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Finset.sum_range_succ",
            "Finset.sum"
          ],
          "tactic": "rw [sum_range_succ]",
          "proofState": 52,
          "pos": {
            "line": 110,
            "column": 4
          },
          "goals": "case succ\nj\u271d j : \u2115\nhj : 3 \u2264 j\nih : \u2211 i \u2208 range (j + 1), i ! < j ! + j !\n\u22a2 \u2211 i \u2208 range (j + 1 + 1), i ! < (j + 1)! + (j + 1)!",
          "endPos": {
            "line": 110,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "add_lt_add_right"
          ],
          "tactic": "gcongr",
          "proofState": 53,
          "pos": {
            "line": 111,
            "column": 4
          },
          "goals": "case succ\nj\u271d j : \u2115\nhj : 3 \u2264 j\nih : \u2211 i \u2208 range (j + 1), i ! < j ! + j !\n\u22a2 \u2211 x \u2208 range (j + 1), x ! + (j + 1)! < (j + 1)! + (j + 1)!",
          "endPos": {
            "line": 111,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "Nat.sum_factorial_lt_factorial_succ"
          ],
          "tactic": "apply sum_factorial_lt_factorial_succ",
          "proofState": 54,
          "pos": {
            "line": 112,
            "column": 4
          },
          "goals": "case succ.bc\nj\u271d j : \u2115\nhj : 3 \u2264 j\nih : \u2211 i \u2208 range (j + 1), i ! < j ! + j !\n\u22a2 \u2211 x \u2208 range (j + 1), x ! < (j + 1)!",
          "endPos": {
            "line": 112,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega",
          "proofState": 55,
          "pos": {
            "line": 113,
            "column": 4
          },
          "goals": "case succ.bc.hj\nj\u271d j : \u2115\nhj : 3 \u2264 j\nih : \u2211 i \u2208 range (j + 1), i ! < j ! + j !\n\u22a2 1 < j",
          "endPos": {
            "line": 113,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "instHAdd",
            "HAdd.hAdd",
            "Nat",
            "instAddNat",
            "OfNat.ofNat",
            "Nat.factorial_pos"
          ],
          "tactic": "positivity",
          "proofState": 56,
          "pos": {
            "line": 116,
            "column": 20
          },
          "goals": "j : \u2115\n\u22a2 0 < (j + 1)!",
          "endPos": {
            "line": 116,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZMod.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "ZMod",
            "Subtype.mk",
            "Finset.range",
            "instHAdd",
            "ZHat.instDFunLikePNatZModVal",
            "HAdd.hAdd",
            "Nat.factorial",
            "ZHat.e",
            "Nat",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "ZHat",
            "instLTNat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "PNat"
          ],
          "tactic": "simp_rw [e_def, PNat.mk_coe, cast_sum]",
          "proofState": 57,
          "pos": {
            "line": 117,
            "column": 2
          },
          "goals": "j : \u2115\n\u22a2 e \u27e8(j + 1)!, \u22ef\u27e9 = \u2191(\u2211 i \u2208 range (j + 1), i !)",
          "endPos": {
            "line": 117,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "ExistsAddOfLE.exists_add_of_le",
            "HAdd.hAdd",
            "Nat.self_le_factorial",
            "OfNat.ofNat"
          ],
          "tactic": "obtain \u27e8k, hk\u27e9 := exists_add_of_le <| self_le_factorial (j + 1)",
          "proofState": 58,
          "pos": {
            "line": 118,
            "column": 2
          },
          "goals": "j : \u2115\n\u22a2 \u2211 x \u2208 range (j + 1)!, \u2191x ! = \u2211 x \u2208 range (j + 1), \u2191x !",
          "endPos": {
            "line": 118,
            "column": 65
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "AddCommMonoidWithOne.toAddCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.instNonUnitalSemiring",
            "Nat.cast",
            "ZMod",
            "Finset.range",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Finset.sum"
          ],
          "tactic": "rw [hk, sum_range_add, add_right_eq_self]",
          "proofState": 59,
          "pos": {
            "line": 119,
            "column": 2
          },
          "goals": "case intro\nj k : \u2115\nhk : (j + 1)! = j + 1 + k\n\u22a2 \u2211 x \u2208 range (j + 1)!, \u2191x ! = \u2211 x \u2208 range (j + 1), \u2191x !",
          "endPos": {
            "line": 119,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "Finset",
            "Finset.sum_eq_zero",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Membership.mem",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "instOfNatNat",
            "Finset.instMembership",
            "Nat.instNonUnitalSemiring",
            "Nat.cast",
            "ZMod",
            "Finset.range",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "refine sum_eq_zero (fun i _ => ?_)",
          "proofState": 60,
          "pos": {
            "line": 120,
            "column": 2
          },
          "goals": "case intro\nj k : \u2115\nhk : (j + 1)! = j + 1 + k\n\u22a2 \u2211 x \u2208 range k, \u2191(j + 1 + x)! = 0",
          "endPos": {
            "line": 120,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
            "instOfNatNat",
            "Nat.instNonUnitalSemiring",
            "Nat.cast",
            "ZMod",
            "instHAdd",
            "Nat.instDvd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "AddZeroClass.toZero",
            "propext",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "ZMod.natCast_zmod_eq_zero_iff_dvd",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [ZMod.natCast_zmod_eq_zero_iff_dvd, \u2190 hk]",
          "proofState": 61,
          "pos": {
            "line": 121,
            "column": 2
          },
          "goals": "case intro\nj k : \u2115\nhk : (j + 1)! = j + 1 + k\ni : \u2115\nx\u271d : i \u2208 range k\n\u22a2 \u2191(j + 1 + i)! = 0",
          "endPos": {
            "line": 121,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Nat.le_add_right",
            "instOfNatNat",
            "Nat.factorial_dvd_factorial",
            "instHAdd",
            "HAdd.hAdd",
            "Nat",
            "instAddNat",
            "OfNat.ofNat"
          ],
          "tactic": "exact factorial_dvd_factorial (Nat.le_add_right _ _)",
          "proofState": 62,
          "pos": {
            "line": 122,
            "column": 2
          },
          "goals": "case intro\nj k : \u2115\nhk : (j + 1)! = j + 1 + k\ni : \u2115\nx\u271d : i \u2208 range k\n\u22a2 (j + 1)! \u2223 (j + 1 + i)!",
          "endPos": {
            "line": 122,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Int"
          ],
          "tactic": "rintro (a | a) ha",
          "proofState": 63,
          "pos": {
            "line": 126,
            "column": 2
          },
          "goals": "\u22a2 \u2200 (a : \u2124), e \u2260 \u2191a",
          "endPos": {
            "line": 126,
            "column": 17
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8j, honelt, hj\u27e9 : \u2203 j : \u2115, 1 < j \u2227 a < \u2211 i \u2208 range (j + 1), i ! :=\n  by\n  refine \u27e8a + 2, ?_, ?_\u27e9\n  \u00b7 simp only [lt_add_iff_pos_left, add_pos_iff, zero_lt_one, or_true]\n  rw [sum_range_add]\n  apply lt_add_of_nonneg_of_lt\n  \u00b7 positivity\n  rw [range_one, sum_singleton, add_zero]\n  exact (Nat.lt_add_of_pos_right two_pos).trans_le (self_le_factorial _)",
          "proofState": 64,
          "pos": {
            "line": 127,
            "column": 4
          },
          "goals": "case ofNat\na : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 False",
          "endPos": {
            "line": 134,
            "column": 76
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "And",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "And.intro",
            "LT.lt",
            "Exists.intro",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instLTNat",
            "OfNat.ofNat",
            "Finset.sum"
          ],
          "tactic": "refine \u27e8a + 2, ?_, ?_\u27e9",
          "proofState": 65,
          "pos": {
            "line": 128,
            "column": 6
          },
          "goals": "a : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 \u2203 j, 1 < j \u2227 a < \u2211 i \u2208 range (j + 1), i !",
          "endPos": {
            "line": 128,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "IsRightCancelAdd.addRightStrictMono_of_addRightMono",
            "Nat.instCanonicallyOrderedAdd",
            "Preorder.toLT",
            "OrderedAddCommMonoid.toAddLeftMono",
            "congrArg",
            "covariant_swap_add_of_covariant_add",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddCancelMonoid.toIsCancelAdd",
            "Preorder.toLE",
            "Nat.instAddMonoid",
            "Nat.instAddCancelCommMonoid",
            "Nat.instStarOrderedRing",
            "Nat.instStarRing",
            "instOfNatNat",
            "LE.le",
            "Nat.instAddMonoidWithOne",
            "OrderedCancelAddCommMonoid.toAddLeftReflectLT",
            "AddMonoidWithOne.toOne",
            "instZeroLEOneClass",
            "instHAdd",
            "_auxLemma.7",
            "_auxLemma.6",
            "HAdd.hAdd",
            "Nat.instNeZeroSucc",
            "Nat",
            "_auxLemma.5",
            "AddZeroClass.toZero",
            "LT.lt",
            "Nat.instStrictOrderedSemiring",
            "True",
            "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
            "Nat.instPartialOrder",
            "of_eq_true",
            "One.toOfNat1",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "contravariant_swap_add_of_contravariant_add",
            "AddCommMonoid.toAddMonoid",
            "Or",
            "instLTNat",
            "OfNat.ofNat",
            "or_true",
            "AddZeroClass.toAdd",
            "AddCancelCommMonoid.toAddCancelMonoid",
            "IsCancelAdd.toIsRightCancelAdd",
            "Nat.instAddCommSemigroup",
            "Eq.trans",
            "Nat.instOrderedSemiring"
          ],
          "tactic": "simp only [lt_add_iff_pos_left, add_pos_iff, zero_lt_one, or_true]",
          "proofState": 66,
          "pos": {
            "line": 129,
            "column": 8
          },
          "goals": "case refine_1\na : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 1 < a + 2",
          "endPos": {
            "line": 129,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "id",
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "Finset.sum_range_add",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "AddCommMonoid.toAddMonoid",
            "instLTNat",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Finset.sum"
          ],
          "tactic": "rw [sum_range_add]",
          "proofState": 67,
          "pos": {
            "line": 130,
            "column": 6
          },
          "goals": "case refine_2\na : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 a < \u2211 i \u2208 range (a + 2 + 1), i !",
          "endPos": {
            "line": 130,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "lt_add_of_nonneg_of_lt"
          ],
          "tactic": "apply lt_add_of_nonneg_of_lt",
          "proofState": 68,
          "pos": {
            "line": 131,
            "column": 6
          },
          "goals": "case refine_2\na : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 a < \u2211 x \u2208 range (a + 2), x ! + \u2211 x \u2208 range 1, (a + 2 + x)!",
          "endPos": {
            "line": 131,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "Nat.instMulZeroClass",
            "Finset",
            "PartialOrder.toPreorder",
            "le_of_lt",
            "Membership.mem",
            "Finset.sum_pos",
            "instOfNatNat",
            "Finset.instMembership",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "Nat.instStrictOrderedSemiring",
            "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
            "Nat.instPartialOrder",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "Zero.toOfNat0",
            "Finset.nonempty_range_succ",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "Finset.sum",
            "MulZeroClass.toZero"
          ],
          "tactic": "positivity",
          "proofState": 69,
          "pos": {
            "line": 132,
            "column": 8
          },
          "goals": "case refine_2.ha\na : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 0 \u2264 \u2211 x \u2208 range (a + 2), x !",
          "endPos": {
            "line": 132,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Preorder.toLT",
            "congrArg",
            "Finset",
            "id",
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat.instPreorder",
            "Nat",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "Finset.range_one",
            "Finset.instSingleton",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Eq",
            "Finset.sum"
          ],
          "tactic": "rw [range_one, sum_singleton, add_zero]",
          "proofState": 70,
          "pos": {
            "line": 133,
            "column": 6
          },
          "goals": "case refine_2.hbc\na : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 a < \u2211 x \u2208 range 1, (a + 2 + x)!",
          "endPos": {
            "line": 133,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "OrderedAddCommMonoid.toAddLeftMono",
            "two_pos",
            "Nat.instStarOrderedRing",
            "AddMonoidWithOne.toNatCast",
            "Nat.instStarRing",
            "instOfNatNat",
            "Nat.instAddMonoidWithOne",
            "instZeroLEOneClass",
            "instHAdd",
            "Nat.lt_add_of_pos_right",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat.instNeZeroSucc",
            "Nat.instPreorder",
            "LT.lt.trans_le",
            "Nat",
            "Nat.instPartialOrder",
            "instAddNat",
            "Nat.instSemiring",
            "Nat.self_le_factorial",
            "OfNat.ofNat",
            "instOfNatAtLeastTwo",
            "Nat.instOrderedSemiring"
          ],
          "tactic": "exact (Nat.lt_add_of_pos_right two_pos).trans_le (self_le_factorial _)",
          "proofState": 71,
          "pos": {
            "line": 134,
            "column": 6
          },
          "goals": "case refine_2.hbc\na : \u2115\nha : e = \u2191(Int.ofNat a)\n\u22a2 a < (a + 2)!",
          "endPos": {
            "line": 134,
            "column": 76
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "Subtype.mk",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "instAddNat",
            "instLTNat",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "PNat"
          ],
          "tactic": "let N : \u2115+ := \u27e8(j + 1)!, by positivity\u27e9",
          "proofState": 72,
          "pos": {
            "line": 135,
            "column": 4
          },
          "goals": "case ofNat.intro.intro\na : \u2115\nha : e = \u2191(Int.ofNat a)\nj : \u2115\nhonelt : 1 < j\nhj : a < \u2211 i \u2208 range (j + 1), i !\n\u22a2 False",
          "endPos": {
            "line": 135,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "instHAdd",
            "HAdd.hAdd",
            "Nat",
            "instAddNat",
            "OfNat.ofNat",
            "Nat.factorial_pos"
          ],
          "tactic": "positivity",
          "proofState": 73,
          "pos": {
            "line": 135,
            "column": 32
          },
          "goals": "a : \u2115\nha : e = \u2191(Int.ofNat a)\nj : \u2115\nhonelt : 1 < j\nhj : a < \u2211 i \u2208 range (j + 1), i !\n\u22a2 0 < (j + 1)!",
          "endPos": {
            "line": 135,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "lt_irrefl",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.instPreorder",
            "ZHat.e",
            "Nat",
            "ZHat",
            "DFunLike.coe",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "apply lt_irrefl (e N).val",
          "proofState": 74,
          "pos": {
            "line": 136,
            "column": 4
          },
          "goals": "case ofNat.intro.intro\na : \u2115\nha : e = \u2191(Int.ofNat a)\nj : \u2115\nhonelt : 1 < j\nhj : a < \u2211 i \u2208 range (j + 1), i !\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 False",
          "endPos": {
            "line": 136,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Preorder.toLT",
            "instOfNatNat",
            "ZMod",
            "Finset.range",
            "instHAdd",
            "Nat.sum_factorial_lt_factorial_succ",
            "ZHat.instDFunLikePNatZModVal",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat.instPreorder",
            "ZHat.e",
            "Nat",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "ZHat",
            "instLTNat",
            "OfNat.ofNat",
            "DFunLike.coe",
            "Finset.sum",
            "letFun",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "have h\u2080 : \u2211 i \u2208 range (j + 1), i ! < (j + 1)! := sum_factorial_lt_factorial_succ honelt",
          "proofState": 75,
          "pos": {
            "line": 137,
            "column": 4
          },
          "goals": "case ofNat.intro.intro\na : \u2115\nha : e = \u2191(Int.ofNat a)\nj : \u2115\nhonelt : 1 < j\nhj : a < \u2211 i \u2208 range (j + 1), i !\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 (e N).val < (e N).val",
          "endPos": {
            "line": 137,
            "column": 92
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Int.cast",
            "Int.cast_natCast",
            "Trans.trans",
            "ZMod.commRing",
            "ZHat.e_factorial_succ",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Nat.instMod",
            "instHMod",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "instOfNatNat",
            "AddGroupWithOne.toIntCast",
            "Nat.mod_eq_of_lt",
            "Nat.cast",
            "ZMod",
            "Subtype.mk",
            "Finset.range",
            "instTransEq",
            "instHAdd",
            "HMod.hMod",
            "ZHat.instDFunLikePNatZModVal",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat.instPreorder",
            "ZHat.e",
            "Nat",
            "ZMod.val_natCast",
            "LT.lt",
            "True",
            "eq_self",
            "LT.lt.trans",
            "of_eq_true",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instTransEq_1",
            "ZHat",
            "instLTNat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "Eq.trans",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "calc\n  _ = _ := by simp [ha, N, mod_eq_of_lt (hj.trans h\u2080)]\n  _ < _ := hj\n  _ = _ := by simp only [PNat.mk_coe, e_factorial_succ, ZMod.val_natCast, mod_eq_of_lt h\u2080, N]",
          "proofState": 76,
          "pos": {
            "line": 138,
            "column": 4
          },
          "goals": "case ofNat.intro.intro\na : \u2115\nha : e = \u2191(Int.ofNat a)\nj : \u2115\nhonelt : 1 < j\nhj : a < \u2211 i \u2208 range (j + 1), i !\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\nh\u2080 : \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\n\u22a2 (e N).val < (e N).val",
          "endPos": {
            "line": 141,
            "column": 97
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  _ = _ := by simp [ha, N, mod_eq_of_lt (hj.trans h\u2080)]\n  _ < _ := hj\n  _ = _ := by simp only [PNat.mk_coe, e_factorial_succ, ZMod.val_natCast, mod_eq_of_lt h\u2080, N]",
          "proofState": 77,
          "pos": {
            "line": 139,
            "column": 6
          },
          "goals": "no goals",
          "endPos": {
            "line": 141,
            "column": 97
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Int.cast",
            "Int.cast_natCast",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Nat.instMod",
            "instHMod",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "instOfNatNat",
            "AddGroupWithOne.toIntCast",
            "Nat.mod_eq_of_lt",
            "Nat.cast",
            "ZMod",
            "Subtype.mk",
            "Finset.range",
            "instHAdd",
            "HMod.hMod",
            "ZHat.instDFunLikePNatZModVal",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat.instPreorder",
            "ZHat.e",
            "Nat",
            "ZMod.val_natCast",
            "LT.lt",
            "True",
            "eq_self",
            "LT.lt.trans",
            "of_eq_true",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "ZHat",
            "instLTNat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "Eq.trans",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "simp [ha, N, mod_eq_of_lt (hj.trans h\u2080)]",
          "proofState": 78,
          "pos": {
            "line": 139,
            "column": 18
          },
          "goals": "a : \u2115\nha : e = \u2191(Int.ofNat a)\nj : \u2115\nhonelt : 1 < j\nhj : a < \u2211 i \u2208 range (j + 1), i !\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\nh\u2080 : \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\n\u22a2 (e N).val = a",
          "endPos": {
            "line": 139,
            "column": 58
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZMod.commRing",
            "ZHat.e_factorial_succ",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Nat.instMod",
            "instHMod",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.mod_eq_of_lt",
            "Nat.cast",
            "ZMod",
            "Subtype.mk",
            "Finset.range",
            "instHAdd",
            "HMod.hMod",
            "ZHat.instDFunLikePNatZModVal",
            "HAdd.hAdd",
            "Nat.factorial",
            "ZHat.e",
            "Nat",
            "ZMod.val_natCast",
            "LT.lt",
            "True",
            "eq_self",
            "of_eq_true",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "ZHat",
            "instLTNat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Finset.sum",
            "Eq.trans",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "simp only [PNat.mk_coe, e_factorial_succ, ZMod.val_natCast, mod_eq_of_lt h\u2080, N]",
          "proofState": 79,
          "pos": {
            "line": 141,
            "column": 18
          },
          "goals": "a : \u2115\nha : e = \u2191(Int.ofNat a)\nj : \u2115\nhonelt : 1 < j\nhj : a < \u2211 i \u2208 range (j + 1), i !\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\nh\u2080 : \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\n\u22a2 \u2211 i \u2208 range (j + 1), i ! = (e N).val",
          "endPos": {
            "line": 141,
            "column": 97
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8j, honelt, hj\u27e9 : \u2203 j, 1 < j \u2227 (a + 1) + \u2211 i \u2208 range (j + 1), i ! < (j + 1)! :=\n  by\n  refine \u27e8a + 3, ?_, ?_\u27e9\n  \u00b7 omega\n  calc\n    _ < (a + 1) * 1 + 2 * (a + 3)! := ?_\n    _ \u2264 (a + 1) * (a + 3)! + 2 * (a + 3)! + 0 := ?_\n    _ < (a + 1) * (a + 3)! + 2 * (a + 3)! + (a + 3)! := ?_\n    _ = (a + 4)! := ?_\n  \u00b7 rw [mul_one]\n    have : 3 \u2264 a + 3 := by omega\n    have := sum_factorial_lt_two_mul_factorial this\n    gcongr\n  \u00b7 rw [add_zero]\n    have : 1 \u2264 (a + 3)! := Nat.one_le_of_lt (factorial_pos _)\n    gcongr\n  \u00b7 gcongr\n    exact factorial_pos _\n  \u00b7 rw [factorial_succ (a + 3)]\n    ring",
          "proofState": 80,
          "pos": {
            "line": 142,
            "column": 4
          },
          "goals": "case negSucc\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 False",
          "endPos": {
            "line": 160,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "And",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "And.intro",
            "LT.lt",
            "Exists.intro",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instLTNat",
            "OfNat.ofNat",
            "Finset.sum"
          ],
          "tactic": "refine \u27e8a + 3, ?_, ?_\u27e9",
          "proofState": 81,
          "pos": {
            "line": 143,
            "column": 6
          },
          "goals": "a : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 \u2203 j, 1 < j \u2227 a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!",
          "endPos": {
            "line": 143,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega",
          "proofState": 82,
          "pos": {
            "line": 144,
            "column": 8
          },
          "goals": "case refine_1\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 1 < a + 3",
          "endPos": {
            "line": 144,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "Trans.trans",
            "HMul.hMul",
            "Nat.instTransLtLe",
            "instMulNat",
            "instOfNatNat",
            "Nat.instTransLt",
            "LE.le",
            "instLENat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instTransEq_1",
            "instLTNat",
            "OfNat.ofNat",
            "Eq",
            "Finset.sum",
            "instHMul"
          ],
          "tactic": "calc\n  _ < (a + 1) * 1 + 2 * (a + 3)! := ?_\n  _ \u2264 (a + 1) * (a + 3)! + 2 * (a + 3)! + 0 := ?_\n  _ < (a + 1) * (a + 3)! + 2 * (a + 3)! + (a + 3)! := ?_\n  _ = (a + 4)! := ?_",
          "proofState": 83,
          "pos": {
            "line": 145,
            "column": 6
          },
          "goals": "case refine_2\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 a + 1 + \u2211 i \u2208 range (a + 3 + 1), i ! < (a + 3 + 1)!",
          "endPos": {
            "line": 149,
            "column": 26
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  _ < (a + 1) * 1 + 2 * (a + 3)! := ?_\n  _ \u2264 (a + 1) * (a + 3)! + 2 * (a + 3)! + 0 := ?_\n  _ < (a + 1) * (a + 3)! + 2 * (a + 3)! + (a + 3)! := ?_\n  _ = (a + 4)! := ?_",
          "proofState": 84,
          "pos": {
            "line": 146,
            "column": 8
          },
          "goals": "no goals",
          "endPos": {
            "line": 149,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "HMul.hMul",
            "MulOneClass.toMul",
            "congrArg",
            "id",
            "instMulNat",
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "MulOneClass.toOne",
            "One.toOfNat1",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instLTNat",
            "mul_one",
            "OfNat.ofNat",
            "Eq",
            "Finset.sum",
            "instHMul"
          ],
          "tactic": "rw [mul_one]",
          "proofState": 85,
          "pos": {
            "line": 150,
            "column": 8
          },
          "goals": "case refine_2.calc_1\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 a + 1 + \u2211 i \u2208 range (a + 3 + 1), i ! < (a + 1) * 1 + 2 * (a + 3)!",
          "endPos": {
            "line": 150,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "HMul.hMul",
            "instMulNat",
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instLTNat",
            "OfNat.ofNat",
            "Finset.sum",
            "letFun",
            "instHMul"
          ],
          "tactic": "have : 3 \u2264 a + 3 := by omega",
          "proofState": 86,
          "pos": {
            "line": 151,
            "column": 8
          },
          "goals": "case refine_2.calc_1\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 a + 1 + \u2211 i \u2208 range (a + 3 + 1), i ! < a + 1 + 2 * (a + 3)!",
          "endPos": {
            "line": 151,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega",
          "proofState": 87,
          "pos": {
            "line": 151,
            "column": 31
          },
          "goals": "a : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 3 \u2264 a + 3",
          "endPos": {
            "line": 151,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Nat.sum_factorial_lt_two_mul_factorial",
            "HMul.hMul",
            "instMulNat",
            "instOfNatNat",
            "Finset.range",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "instLTNat",
            "OfNat.ofNat",
            "Finset.sum",
            "letFun",
            "instHMul"
          ],
          "tactic": "have := sum_factorial_lt_two_mul_factorial this",
          "proofState": 88,
          "pos": {
            "line": 152,
            "column": 8
          },
          "goals": "case refine_2.calc_1\na : \u2115\nha : e = \u2191(Int.negSucc a)\nthis : 3 \u2264 a + 3\n\u22a2 a + 1 + \u2211 i \u2208 range (a + 3 + 1), i ! < a + 1 + 2 * (a + 3)!",
          "endPos": {
            "line": 152,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "add_lt_add_left"
          ],
          "tactic": "gcongr",
          "proofState": 89,
          "pos": {
            "line": 153,
            "column": 8
          },
          "goals": "case refine_2.calc_1\na : \u2115\nha : e = \u2191(Int.negSucc a)\nthis\u271d : 3 \u2264 a + 3\nthis : \u2211 i \u2208 range (a + 3 + 1), i ! < 2 * (a + 3)!\n\u22a2 a + 1 + \u2211 i \u2208 range (a + 3 + 1), i ! < a + 1 + 2 * (a + 3)!",
          "endPos": {
            "line": 153,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "HMul.hMul",
            "congrArg",
            "id",
            "instMulNat",
            "instOfNatNat",
            "LE.le",
            "instLENat",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "AddZeroClass.toZero",
            "instAddNat",
            "Zero.toOfNat0",
            "add_zero",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "instHMul"
          ],
          "tactic": "rw [add_zero]",
          "proofState": 90,
          "pos": {
            "line": 154,
            "column": 8
          },
          "goals": "case refine_2.calc_2\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 (a + 1) * 1 + 2 * (a + 3)! \u2264 (a + 1) * (a + 3)! + 2 * (a + 3)! + 0",
          "endPos": {
            "line": 154,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "HMul.hMul",
            "instMulNat",
            "instOfNatNat",
            "LE.le",
            "Nat.one_le_of_lt",
            "instLENat",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "instAddNat",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "letFun",
            "instHMul"
          ],
          "tactic": "have : 1 \u2264 (a + 3)! := Nat.one_le_of_lt (factorial_pos _)",
          "proofState": 91,
          "pos": {
            "line": 155,
            "column": 8
          },
          "goals": "case refine_2.calc_2\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 (a + 1) * 1 + 2 * (a + 3)! \u2264 (a + 1) * (a + 3)! + 2 * (a + 3)!",
          "endPos": {
            "line": 155,
            "column": 65
          }
        },
        {
          "usedConstants": [
            "add_le_add_right"
          ],
          "tactic": "gcongr",
          "proofState": 92,
          "pos": {
            "line": 156,
            "column": 8
          },
          "goals": "case refine_2.calc_2\na : \u2115\nha : e = \u2191(Int.negSucc a)\nthis : 1 \u2264 (a + 3)!\n\u22a2 (a + 1) * 1 + 2 * (a + 3)! \u2264 (a + 1) * (a + 3)! + 2 * (a + 3)!",
          "endPos": {
            "line": 156,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "add_lt_add_left"
          ],
          "tactic": "gcongr",
          "proofState": 93,
          "pos": {
            "line": 157,
            "column": 8
          },
          "goals": "case refine_2.calc_3\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 (a + 1) * (a + 3)! + 2 * (a + 3)! + 0 < (a + 1) * (a + 3)! + 2 * (a + 3)! + (a + 3)!",
          "endPos": {
            "line": 157,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "instHAdd",
            "HAdd.hAdd",
            "Nat",
            "instAddNat",
            "OfNat.ofNat",
            "Nat.factorial_pos"
          ],
          "tactic": "exact factorial_pos _",
          "proofState": 94,
          "pos": {
            "line": 158,
            "column": 8
          },
          "goals": "case refine_2.calc_3.bc\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 0 < (a + 3)!",
          "endPos": {
            "line": 158,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "HMul.hMul",
            "congrArg",
            "Nat.factorial_succ",
            "id",
            "instMulNat",
            "instOfNatNat",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "instAddNat",
            "OfNat.ofNat",
            "Eq",
            "instHMul"
          ],
          "tactic": "rw [factorial_succ (a + 3)]",
          "proofState": 95,
          "pos": {
            "line": 159,
            "column": 8
          },
          "goals": "case refine_2.calc_4\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 (a + 1) * (a + 3)! + 2 * (a + 3)! + (a + 3)! = (a + 4)!",
          "endPos": {
            "line": 159,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "HMul.hMul",
            "Nat.rawCast",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Mathlib.Tactic.Ring.one_mul",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "instMulNat",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat.factorial",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Mathlib.Tactic.Ring.mul_one",
            "Nat.instCommSemiring",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "Zero.toOfNat0",
            "Eq.refl",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 96,
          "pos": {
            "line": 160,
            "column": 8
          },
          "goals": "case refine_2.calc_4\na : \u2115\nha : e = \u2191(Int.negSucc a)\n\u22a2 (a + 1) * (a + 3)! + 2 * (a + 3)! + (a + 3)! = (a + 3 + 1) * (a + 3)!",
          "endPos": {
            "line": 160,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "Subtype.mk",
            "instHAdd",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat",
            "LT.lt",
            "instAddNat",
            "instLTNat",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "PNat"
          ],
          "tactic": "let N : \u2115+ := \u27e8(j + 1)!, by positivity\u27e9",
          "proofState": 97,
          "pos": {
            "line": 161,
            "column": 4
          },
          "goals": "case negSucc.intro.intro\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\n\u22a2 False",
          "endPos": {
            "line": 161,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "instOfNatNat",
            "instHAdd",
            "HAdd.hAdd",
            "Nat",
            "instAddNat",
            "OfNat.ofNat",
            "Nat.factorial_pos"
          ],
          "tactic": "positivity",
          "proofState": 98,
          "pos": {
            "line": 161,
            "column": 32
          },
          "goals": "a : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\n\u22a2 0 < (j + 1)!",
          "endPos": {
            "line": 161,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "lt_irrefl",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.instPreorder",
            "ZHat.e",
            "Nat",
            "ZHat",
            "DFunLike.coe",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "apply lt_irrefl (e N).val",
          "proofState": 99,
          "pos": {
            "line": 162,
            "column": 4
          },
          "goals": "case negSucc.intro.intro\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 False",
          "endPos": {
            "line": 162,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Trans.trans",
            "HSub.hSub",
            "instSubNat",
            "instOfNatNat",
            "ZMod",
            "instHAdd",
            "ZHat.instDFunLikePNatZModVal",
            "instHSub",
            "HAdd.hAdd",
            "ZHat.e",
            "Nat",
            "LT.lt",
            "instAddNat",
            "instTransEq_1",
            "ZHat",
            "instLTNat",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "calc\n  _ < N - (a + 1) := ?_\n  _ = (e N).val := ?_",
          "proofState": 100,
          "pos": {
            "line": 163,
            "column": 4
          },
          "goals": "case negSucc.intro.intro\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 (e N).val < (e N).val",
          "endPos": {
            "line": 165,
            "column": 25
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  _ < N - (a + 1) := ?_\n  _ = (e N).val := ?_",
          "proofState": 101,
          "pos": {
            "line": 164,
            "column": 6
          },
          "goals": "no goals",
          "endPos": {
            "line": 165,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "HSub.hSub",
            "id",
            "HAdd.hAdd",
            "LT.lt",
            "OfNat.ofNat"
          ],
          "tactic": "dsimp [N]",
          "proofState": 102,
          "pos": {
            "line": 166,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_1\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 (e N).val < \u2191N - (a + 1)",
          "endPos": {
            "line": 166,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Nat.lt_sub_of_add_lt"
          ],
          "tactic": "apply lt_sub_of_add_lt",
          "proofState": 103,
          "pos": {
            "line": 167,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_1\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 (e \u27e8(j + 1)!, \u22ef\u27e9).val < (j + 1)! - (a + 1)",
          "endPos": {
            "line": 167,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "congrArg",
            "id",
            "instOfNatNat",
            "add_comm",
            "ZMod",
            "Subtype.mk",
            "instHAdd",
            "ZHat.instDFunLikePNatZModVal",
            "HAdd.hAdd",
            "Nat.factorial",
            "ZHat.e",
            "Nat",
            "LT.lt",
            "instAddNat",
            "AddCommSemigroup.toAddCommMagma",
            "ZHat",
            "instLTNat",
            "OfNat.ofNat",
            "Nat.factorial_pos",
            "Eq",
            "DFunLike.coe",
            "Nat.instAddCommSemigroup",
            "AddCommMagma.toAdd",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "rwa [add_comm, e_factorial_succ, ZMod.val_natCast, mod_eq_of_lt (sum_factorial_lt_factorial_succ honelt)]",
          "proofState": 104,
          "pos": {
            "line": 168,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_1.h\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 (e \u27e8(j + 1)!, \u22ef\u27e9).val + (a + 1) < (j + 1)!",
          "endPos": {
            "line": 169,
            "column": 62
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "lt_of_le_of_lt",
            "Nat.le_add_right",
            "HSub.hSub",
            "instSubNat",
            "instOfNatNat",
            "ZMod",
            "Finset.range",
            "instHAdd",
            "ZHat.instDFunLikePNatZModVal",
            "instHSub",
            "HAdd.hAdd",
            "Nat.factorial",
            "Nat.instPreorder",
            "ZHat.e",
            "Nat",
            "LT.lt",
            "instAddNat",
            "Nat.instAddCommMonoid",
            "ZHat",
            "instLTNat",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Finset.sum",
            "letFun",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "have : a + 1 < N := lt_of_le_of_lt (Nat.le_add_right _ _) hj",
          "proofState": 105,
          "pos": {
            "line": 170,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_2\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\n\u22a2 \u2191N - (a + 1) = (e N).val",
          "endPos": {
            "line": 170,
            "column": 66
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Int.cast",
            "Eq.mpr",
            "congrArg",
            "ZHat.commRing",
            "HSub.hSub",
            "id",
            "instSubNat",
            "instOfNatNat",
            "AddGroupWithOne.toIntCast",
            "ZMod",
            "instHAdd",
            "ZHat.instDFunLikePNatZModVal",
            "instHSub",
            "HAdd.hAdd",
            "ZHat.e",
            "Nat",
            "instAddNat",
            "ZHat",
            "Int.negSucc",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "rw [ha, intCast_val, Int.cast_negSucc, ZMod.neg_val, ZMod.val_natCast, if_neg, mod_eq_of_lt this]",
          "proofState": 106,
          "pos": {
            "line": 171,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_2\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\nthis : a + 1 < \u2191N\n\u22a2 \u2191N - (a + 1) = (e N).val",
          "endPos": {
            "line": 172,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "ZMod",
            "instHAdd",
            "Nat.instDvd",
            "HAdd.hAdd",
            "Nat",
            "propext",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "instAddNat",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "ZMod.natCast_zmod_eq_zero_iff_dvd",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [ZMod.natCast_zmod_eq_zero_iff_dvd]",
          "proofState": 107,
          "pos": {
            "line": 173,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_2.hnc\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\nthis : a + 1 < \u2191N\n\u22a2 \u00ac\u2191(a + 1) = 0",
          "endPos": {
            "line": 173,
            "column": 44
          }
        },
        {
          "usedConstants": [],
          "tactic": "contrapose! this",
          "proofState": 108,
          "pos": {
            "line": 174,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_2.hnc\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\nthis : a + 1 < \u2191N\n\u22a2 \u00ac\u2191N \u2223 a + 1",
          "endPos": {
            "line": 174,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Nat.zero_lt_succ",
            "Nat.le_of_dvd",
            "Nat.succ"
          ],
          "tactic": "apply le_of_dvd (zero_lt_succ a) this",
          "proofState": 109,
          "pos": {
            "line": 175,
            "column": 6
          },
          "goals": "case negSucc.intro.intro.calc_2.hnc\na : \u2115\nha : e = \u2191(Int.negSucc a)\nj : \u2115\nhonelt : 1 < j\nhj : a + 1 + \u2211 i \u2208 range (j + 1), i ! < (j + 1)!\nN : \u2115+ := \u27e8(j + 1)!, \u22ef\u27e9\nthis : \u2191N \u2223 a + 1\n\u22a2 \u2191N \u2264 a + 1",
          "endPos": {
            "line": 175,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "ZMod.cast",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "id",
            "ZMod.castHom_apply",
            "ZMod",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "ZMod.charP",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "ZMod.castHom"
          ],
          "tactic": "rw [ZMod.castHom_apply, ZMod.cast_eq_val]",
          "proofState": 110,
          "pos": {
            "line": 180,
            "column": 2
          },
          "goals": "a b : \u2115\ninst\u271d : NeZero b\nh : a \u2223 b\nx : ZMod b\nhx : a \u2223 x.val\n\u22a2 (ZMod.castHom h (ZMod a)) x = 0",
          "endPos": {
            "line": 180,
            "column": 43
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8y, hy\u27e9 := hx",
          "proofState": 111,
          "pos": {
            "line": 181,
            "column": 2
          },
          "goals": "a b : \u2115\ninst\u271d : NeZero b\nh : a \u2223 b\nx : ZMod b\nhx : a \u2223 x.val\n\u22a2 \u2191x.val = 0",
          "endPos": {
            "line": 181,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instMulNat",
            "Nat.cast",
            "ZMod",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "instHMul",
            "ZMod.val"
          ],
          "tactic": "rw [hy]",
          "proofState": 112,
          "pos": {
            "line": 182,
            "column": 2
          },
          "goals": "case intro\na b : \u2115\ninst\u271d : NeZero b\nh : a \u2223 b\nx : ZMod b\ny : \u2115\nhy : x.val = a * y\n\u22a2 \u2191x.val = 0",
          "endPos": {
            "line": 182,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "CharP.cast_eq_zero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "MulZeroClass.zero_mul",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddMonoidWithOne.toNatCast",
            "instMulNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "ZMod",
            "CommRing.toCommSemiring",
            "Nat.cast_mul",
            "ZMod.charP",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 113,
          "pos": {
            "line": 183,
            "column": 2
          },
          "goals": "case intro\na b : \u2115\ninst\u271d : NeZero b\nh : a \u2223 b\nx : ZMod b\ny : \u2115\nhy : x.val = a * y\n\u22a2 \u2191(a * y) = 0",
          "endPos": {
            "line": 183,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "ZHat.ext"
          ],
          "tactic": "ext j",
          "proofState": 114,
          "pos": {
            "line": 186,
            "column": 2
          },
          "goals": "N : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\n\u22a2 a = 0",
          "endPos": {
            "line": 186,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "ZMod",
            "instZHatCommRing",
            "ZHat.instDFunLikePNatZModVal",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "OfNat.ofNat",
            "ZHat.zero_val",
            "Eq",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "PNat"
          ],
          "tactic": "rw [zero_val, \u2190 a.prop j (N * j) (by simp)]",
          "proofState": 115,
          "pos": {
            "line": 187,
            "column": 2
          },
          "goals": "case h\nN : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 a j = 0 j",
          "endPos": {
            "line": 187,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "CommMagma.toMul",
            "CommSemigroup.toSemigroup",
            "Nat",
            "CommSemigroup.toCommMagma",
            "of_eq_true",
            "Mathlib.Algebra.Divisibility.Basic._auxLemma.3",
            "Nat.instCommSemigroup",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 116,
          "pos": {
            "line": 187,
            "column": 39
          },
          "goals": "N : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 \u2191j \u2223 \u2191(N * j)",
          "endPos": {
            "line": 187,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "ZHat.torsionfree_aux"
          ],
          "tactic": "apply torsionfree_aux",
          "proofState": 117,
          "pos": {
            "line": 188,
            "column": 2
          },
          "goals": "case h\nN : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 (ZMod.castHom \u22ef (ZMod \u2191j)) (a (N * j)) = 0",
          "endPos": {
            "line": 188,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "HMul.hMul",
            "ZMod",
            "instPNatMul",
            "ZHat.instDFunLikePNatZModVal",
            "PNat.pos",
            "ZHat",
            "Nat.dvd_of_mul_dvd_mul_left",
            "DFunLike.coe",
            "instHMul",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "apply Nat.dvd_of_mul_dvd_mul_left N.pos",
          "proofState": 118,
          "pos": {
            "line": 189,
            "column": 2
          },
          "goals": "case h.hx\nN : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 \u2191j \u2223 (a (N * j)).val",
          "endPos": {
            "line": 189,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "Dvd.dvd",
            "HMul.hMul",
            "congrArg",
            "id",
            "instMulNat",
            "ZMod",
            "instPNatMul",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.instDvd",
            "Nat",
            "PNat.mul_coe",
            "ZHat",
            "Eq.symm",
            "Eq",
            "DFunLike.coe",
            "instHMul",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "rw [\u2190 PNat.mul_coe]",
          "proofState": 119,
          "pos": {
            "line": 190,
            "column": 2
          },
          "goals": "case h.hx\nN : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 \u2191N * \u2191j \u2223 \u2191N * (a (N * j)).val",
          "endPos": {
            "line": 190,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Nat.dvd_of_mod_eq_zero"
          ],
          "tactic": "apply Nat.dvd_of_mod_eq_zero",
          "proofState": 120,
          "pos": {
            "line": 191,
            "column": 2
          },
          "goals": "case h.hx\nN : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 \u2191(N * j) \u2223 \u2191N * (a (N * j)).val",
          "endPos": {
            "line": 191,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Nat.instMod",
            "instHMod",
            "AddMonoidWithOne.toNatCast",
            "instMulNat",
            "instOfNatNat",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "HMod.hMod",
            "ZHat.instDFunLikePNatZModVal",
            "Distrib.toMul",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "MulZeroClass.toZero",
            "instHMul",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "have : N * a (N * j) = 0 := by\n  have : ((N : ZHat) * a) (N * j) = 0 := by simp [ha]\n  exact this",
          "proofState": 121,
          "pos": {
            "line": 192,
            "column": 2
          },
          "goals": "case h.hx.H\nN : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 \u2191N * (a (N * j)).val % \u2191(N * j) = 0",
          "endPos": {
            "line": 194,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "ZHat.instDFunLikePNatZModVal",
            "Distrib.toMul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "have : ((N : ZHat) * a) (N * j) = 0 := by simp [ha]",
          "proofState": 122,
          "pos": {
            "line": 193,
            "column": 4
          },
          "goals": "N : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 \u2191\u2191N * a (N * j) = 0",
          "endPos": {
            "line": 193,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddMonoidWithOne.toNatCast",
            "instMulNat",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "ZHat.instDFunLikePNatZModVal",
            "Distrib.toMul",
            "Nat",
            "True",
            "eq_self",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "simp [ha]",
          "proofState": 123,
          "pos": {
            "line": 193,
            "column": 46
          },
          "goals": "N : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\n\u22a2 (\u2191\u2191N * a) (N * j) = 0",
          "endPos": {
            "line": 193,
            "column": 55
          }
        },
        {
          "usedConstants": [],
          "tactic": "exact this",
          "proofState": 124,
          "pos": {
            "line": 194,
            "column": 4
          },
          "goals": "N : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\nthis : (\u2191\u2191N * a) (N * j) = 0\n\u22a2 \u2191\u2191N * a (N * j) = 0",
          "endPos": {
            "line": 194,
            "column": 14
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa only [ZMod.val_mul, ZMod.val_natCast, Nat.mod_mul_mod, ZMod.val_zero] using congrArg ZMod.val this",
          "proofState": 125,
          "pos": {
            "line": 195,
            "column": 2
          },
          "goals": "case h.hx.H\nN : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\nj : \u2115+\nthis : \u2191\u2191N * a (N * j) = 0\n\u22a2 \u2191N * (a (N * j)).val % \u2191(N * j) = 0",
          "endPos": {
            "line": 195,
            "column": 106
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Distrib.toMul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "AddCommMonoid.toAddMonoid",
            "AddMonoidHom.mulLeft",
            "ZHat",
            "Function.Injective",
            "AddMonoidHom.coe_mulLeft",
            "CommRing.toRing",
            "AddMonoidHom",
            "AddMonoidHom.instFunLike",
            "Eq.symm",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "rw [\u2190 AddMonoidHom.coe_mulLeft, injective_iff_map_eq_zero]",
          "proofState": 126,
          "pos": {
            "line": 199,
            "column": 2
          },
          "goals": "N : \u2115+\n\u22a2 Function.Injective fun z => \u2191\u2191N * z",
          "endPos": {
            "line": 199,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "ZHat"
          ],
          "tactic": "intro a ha",
          "proofState": 127,
          "pos": {
            "line": 200,
            "column": 2
          },
          "goals": "N : \u2115+\n\u22a2 \u2200 (a : ZHat), (AddMonoidHom.mulLeft \u2191\u2191N) a = 0 \u2192 a = 0",
          "endPos": {
            "line": 200,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Eq.mp",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Distrib.toMul",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "AddMonoidHom.mulLeft",
            "ZHat",
            "AddMonoidWithOne.toAddMonoid",
            "AddMonoidHom.coe_mulLeft",
            "CommRing.toRing",
            "AddMonoidHom",
            "AddMonoidHom.instFunLike",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "rw [AddMonoidHom.coe_mulLeft] at ha",
          "proofState": 128,
          "pos": {
            "line": 201,
            "column": 2
          },
          "goals": "N : \u2115+\na : ZHat\nha : (AddMonoidHom.mulLeft \u2191\u2191N) a = 0\n\u22a2 a = 0",
          "endPos": {
            "line": 201,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "ZHat.eq_zero_of_mul_eq_zero"
          ],
          "tactic": "exact eq_zero_of_mul_eq_zero N a ha",
          "proofState": 129,
          "pos": {
            "line": 202,
            "column": 2
          },
          "goals": "N : \u2115+\na : ZHat\nha : \u2191\u2191N * a = 0\n\u22a2 a = 0",
          "endPos": {
            "line": 202,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Submodule",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "Submodule.torsion",
            "ZHat.commRing",
            "id",
            "Bot.bot",
            "Int",
            "Module.Flat",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "Int.instCommRing",
            "Ring.toAddCommGroup",
            "Module.Flat.flat_iff_torsion_eq_bot",
            "propext",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "ZHat",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "Eq"
          ],
          "tactic": "rw [Module.Flat.flat_iff_torsion_eq_bot]",
          "proofState": 130,
          "pos": {
            "line": 205,
            "column": 2
          },
          "goals": "\u22a2 Module.Flat \u2124 ZHat",
          "endPos": {
            "line": 205,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "OrderedAddCommMonoid.toPartialOrder",
            "Submodule.torsion",
            "ZHat.commRing",
            "OrderBot.toBot",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "id",
            "Bot.bot",
            "Int",
            "LE.le",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "Int.instCommRing",
            "Submodule.instOrderedAddCommMonoid",
            "Ring.toAddCommGroup",
            "propext",
            "AddCommGroup.toIntModule",
            "ZHat",
            "Submodule.instOrderBot",
            "CommRing.toRing",
            "eq_bot_iff",
            "Eq"
          ],
          "tactic": "rw [eq_bot_iff]",
          "proofState": 131,
          "pos": {
            "line": 206,
            "column": 2
          },
          "goals": "\u22a2 Submodule.torsion \u2124 ZHat = \u22a5",
          "endPos": {
            "line": 206,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "ZHat"
          ],
          "tactic": "intro x hx",
          "proofState": 132,
          "pos": {
            "line": 207,
            "column": 2
          },
          "goals": "\u22a2 Submodule.torsion \u2124 ZHat \u2264 \u22a5",
          "endPos": {
            "line": 207,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "_auxLemma.11",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "OrderedAddCommMonoid.toPartialOrder",
            "ZHat.commRing",
            "OrderBot.toBot",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "Membership.mem",
            "id",
            "Bot.bot",
            "Int",
            "CommRing.toCommSemiring",
            "Int.instCommRing",
            "Submodule.instOrderedAddCommMonoid",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "AddCommGroup.toIntModule",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "ZHat",
            "Submodule.instOrderBot",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "SetLike.instMembership"
          ],
          "tactic": "simp only [Submodule.mem_torsion'_iff, Subtype.exists, Submonoid.mk_smul, zsmul_eq_mul, exists_prop, Submodule.mem_bot,\n  mem_nonZeroDivisors_iff_ne_zero] at hx \u22a2",
          "proofState": 133,
          "pos": {
            "line": 208,
            "column": 2
          },
          "goals": "x : ZHat\nhx : x \u2208 Submodule.torsion \u2124 ZHat\n\u22a2 x \u2208 \u22a5",
          "endPos": {
            "line": 209,
            "column": 76
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8N, hN\u27e9 := hx",
          "proofState": 134,
          "pos": {
            "line": 210,
            "column": 2
          },
          "goals": "x : ZHat\nhx : \u2203 a, a \u2260 0 \u2227 \u2191a * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 210,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int",
            "Eq.refl"
          ],
          "tactic": "cases N",
          "proofState": 135,
          "pos": {
            "line": 211,
            "column": 2
          },
          "goals": "case intro\nx : ZHat\nN : \u2124\nhN : N \u2260 0 \u2227 \u2191N * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 211,
            "column": 9
          }
        },
        {
          "usedConstants": [],
          "tactic": "case ofNat N =>\n  simp only [Int.ofNat_eq_coe, ne_eq, cast_eq_zero, Int.cast_natCast] at hN\n  lift N to \u2115+ using by\n    omega\n      -- lol\n  exact eq_zero_of_mul_eq_zero _ _ hN.2",
          "proofState": 136,
          "pos": {
            "line": 212,
            "column": 2
          },
          "goals": "case intro.ofNat\nx : ZHat\na\u271d : \u2115\nhN : Int.ofNat a\u271d \u2260 0 \u2227 \u2191(Int.ofNat a\u271d) * x = 0\n\u22a2 x = 0\ncase intro.negSucc\nx : ZHat\na\u271d : \u2115\nhN : Int.negSucc a\u271d \u2260 0 \u2227 \u2191(Int.negSucc a\u271d) * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 215,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Int.cast_natCast",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "AddCommGroup.toAddCommMonoid",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "_auxLemma.13",
            "Eq.mp",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "And",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "Int.instRing",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "instNatCastInt",
            "ZHat",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "instHMul"
          ],
          "tactic": "simp only [Int.ofNat_eq_coe, ne_eq, cast_eq_zero, Int.cast_natCast] at hN",
          "proofState": 137,
          "pos": {
            "line": 213,
            "column": 4
          },
          "goals": "x : ZHat\nN : \u2115\nhN : Int.ofNat N \u2260 0 \u2227 \u2191(Int.ofNat N) * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 213,
            "column": 77
          }
        },
        {
          "usedConstants": [],
          "tactic": "lift N to \u2115+ using by\n  omega\n    -- lol",
          "proofState": 138,
          "pos": {
            "line": 214,
            "column": 4
          },
          "goals": "x : ZHat\nN : \u2115\nhN : \u00acN = 0 \u2227 \u2191N * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 214,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega\n  -- lol",
          "proofState": 139,
          "pos": {
            "line": 214,
            "column": 26
          },
          "goals": "x : ZHat\nN : \u2115\nhN : \u00acN = 0 \u2227 \u2191N * x = 0\n\u22a2 0 < N",
          "endPos": {
            "line": 214,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "AddCommGroup.toAddCommMonoid",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "And.right",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "Nat",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "ZHat",
            "ZHat.eq_zero_of_mul_eq_zero",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "instHMul"
          ],
          "tactic": "exact eq_zero_of_mul_eq_zero _ _ hN.2",
          "proofState": 140,
          "pos": {
            "line": 215,
            "column": 4
          },
          "goals": "case intro\nx : ZHat\nN : \u2115+\nhN : \u00ac\u2191N = 0 \u2227 \u2191\u2191N * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 215,
            "column": 41
          }
        },
        {
          "usedConstants": [],
          "tactic": "case negSucc\n  N =>\n  simp only [ne_eq, Int.negSucc_ne_zero, not_false_eq_true, true_and, Int.cast_negSucc] at hN\n  rw [neg_mul, neg_eq_zero] at hN\n  exact eq_zero_of_mul_eq_zero \u27e8N + 1, by omega\u27e9 _ hN",
          "proofState": 141,
          "pos": {
            "line": 216,
            "column": 2
          },
          "goals": "case intro.negSucc\nx : ZHat\na\u271d : \u2115\nhN : Int.negSucc a\u271d \u2260 0 \u2227 \u2191(Int.negSucc a\u271d) * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 219,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "NegZeroClass.toNeg",
            "False",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "AddCommGroup.toAddCommMonoid",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Eq.mp",
            "Int.cast_negSucc",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "_auxLemma.14",
            "instHAdd",
            "And",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "ZHat",
            "Int.negSucc",
            "CommRing.toRing",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Not",
            "Neg.neg",
            "true_and",
            "Eq.trans",
            "instHMul"
          ],
          "tactic": "simp only [ne_eq, Int.negSucc_ne_zero, not_false_eq_true, true_and, Int.cast_negSucc] at hN",
          "proofState": 142,
          "pos": {
            "line": 217,
            "column": 4
          },
          "goals": "x : ZHat\nN : \u2115\nhN : Int.negSucc N \u2260 0 \u2227 \u2191(Int.negSucc N) * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 217,
            "column": 95
          }
        },
        {
          "usedConstants": [
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "AddCommGroup.toAddCommMonoid",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Eq.mp",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "instHAdd",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instAddNat",
            "Zero.toOfNat0",
            "neg_mul",
            "AddCommMonoid.toAddMonoid",
            "ZHat",
            "HasDistribNeg.toInvolutiveNeg",
            "CommRing.toRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "instHMul"
          ],
          "tactic": "rw [neg_mul, neg_eq_zero] at hN",
          "proofState": 143,
          "pos": {
            "line": 218,
            "column": 4
          },
          "goals": "x : ZHat\nN : \u2115\nhN : -\u2191(N + 1) * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 218,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Lean.Omega.Constraint.not_sat'_of_isImpossible",
            "of_decide_eq_true",
            "le_of_le_of_eq",
            "Lean.Omega.Constraint.mk",
            "Lean.Omega.Constraint.combine_sat'",
            "HSub.hSub",
            "Lean.Omega.Int.add_congr",
            "Lean.Omega.LinearCombo.eval",
            "Option.some",
            "id",
            "instDecidableEqBool",
            "Int.instNegInt",
            "Int.sub_nonneg_of_le",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Lean.Omega.Int.sub_congr",
            "List.cons",
            "Subtype.mk",
            "Lean.Omega.LinearCombo",
            "Bool.true",
            "Option.none",
            "instHAdd",
            "Lean.Omega.tidy_sat",
            "instHSub",
            "Lean.Omega.LinearCombo.coordinate_eval_0",
            "instOfNat",
            "HAdd.hAdd",
            "Lean.Omega.LinearCombo.mk",
            "Lean.Omega.Coeffs.ofList",
            "Nat",
            "LT.lt",
            "Lean.Omega.LinearCombo.add_eval",
            "Lean.Omega.LinearCombo.sub_eval",
            "Lean.Omega.LinearCombo.coordinate",
            "Decidable.byContradiction",
            "Bool",
            "Nat.decLt",
            "Int.instAdd",
            "Lean.Omega.LinearCombo.instAdd",
            "instAddNat",
            "Eq.refl",
            "Int.instSub",
            "Int.ofNat_add",
            "Lean.Omega.Int.ofNat_le_of_le",
            "instNatCastInt",
            "ZHat.eq_zero_of_mul_eq_zero",
            "instLTNat",
            "OfNat.ofNat",
            "Eq.symm",
            "Lean.Omega.Constraint.addInequality_sat",
            "Decidable.decide",
            "Eq",
            "Lean.Omega.LinearCombo.instSub",
            "Not",
            "Nat.le_of_not_lt",
            "Neg.neg",
            "Int.instLEInt",
            "Eq.trans",
            "Lean.Omega.Constraint.isImpossible",
            "Int.ofNat_nonneg",
            "List.nil"
          ],
          "tactic": "exact eq_zero_of_mul_eq_zero \u27e8N + 1, by omega\u27e9 _ hN",
          "proofState": 144,
          "pos": {
            "line": 219,
            "column": 4
          },
          "goals": "x : ZHat\nN : \u2115\nhN : \u2191(N + 1) * x = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 219,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Decidable.byContradiction"
          ],
          "tactic": "omega",
          "proofState": 145,
          "pos": {
            "line": 219,
            "column": 44
          },
          "goals": "x : ZHat\nN : \u2115\nhN : \u2191(N + 1) * x = 0\n\u22a2 0 < N + 1",
          "endPos": {
            "line": 219,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Semigroup.toMul",
            "Dvd.dvd",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "ZHat.prop",
            "RingHom",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "Nat.instSemigroup",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "Distrib.toMul",
            "Nat",
            "Nat.instDiv",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "ZHat",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "_auxLemma.15",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "have hhj := z.prop N (N * j) (by simp only [PNat.mul_coe, dvd_mul_right])",
          "proofState": 146,
          "pos": {
            "line": 223,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\n\u22a2 \u2191\u2191N * \u2191((z (N * j)).val / \u2191N) = z j",
          "endPos": {
            "line": 223,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Semigroup.toMul",
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "Nat.instSemigroup",
            "Nat",
            "of_eq_true",
            "_auxLemma.15",
            "instHMul"
          ],
          "tactic": "simp only [PNat.mul_coe, dvd_mul_right]",
          "proofState": 147,
          "pos": {
            "line": 223,
            "column": 35
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\n\u22a2 \u2191N \u2223 \u2191(N * j)",
          "endPos": {
            "line": 223,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Semigroup.toMul",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Eq.mp",
            "Nat.instSemigroup",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "Nat",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "_auxLemma.15",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rw [hz, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hhj",
          "proofState": 148,
          "pos": {
            "line": 224,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\nhhj : (ZMod.castHom \u22ef (ZMod \u2191N)) (z (N * j)) = z N\n\u22a2 \u2191\u2191N * \u2191((z (N * j)).val / \u2191N) = z j",
          "endPos": {
            "line": 224,
            "column": 89
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "instMulNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.cast_mul",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Nat.instDiv",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "ZHat",
            "CommRing.toRing",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "instHMul",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "rw [\u2190 Nat.cast_mul, mul_comm, Nat.div_mul_cancel hhj]",
          "proofState": 149,
          "pos": {
            "line": 225,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\nhhj : \u2191N \u2223 (z (N * j)).val\n\u22a2 \u2191\u2191N * \u2191((z (N * j)).val / \u2191N) = z j",
          "endPos": {
            "line": 225,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Dvd.dvd",
            "HMul.hMul",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "ZHat.prop",
            "RingHom",
            "AddMonoidWithOne.toNatCast",
            "CommMagma.toMul",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "CommSemigroup.toSemigroup",
            "Nat",
            "CommSemigroup.toCommMagma",
            "of_eq_true",
            "_auxLemma.16",
            "ZHat",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Nat.instCommSemigroup",
            "letFun",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "have hhj' := z.prop j (N * j) (by simp only [PNat.mul_coe, dvd_mul_left])",
          "proofState": 150,
          "pos": {
            "line": 226,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\nhhj : \u2191N \u2223 (z (N * j)).val\n\u22a2 \u2191(z (N * j)).val = z j",
          "endPos": {
            "line": 226,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "CommMagma.toMul",
            "CommSemigroup.toSemigroup",
            "Nat",
            "CommSemigroup.toCommMagma",
            "of_eq_true",
            "_auxLemma.16",
            "Nat.instCommSemigroup",
            "instHMul"
          ],
          "tactic": "simp only [PNat.mul_coe, dvd_mul_left]",
          "proofState": 151,
          "pos": {
            "line": 226,
            "column": 36
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\nhhj : \u2191N \u2223 (z (N * j)).val\n\u22a2 \u2191j \u2223 \u2191(N * j)",
          "endPos": {
            "line": 226,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Dvd.dvd",
            "HMul.hMul",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "RingHom",
            "id",
            "AddMonoidWithOne.toNatCast",
            "CommMagma.toMul",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "CommSemigroup.toSemigroup",
            "Nat",
            "CommSemigroup.toCommMagma",
            "of_eq_true",
            "_auxLemma.16",
            "ZHat",
            "CommRing.toRing",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Nat.instCommSemigroup",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rw [\u2190 hhj']",
          "proofState": 152,
          "pos": {
            "line": 227,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\nhhj : \u2191N \u2223 (z (N * j)).val\nhhj' : (ZMod.castHom \u22ef (ZMod \u2191j)) (z (N * j)) = z j\n\u22a2 \u2191(z (N * j)).val = z j",
          "endPos": {
            "line": 227,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Dvd.dvd",
            "HMul.hMul",
            "ZMod.cast",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "RingHom",
            "id",
            "ZMod.castHom_apply",
            "AddMonoidWithOne.toNatCast",
            "CommMagma.toMul",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "CommSemigroup.toSemigroup",
            "Nat",
            "CommSemigroup.toCommMagma",
            "of_eq_true",
            "_auxLemma.16",
            "ZHat",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Nat.instCommSemigroup",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rw [ZMod.castHom_apply, ZMod.cast_eq_val]\n  -- LaTeX proof in the notes.",
          "proofState": 153,
          "pos": {
            "line": 228,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nhz : z N = 0\nj : \u2115+\nhhj : \u2191N \u2223 (z (N * j)).val\nhhj' : (ZMod.castHom \u22ef (ZMod \u2191j)) (z (N * j)) = z j\n\u22a2 \u2191(z (N * j)).val = (ZMod.castHom \u22ef (ZMod \u2191j)) (z (N * j))",
          "endPos": {
            "line": 228,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Iff.intro"
          ],
          "tactic": "constructor",
          "proofState": 154,
          "pos": {
            "line": 232,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\n\u22a2 (\u2203 y, \u2191\u2191N * y = z) \u2194 z N = 0",
          "endPos": {
            "line": 232,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Exists",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "Distrib.toMul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "ZHat",
            "CommRing.toRing",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "intro \u27e8y, hy\u27e9",
          "proofState": 155,
          "pos": {
            "line": 233,
            "column": 4
          },
          "goals": "case mp\nN : \u2115+\nz : ZHat\n\u22a2 (\u2203 y, \u2191\u2191N * y = z) \u2192 z N = 0",
          "endPos": {
            "line": 233,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "Distrib.toMul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "rw [\u2190 hy]",
          "proofState": 156,
          "pos": {
            "line": 234,
            "column": 4
          },
          "goals": "case mp\nN : \u2115+\nz y : ZHat\nhy : \u2191\u2191N * y = z\n\u22a2 z N = 0",
          "endPos": {
            "line": 234,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "Distrib.toMul",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "change N * (y N) = 0",
          "proofState": 157,
          "pos": {
            "line": 235,
            "column": 4
          },
          "goals": "case mp\nN : \u2115+\nz y : ZHat\nhy : \u2191\u2191N * y = z\n\u22a2 (\u2191\u2191N * y) N = 0",
          "endPos": {
            "line": 235,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "CharP.cast_eq_zero",
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "MulZeroClass.zero_mul",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "ZMod.charP",
            "Distrib.toMul",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "simp [ZMod.natCast_self]",
          "proofState": 158,
          "pos": {
            "line": 236,
            "column": 4
          },
          "goals": "case mp\nN : \u2115+\nz y : ZHat\nhy : \u2191\u2191N * y = z\n\u22a2 \u2191\u2191N * y N = 0",
          "endPos": {
            "line": 236,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "PNat"
          ],
          "tactic": "intro h",
          "proofState": 159,
          "pos": {
            "line": 237,
            "column": 4
          },
          "goals": "case mpr\nN : \u2115+\nz : ZHat\n\u22a2 z N = 0 \u2192 \u2203 y, \u2191\u2191N * y = z",
          "endPos": {
            "line": 237,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "RingHom.instRingHomClass",
            "Nat.div_mul_cancel",
            "ZHat.proof_1",
            "StrictOrderedSemiring.toOrderedSemiring",
            "False",
            "Nat.instMulZeroClass",
            "Semigroup.toMul",
            "LinearOrderedSemiring.noZeroDivisors",
            "Preorder.toLT",
            "Dvd.dvd",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "ZMod.cast",
            "CommRing.toNonUnitalCommRing",
            "Subring.instSetLike",
            "ZMod.commRing",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "_auxLemma.17",
            "MulOneClass.toMul",
            "NeZero.mul",
            "Subsemigroup.mk",
            "ZMod.cast_eq_val",
            "congrArg",
            "CommSemiring.toSemiring",
            "OrderedAddCommMonoid.toPartialOrder",
            "ZMod.eq_iff_modEq_nat",
            "Nat.instMonoid",
            "PartialOrder.toPreorder",
            "semigroupDvd",
            "setOf",
            "AddGroupWithOne.toAddMonoidWithOne",
            "StrictOrderedSemiring.toSemiring",
            "ZHat.prop",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Membership.mem",
            "mul_dvd_mul",
            "Eq.mp",
            "id",
            "HDiv.hDiv",
            "Nat.instStarOrderedRing",
            "ZMod.castHom_apply",
            "AddMonoidWithOne.toNatCast",
            "Nat.instStarRing",
            "CommMagma.toMul",
            "instMulNat",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "ZMod.natCast_val",
            "ZHat.proof_6",
            "Nat.instSemigroup",
            "ZHat.proof_2",
            "Nat.instNonUnitalSemiring",
            "Nat.cast",
            "ZMod",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "ZMod.cast_id'",
            "instPNatMul",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "Nat.ModEq",
            "map_natCast",
            "ZMod.charP",
            "Nat.instDvd",
            "Subring",
            "congrFun",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Pi.ring",
            "StarOrderedRing.toExistsAddOfLE",
            "LT.lt",
            "Nat.instStrictOrderedSemiring",
            "True",
            "Subsemiring.mk",
            "CommSemigroup.toCommMagma",
            "eq_self",
            "Nat.instDiv",
            "propext",
            "ZHat.proof_3",
            "Nat.instPartialOrder",
            "mul_comm",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Submonoid.mk",
            "ZHat",
            "CommRing.toRing",
            "Nat.instLinearOrderedSemiring",
            "ZMod.natCast_zmod_eq_zero_iff_dvd",
            "OfNat.ofNat",
            "Eq.symm",
            "not_false_eq_true",
            "ZHat.proof_4",
            "Subtype.val",
            "dvd_refl",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "ZHat.proof_5",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Not",
            "Subring.mk",
            "SetLike.instMembership",
            "Nat.instCommSemigroup",
            "letFun",
            "_auxLemma.15",
            "Eq.trans",
            "Nat.ModEq.mul_right_cancel'",
            "MulZeroClass.toZero",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "let y : ZHat :=\n  { val := fun j \u21a6 (z (N * j)).val / (N : \u2115)\n    property := by\n      intro j k hjk\n      have hj := z.prop N (N * j) (by simp only [PNat.mul_coe, dvd_mul_right])\n      have hk := z.prop N (N * k) (by simp only [PNat.mul_coe, dvd_mul_right])\n      rw [h, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hj\n      rw [h, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hk\n      have hNjk := z.prop (N * j) (N * k) (mul_dvd_mul (dvd_refl _) hjk)\n      rw [ZMod.castHom_apply, ZMod.cast_eq_val] at hNjk\n      simp only [PNat.mul_coe, map_natCast, ZMod.natCast_val, ZMod.eq_iff_modEq_nat]\n      apply Nat.ModEq.mul_right_cancel' (c := N) (by simp)\n      rw [Nat.div_mul_cancel hj, Nat.div_mul_cancel hk, mul_comm (j : \u2115) (N : \u2115), \u2190 ZMod.eq_iff_modEq_nat, hNjk]\n      simp }",
          "proofState": 160,
          "pos": {
            "line": 238,
            "column": 4
          },
          "goals": "case mpr\nN : \u2115+\nz : ZHat\nh : z N = 0\n\u22a2 \u2203 y, \u2191\u2191N * y = z",
          "endPos": {
            "line": 253,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "PNat"
          ],
          "tactic": "intro j k hjk",
          "proofState": 161,
          "pos": {
            "line": 241,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\n\u22a2 (fun j => \u2191((z (N * j)).val / \u2191N)) \u2208\n    { carrier := {f | \u2200 (D N : \u2115+) (h : \u2191D \u2223 \u2191N), (ZMod.castHom h (ZMod \u2191D)) (f N) = f D}, mul_mem' := @proof_2,\n      one_mem' := proof_3, add_mem' := @proof_4, zero_mem' := proof_5, neg_mem' := @proof_6 }",
          "endPos": {
            "line": 241,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZHat.proof_1",
            "Semigroup.toMul",
            "Dvd.dvd",
            "instHDiv",
            "HMul.hMul",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "ZHat.prop",
            "RingHom",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "Nat.instSemigroup",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "Nat",
            "Nat.instDiv",
            "of_eq_true",
            "ZHat",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "_auxLemma.15",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "have hj := z.prop N (N * j) (by simp only [PNat.mul_coe, dvd_mul_right])",
          "proofState": 162,
          "pos": {
            "line": 242,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\n\u22a2 (ZMod.castHom hjk (ZMod \u2191j)) ((fun j => \u2191((z (N * j)).val / \u2191N)) k) = (fun j => \u2191((z (N * j)).val / \u2191N)) j",
          "endPos": {
            "line": 242,
            "column": 80
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Semigroup.toMul",
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "Nat.instSemigroup",
            "Nat",
            "of_eq_true",
            "_auxLemma.15",
            "instHMul"
          ],
          "tactic": "simp only [PNat.mul_coe, dvd_mul_right]",
          "proofState": 163,
          "pos": {
            "line": 242,
            "column": 40
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\n\u22a2 \u2191N \u2223 \u2191(N * j)",
          "endPos": {
            "line": 242,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZHat.proof_1",
            "Semigroup.toMul",
            "Dvd.dvd",
            "instHDiv",
            "HMul.hMul",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "AddGroupWithOne.toAddMonoidWithOne",
            "ZHat.prop",
            "RingHom",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "Nat.instSemigroup",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "Nat",
            "Nat.instDiv",
            "of_eq_true",
            "ZHat",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "_auxLemma.15",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "have hk := z.prop N (N * k) (by simp only [PNat.mul_coe, dvd_mul_right])",
          "proofState": 164,
          "pos": {
            "line": 243,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : (ZMod.castHom \u22ef (ZMod \u2191N)) (z (N * j)) = z N\n\u22a2 (ZMod.castHom hjk (ZMod \u2191j)) ((fun j => \u2191((z (N * j)).val / \u2191N)) k) = (fun j => \u2191((z (N * j)).val / \u2191N)) j",
          "endPos": {
            "line": 243,
            "column": 80
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Semigroup.toMul",
            "Dvd.dvd",
            "HMul.hMul",
            "semigroupDvd",
            "Nat.instSemigroup",
            "Nat",
            "of_eq_true",
            "_auxLemma.15",
            "instHMul"
          ],
          "tactic": "simp only [PNat.mul_coe, dvd_mul_right]",
          "proofState": 165,
          "pos": {
            "line": 243,
            "column": 40
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : (ZMod.castHom \u22ef (ZMod \u2191N)) (z (N * j)) = z N\n\u22a2 \u2191N \u2223 \u2191(N * k)",
          "endPos": {
            "line": 243,
            "column": 79
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [h, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hj",
          "proofState": 166,
          "pos": {
            "line": 244,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : (ZMod.castHom \u22ef (ZMod \u2191N)) (z (N * j)) = z N\nhk : (ZMod.castHom \u22ef (ZMod \u2191N)) (z (N * k)) = z N\n\u22a2 (ZMod.castHom hjk (ZMod \u2191j)) ((fun j => \u2191((z (N * j)).val / \u2191N)) k) = (fun j => \u2191((z (N * j)).val / \u2191N)) j",
          "endPos": {
            "line": 244,
            "column": 93
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Semigroup.toMul",
            "Dvd.dvd",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "semigroupDvd",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Eq.mp",
            "Nat.instSemigroup",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "Nat",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "_auxLemma.15",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rw [h, ZMod.castHom_apply, ZMod.cast_eq_val, ZMod.natCast_zmod_eq_zero_iff_dvd] at hk",
          "proofState": 167,
          "pos": {
            "line": 245,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : (ZMod.castHom \u22ef (ZMod \u2191N)) (z (N * k)) = z N\n\u22a2 (ZMod.castHom hjk (ZMod \u2191j)) ((fun j => \u2191((z (N * j)).val / \u2191N)) k) = (fun j => \u2191((z (N * j)).val / \u2191N)) j",
          "endPos": {
            "line": 245,
            "column": 93
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "PNat.val",
            "ZHat.proof_1",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Preorder.toLT",
            "instHDiv",
            "HMul.hMul",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "OrderedAddCommMonoid.toPartialOrder",
            "Nat.instMonoid",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "StrictOrderedSemiring.toSemiring",
            "ZHat.prop",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "mul_dvd_mul",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "LT.lt",
            "Nat.instStrictOrderedSemiring",
            "Nat.instDiv",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Subtype.val",
            "dvd_refl",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Nat.instCommSemigroup",
            "letFun",
            "MulZeroClass.toZero",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "have hNjk := z.prop (N * j) (N * k) (mul_dvd_mul (dvd_refl _) hjk)",
          "proofState": 168,
          "pos": {
            "line": 246,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : \u2191N \u2223 (z (N * k)).val\n\u22a2 (ZMod.castHom hjk (ZMod \u2191j)) ((fun j => \u2191((z (N * j)).val / \u2191N)) k) = (fun j => \u2191((z (N * j)).val / \u2191N)) j",
          "endPos": {
            "line": 246,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "PNat.val",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Preorder.toLT",
            "HMul.hMul",
            "ZMod.cast",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "OrderedAddCommMonoid.toPartialOrder",
            "Nat.instMonoid",
            "PartialOrder.toPreorder",
            "StrictOrderedSemiring.toSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "mul_dvd_mul",
            "Eq.mp",
            "ZMod.castHom_apply",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "ZMod.charP",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "LT.lt",
            "Nat.instStrictOrderedSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Subtype.val",
            "dvd_refl",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Nat.instCommSemigroup",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "rw [ZMod.castHom_apply, ZMod.cast_eq_val] at hNjk",
          "proofState": 169,
          "pos": {
            "line": 247,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : \u2191N \u2223 (z (N * k)).val\nhNjk : (ZMod.castHom \u22ef (ZMod \u2191(N * j))) (z (N * k)) = z (N * j)\n\u22a2 (ZMod.castHom hjk (ZMod \u2191j)) ((fun j => \u2191((z (N * j)).val / \u2191N)) k) = (fun j => \u2191((z (N * j)).val / \u2191N)) j",
          "endPos": {
            "line": 247,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "RingHom.instRingHomClass",
            "ZHat.proof_1",
            "instHDiv",
            "HMul.hMul",
            "ZMod.commRing",
            "_auxLemma.17",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "RingHom",
            "id",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "instMulNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "ZMod",
            "instPNatMul",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "RingHom.instFunLike",
            "Nat.ModEq",
            "map_natCast",
            "Nat",
            "Nat.instDiv",
            "ZHat",
            "CommRing.toRing",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "instHMul",
            "ZMod.val",
            "PNat",
            "ZMod.castHom"
          ],
          "tactic": "simp only [PNat.mul_coe, map_natCast, ZMod.natCast_val, ZMod.eq_iff_modEq_nat]",
          "proofState": 170,
          "pos": {
            "line": 248,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : \u2191N \u2223 (z (N * k)).val\nhNjk : \u2191(z (N * k)).val = z (N * j)\n\u22a2 (ZMod.castHom hjk (ZMod \u2191j)) ((fun j => \u2191((z (N * j)).val / \u2191N)) k) = (fun j => \u2191((z (N * j)).val / \u2191N)) j",
          "endPos": {
            "line": 248,
            "column": 86
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "instHDiv",
            "HMul.hMul",
            "HDiv.hDiv",
            "instMulNat",
            "ZMod",
            "instPNatMul",
            "ZHat.instDFunLikePNatZModVal",
            "Nat",
            "Nat.instDiv",
            "ZHat",
            "DFunLike.coe",
            "Nat.ModEq.mul_right_cancel'",
            "instHMul",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "apply Nat.ModEq.mul_right_cancel' (c := N) (by simp)",
          "proofState": 171,
          "pos": {
            "line": 249,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : \u2191N \u2223 (z (N * k)).val\nhNjk : \u2191(z (N * k)).val = z (N * j)\n\u22a2 (z (N * k)).val / \u2191N \u2261 (z (N * j)).val / \u2191N [MOD \u2191j]",
          "endPos": {
            "line": 249,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "False",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "congrArg",
            "instOfNatNat",
            "Nat",
            "True",
            "of_eq_true",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Not",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 172,
          "pos": {
            "line": 249,
            "column": 55
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : \u2191N \u2223 (z (N * k)).val\nhNjk : \u2191(z (N * k)).val = z (N * j)\n\u22a2 \u2191N \u2260 0",
          "endPos": {
            "line": 249,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Eq.mpr",
            "Nat.div_mul_cancel",
            "instHDiv",
            "HMul.hMul",
            "congrArg",
            "id",
            "HDiv.hDiv",
            "instMulNat",
            "ZMod",
            "instPNatMul",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.ModEq",
            "Nat",
            "Nat.instDiv",
            "ZHat",
            "Eq",
            "DFunLike.coe",
            "instHMul",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "rw [Nat.div_mul_cancel hj, Nat.div_mul_cancel hk, mul_comm (j : \u2115) (N : \u2115), \u2190 ZMod.eq_iff_modEq_nat, hNjk]",
          "proofState": 173,
          "pos": {
            "line": 250,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : \u2191N \u2223 (z (N * k)).val\nhNjk : \u2191(z (N * k)).val = z (N * j)\n\u22a2 (z (N * k)).val / \u2191N * \u2191N \u2261 (z (N * j)).val / \u2191N * \u2191N [MOD \u2191j * \u2191N]",
          "endPos": {
            "line": 251,
            "column": 66
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "Nat.instMulZeroClass",
            "LinearOrderedSemiring.noZeroDivisors",
            "HMul.hMul",
            "ZMod.cast",
            "ZMod.commRing",
            "NeZero.mul",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "Nat.instStarOrderedRing",
            "AddMonoidWithOne.toNatCast",
            "Nat.instStarRing",
            "CommMagma.toMul",
            "instMulNat",
            "ZMod.natCast_val",
            "Nat.instNonUnitalSemiring",
            "Nat.cast",
            "ZMod",
            "ZMod.cast_id'",
            "instPNatMul",
            "NeZero.pnat",
            "ZHat.instDFunLikePNatZModVal",
            "congrFun",
            "Nat",
            "StarOrderedRing.toExistsAddOfLE",
            "True",
            "CommSemigroup.toCommMagma",
            "eq_self",
            "Nat.instPartialOrder",
            "of_eq_true",
            "ZHat",
            "CommRing.toRing",
            "Nat.instLinearOrderedSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Nat.instCommSemigroup",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "simp",
          "proofState": 174,
          "pos": {
            "line": 252,
            "column": 8
          },
          "goals": "N : \u2115+\nz : ZHat\nh : z N = 0\nj k : \u2115+\nhjk : \u2191j \u2223 \u2191k\nhj : \u2191N \u2223 (z (N * j)).val\nhk : \u2191N \u2223 (z (N * k)).val\nhNjk : \u2191(z (N * k)).val = z (N * j)\n\u22a2 z (N * j) = \u2191(z (N * j)).val",
          "endPos": {
            "line": 252,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "Distrib.toMul",
            "Exists.intro",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "ZHat",
            "CommRing.toRing",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "refine \u27e8y, ?_\u27e9",
          "proofState": 175,
          "pos": {
            "line": 254,
            "column": 4
          },
          "goals": "case mpr\nN : \u2115+\nz : ZHat\nh : z N = 0\ny : ZHat := \u27e8fun j => \u2191((z (N * j)).val / \u2191N), \u22ef\u27e9\n\u22a2 \u2203 y, \u2191\u2191N * y = z",
          "endPos": {
            "line": 254,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "ZHat.ext"
          ],
          "tactic": "ext j",
          "proofState": 176,
          "pos": {
            "line": 255,
            "column": 4
          },
          "goals": "case mpr\nN : \u2115+\nz : ZHat\nh : z N = 0\ny : ZHat := \u27e8fun j => \u2191((z (N * j)).val / \u2191N), \u22ef\u27e9\n\u22a2 \u2191\u2191N * y = z",
          "endPos": {
            "line": 255,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "ZHat.y_mul_N_eq_z"
          ],
          "tactic": "exact y_mul_N_eq_z N z h j",
          "proofState": 177,
          "pos": {
            "line": 256,
            "column": 4
          },
          "goals": "case mpr.h\nN : \u2115+\nz : ZHat\nh : z N = 0\ny : ZHat := \u27e8fun j => \u2191((z (N * j)).val / \u2191N), \u22ef\u27e9\nj : \u2115+\n\u22a2 (\u2191\u2191N * y) j = z j",
          "endPos": {
            "line": 256,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "Nat",
            "ZHat",
            "DFunLike.coe",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "let r : \u2115 := (z N : ZMod N).val",
          "proofState": 178,
          "pos": {
            "line": 261,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\n\u22a2 \u2203 q r, z = \u2191\u2191N * q + \u2191r \u2227 r < \u2191N",
          "endPos": {
            "line": 261,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "AddGroupWithOne.toAddGroup",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "SubNegMonoid.toSub",
            "instHAdd",
            "And",
            "ZHat.instDFunLikePNatZModVal",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "LT.lt",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "instLTNat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "letFun",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "have h : (z - r) N = 0 := by change z N - r = 0; simp [r]",
          "proofState": 179,
          "pos": {
            "line": 262,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nr : \u2115 := (z N).val\n\u22a2 \u2203 q r, z = \u2191\u2191N * q + \u2191r \u2227 r < \u2191N",
          "endPos": {
            "line": 262,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "ZHat.instDFunLikePNatZModVal",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "PNat"
          ],
          "tactic": "change z N - r = 0",
          "proofState": 180,
          "pos": {
            "line": 262,
            "column": 31
          },
          "goals": "N : \u2115+\nz : ZHat\nr : \u2115 := (z N).val\n\u22a2 (z - \u2191r) N = 0",
          "endPos": {
            "line": 262,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "ZMod.cast",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "sub_self",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "ZMod.natCast_val",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.cast",
            "ZMod",
            "ZMod.cast_id'",
            "SubNegMonoid.toSub",
            "NeZero.pnat",
            "ZHat.instDFunLikePNatZModVal",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "congrFun",
            "True",
            "eq_self",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "ZMod.val",
            "PNat"
          ],
          "tactic": "simp [r]",
          "proofState": 181,
          "pos": {
            "line": 262,
            "column": 51
          },
          "goals": "N : \u2115+\nz : ZHat\nr : \u2115 := (z N).val\n\u22a2 z N - \u2191r = 0",
          "endPos": {
            "line": 262,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "ZHat.multiples",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "Eq.mp",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "ZMod",
            "SubNegMonoid.toSub",
            "ZHat.instDFunLikePNatZModVal",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "propext",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "ZHat",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "MulZeroClass.toZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "rw [\u2190 multiples] at h",
          "proofState": 182,
          "pos": {
            "line": 263,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nr : \u2115 := (z N).val\nh : (z - \u2191r) N = 0\n\u22a2 \u2203 q r, z = \u2191\u2191N * q + \u2191r \u2227 r < \u2191N",
          "endPos": {
            "line": 263,
            "column": 23
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8q, hq\u27e9 := h",
          "proofState": 183,
          "pos": {
            "line": 264,
            "column": 2
          },
          "goals": "N : \u2115+\nz : ZHat\nr : \u2115 := (z N).val\nh : \u2203 y, \u2191\u2191N * y = z - \u2191r\n\u22a2 \u2203 q r, z = \u2191\u2191N * q + \u2191r \u2227 r < \u2191N",
          "endPos": {
            "line": 264,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "ZHat.commRing",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "AddCancelMonoid.toIsCancelAdd",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Exists",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.cast_zero",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.LinearCombination.eq_rearrange",
            "SubNegZeroMonoid.toNegZeroClass",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.cast",
            "ZMod",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "And",
            "NeZero.pnat",
            "CommRing.toCommSemiring",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "ZHat.instDFunLikePNatZModVal",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "And.intro",
            "LT.lt",
            "Exists.intro",
            "Mathlib.Tactic.LinearCombination.eq_of_eq",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "ZHat",
            "instHPow",
            "Nat.cast_zero",
            "instLTNat",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddGroup.toAddCancelMonoid",
            "OfNat.ofNat",
            "Eq.symm",
            "NegZeroClass.toZero",
            "ZMod.val_lt",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "IsCancelAdd.toIsRightCancelAdd",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "exact \u27e8q, r, by linear_combination -hq, ZMod.val_lt (z N)\u27e9",
          "proofState": 184,
          "pos": {
            "line": 265,
            "column": 2
          },
          "goals": "case intro\nN : \u2115+\nz : ZHat\nr : \u2115 := (z N).val\nq : ZHat\nhq : \u2191\u2191N * q = z - \u2191r\n\u22a2 \u2203 q r, z = \u2191\u2191N * q + \u2191r \u2227 r < \u2191N",
          "endPos": {
            "line": 265,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddGroup",
            "ZHat.commRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "AddCancelMonoid.toIsCancelAdd",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "Nat.cast",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Tactic.LinearCombination.eq_of_eq",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "ZHat",
            "CommRing.toRing",
            "AddGroup.toAddCancelMonoid",
            "Eq.symm",
            "Ring.toAddGroupWithOne",
            "IsCancelAdd.toIsRightCancelAdd",
            "instHMul"
          ],
          "tactic": "linear_combination -hq",
          "proofState": 185,
          "pos": {
            "line": 265,
            "column": 18
          },
          "goals": "N : \u2115+\nz : ZHat\nr : \u2115 := (z N).val\nq : ZHat\nhq : \u2191\u2191N * q = z - \u2191r\n\u22a2 z = \u2191\u2191N * q + \u2191r",
          "endPos": {
            "line": 265,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "Rat",
            "Int",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Ring.toAddCommGroup",
            "TensorProduct.induction_on",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "ZHat",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "Rat.addCommGroup"
          ],
          "tactic": "induction z using TensorProduct.induction_on with\n| zero =>\n  refine \u27e81, 0, ?_\u27e9\n  simp\n| tmul q z =>\n  refine \u27e8\u27e8q.den, q.den_pos\u27e9, q.num * z, ?_\u27e9\n  simp_rw [\u2190 zsmul_eq_mul, TensorProduct.tmul_smul, TensorProduct.smul_tmul']\n  simp only [PNat.mk_coe, zsmul_eq_mul]\n  simp only [\u2190 q.mul_den_eq_num, LinearMap.mul_apply', mul_assoc, one_div, ne_eq, Nat.cast_eq_zero, Rat.den_ne_zero,\n    not_false_eq_true, mul_inv_cancel, mul_one, mul_inv_cancel\u2080]\n| add x y hx hy =>\n  obtain \u27e8N\u2081, z\u2081, rfl\u27e9 := hx\n  obtain \u27e8N\u2082, z\u2082, rfl\u27e9 := hy\n  refine \u27e8N\u2081 * N\u2082, (N\u2081 : \u2124) * z\u2082 + (N\u2082 : \u2124) * z\u2081, ?_\u27e9\n  simp only [TensorProduct.tmul_add, \u2190 zsmul_eq_mul, TensorProduct.tmul_smul, TensorProduct.smul_tmul']\n  simp only [one_div, PNat.mul_coe, Nat.cast_mul, mul_inv_rev, zsmul_eq_mul, Int.cast_natCast, ne_eq, Nat.cast_eq_zero,\n    PNat.ne_zero, not_false_eq_true, mul_inv_cancel_left\u2080]\n  rw [add_comm]\n  congr\n  simp [mul_comm]",
          "proofState": 186,
          "pos": {
            "line": 279,
            "column": 2
          },
          "goals": "z : QHat\n\u22a2 \u2203 N z', z = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'",
          "endPos": {
            "line": 300,
            "column": 19
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction z using TensorProduct.induction_on with\n| zero =>\n  refine \u27e81, 0, ?_\u27e9\n  simp\n| tmul q z =>\n  refine \u27e8\u27e8q.den, q.den_pos\u27e9, q.num * z, ?_\u27e9\n  simp_rw [\u2190 zsmul_eq_mul, TensorProduct.tmul_smul, TensorProduct.smul_tmul']\n  simp only [PNat.mk_coe, zsmul_eq_mul]\n  simp only [\u2190 q.mul_den_eq_num, LinearMap.mul_apply', mul_assoc, one_div, ne_eq, Nat.cast_eq_zero, Rat.den_ne_zero,\n    not_false_eq_true, mul_inv_cancel, mul_one, mul_inv_cancel\u2080]\n| add x y hx hy =>\n  obtain \u27e8N\u2081, z\u2081, rfl\u27e9 := hx\n  obtain \u27e8N\u2082, z\u2082, rfl\u27e9 := hy\n  refine \u27e8N\u2081 * N\u2082, (N\u2081 : \u2124) * z\u2082 + (N\u2082 : \u2124) * z\u2081, ?_\u27e9\n  simp only [TensorProduct.tmul_add, \u2190 zsmul_eq_mul, TensorProduct.tmul_smul, TensorProduct.smul_tmul']\n  simp only [one_div, PNat.mul_coe, Nat.cast_mul, mul_inv_rev, zsmul_eq_mul, Int.cast_natCast, ne_eq, Nat.cast_eq_zero,\n    PNat.ne_zero, not_false_eq_true, mul_inv_cancel_left\u2080]\n  rw [add_comm]\n  congr\n  simp [mul_comm]",
          "proofState": 187,
          "pos": {
            "line": 279,
            "column": 2
          },
          "goals": "z : QHat\n\u22a2 \u2203 N z', z = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'",
          "endPos": {
            "line": 300,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "Rat",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "HDiv.hDiv",
            "instOfNatPNatOfNeZeroNat",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "TensorProduct.zero",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Nat.instNeZeroSucc",
            "Ring.toAddCommGroup",
            "Nat",
            "Exists.intro",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "MulZeroClass.toZero",
            "PNat"
          ],
          "tactic": "refine \u27e81, 0, ?_\u27e9",
          "proofState": 188,
          "pos": {
            "line": 281,
            "column": 4
          },
          "goals": "case zero\n\u22a2 \u2203 N z', 0 = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'",
          "endPos": {
            "line": 281,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "GroupWithZero.toMonoidWithZero",
            "False",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "InvOneClass.toOne",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "congrArg",
            "NeZero.charZero_one",
            "ZHat.commRing",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "DivisionMonoid.toDivInvOneMonoid",
            "TensorProduct.tmul_zero",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "TensorProduct.zero",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "Ring.toAddCommGroup",
            "Nat",
            "True",
            "eq_self",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "Mathlib.Algebra.NeZero._auxLemma.3",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "Not",
            "Rat.instDiv",
            "div_self",
            "Rat.addCommGroup",
            "Eq.trans",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp",
          "proofState": 189,
          "pos": {
            "line": 282,
            "column": 4
          },
          "goals": "case zero\n\u22a2 0 = (1 / \u2191\u21911) \u2297\u209c[\u2124] 0",
          "endPos": {
            "line": 282,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.num",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "Rat",
            "Rat.den",
            "Exists",
            "HDiv.hDiv",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "Nat",
            "LT.lt",
            "Exists.intro",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "QHat",
            "Rat.den_pos",
            "ZHat",
            "TensorProduct.tmul",
            "instLTNat",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul",
            "PNat"
          ],
          "tactic": "refine \u27e8\u27e8q.den, q.den_pos\u27e9, q.num * z, ?_\u27e9",
          "proofState": 190,
          "pos": {
            "line": 284,
            "column": 4
          },
          "goals": "case tmul\nq : \u211a\nz : ZHat\n\u22a2 \u2203 N z', q \u2297\u209c[\u2124] z = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'",
          "endPos": {
            "line": 284,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "Rat.num",
            "instHSMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "ZHat.commRing",
            "Rat",
            "Rat.den",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "_auxLemma.18",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "Nat",
            "LT.lt",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "HSMul.hSMul",
            "QHat",
            "Rat.den_pos",
            "ZHat",
            "TensorProduct.tmul",
            "instLTNat",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul",
            "SubNegMonoid.toZSMul"
          ],
          "tactic": "simp_rw [\u2190 zsmul_eq_mul, TensorProduct.tmul_smul, TensorProduct.smul_tmul']",
          "proofState": 191,
          "pos": {
            "line": 285,
            "column": 4
          },
          "goals": "case tmul\nq : \u211a\nz : ZHat\n\u22a2 q \u2297\u209c[\u2124] z = (1 / \u2191\u2191\u27e8q.den, \u22ef\u27e9) \u2297\u209c[\u2124] (\u2191q.num * z)",
          "endPos": {
            "line": 285,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "zsmul_eq_mul",
            "Rat.num",
            "instHSMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "DistribMulAction.toDistribSMul",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "Rat.den",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DistribSMul.toSMulZeroClass",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "Nat",
            "AddZeroClass.toZero",
            "LT.lt",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "QHat",
            "AddCommMonoid.toAddMonoid",
            "Rat.den_pos",
            "ZHat",
            "TensorProduct.tmul",
            "instLTNat",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Rat.instDiv",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "SubNegMonoid.toZSMul"
          ],
          "tactic": "simp only [PNat.mk_coe, zsmul_eq_mul]",
          "proofState": 192,
          "pos": {
            "line": 286,
            "column": 4
          },
          "goals": "case tmul\nq : \u211a\nz : ZHat\n\u22a2 q \u2297\u209c[\u2124] z = (q.num \u2022 (1 / \u2191\u2191\u27e8q.den, \u22ef\u27e9)) \u2297\u209c[\u2124] z",
          "endPos": {
            "line": 286,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "GroupWithZero.toMonoidWithZero",
            "False",
            "Semigroup.toMul",
            "Rat.instMul",
            "DivInvMonoid.toInv",
            "Rat.num",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedSemifield.toSemifield",
            "mul_inv_cancel\u2080",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "mul_assoc",
            "AddGroupWithOne.toAddMonoidWithOne",
            "_auxLemma.13",
            "DivisionSemiring.toGroupWithZero",
            "Rat.den",
            "DivisionRing.toDivInvMonoid",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Rat.instDivisionRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "_auxLemma.19",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Rat.semigroup",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "Rat.mul_den_eq_num",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "one_div",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "mul_one",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Not",
            "Rat.addCommGroup",
            "Eq.trans",
            "Rat.instNatCast",
            "instHMul"
          ],
          "tactic": "simp only [\u2190 q.mul_den_eq_num, LinearMap.mul_apply', mul_assoc, one_div, ne_eq, Nat.cast_eq_zero, Rat.den_ne_zero,\n  not_false_eq_true, mul_inv_cancel, mul_one, mul_inv_cancel\u2080]",
          "proofState": 193,
          "pos": {
            "line": 287,
            "column": 4
          },
          "goals": "case tmul\nq : \u211a\nz : ZHat\n\u22a2 q \u2297\u209c[\u2124] z = (\u2191q.num * (1 / \u2191q.den)) \u2297\u209c[\u2124] z",
          "endPos": {
            "line": 289,
            "column": 47
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8N\u2081, z\u2081, rfl\u27e9 := hx",
          "proofState": 194,
          "pos": {
            "line": 291,
            "column": 4
          },
          "goals": "case add\nx y : TensorProduct \u2124 \u211a ZHat\nhx : \u2203 N z', x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'\nhy : \u2203 N z', y = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'\n\u22a2 \u2203 N z', x + y = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'",
          "endPos": {
            "line": 291,
            "column": 30
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8N\u2082, z\u2082, rfl\u27e9 := hy",
          "proofState": 195,
          "pos": {
            "line": 292,
            "column": 4
          },
          "goals": "case add.intro.intro\ny : TensorProduct \u2124 \u211a ZHat\nhy : \u2203 N z', y = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'\nN\u2081 : \u2115+\nz\u2081 : ZHat\n\u22a2 \u2203 N z', (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 + y = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'",
          "endPos": {
            "line": 292,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "ZHat.commRing",
            "Rat",
            "Exists",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "instPNatMul",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Exists.intro",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "QHat",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul",
            "PNat"
          ],
          "tactic": "refine \u27e8N\u2081 * N\u2082, (N\u2081 : \u2124) * z\u2082 + (N\u2082 : \u2124) * z\u2081, ?_\u27e9",
          "proofState": 196,
          "pos": {
            "line": 293,
            "column": 4
          },
          "goals": "case add.intro.intro.intro.intro\nN\u2081 : \u2115+\nz\u2081 : ZHat\nN\u2082 : \u2115+\nz\u2082 : ZHat\n\u22a2 \u2203 N z', (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 + (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z'",
          "endPos": {
            "line": 293,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "TensorProduct.leftHasSMul",
            "instHSMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "DistribMulAction.toDistribSMul",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "TensorProduct.tmul_smul",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DistribSMul.toSMulZeroClass",
            "Int",
            "AddGroupWithOne.toIntCast",
            "_auxLemma.18",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instPNatMul",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "TensorProduct.CompatibleSMul.int",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "congr",
            "AddZeroClass.toZero",
            "AddGroup.int_smulCommClass",
            "AddCommGroup.toIntModule",
            "TensorProduct.tmul_add",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "QHat",
            "AddCommMonoid.toAddMonoid",
            "Rat.addGroup",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Eq.trans",
            "Rat.instNatCast",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "SubNegMonoid.toZSMul",
            "PNat"
          ],
          "tactic": "simp only [TensorProduct.tmul_add, \u2190 zsmul_eq_mul, TensorProduct.tmul_smul, TensorProduct.smul_tmul']",
          "proofState": 197,
          "pos": {
            "line": 294,
            "column": 4
          },
          "goals": "case add.intro.intro.intro.intro\nN\u2081 : \u2115+\nz\u2081 : ZHat\nN\u2082 : \u2115+\nz\u2082 : ZHat\n\u22a2 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 + (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 = (1 / \u2191\u2191(N\u2081 * N\u2082)) \u2297\u209c[\u2124] (\u2191\u2191\u2191N\u2081 * z\u2082 + \u2191\u2191\u2191N\u2082 * z\u2081)",
          "endPos": {
            "line": 295,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Int.cast_natCast",
            "zsmul_eq_mul",
            "False",
            "mul_inv_cancel_left\u2080",
            "DivInvMonoid.toInv",
            "instHSMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "Ring.toNonAssocRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "DistribMulAction.toDistribSMul",
            "_auxLemma.20",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "_auxLemma.13",
            "DivisionSemiring.toGroupWithZero",
            "DivisionRing.toDivInvMonoid",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DistribSMul.toSMulZeroClass",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Rat.instDivisionRing",
            "instMulNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instPNatMul",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "Nat.cast_mul",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "one_div",
            "True",
            "MulOneClass.toOne",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Rat.commGroupWithZero",
            "Zero.toOfNat0",
            "TensorProduct",
            "CommGroupWithZero.toDivisionCommMonoid",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "QHat",
            "AddCommMonoid.toAddMonoid",
            "instNatCastInt",
            "mul_inv_rev",
            "ZHat",
            "TensorProduct.tmul",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Not",
            "Rat.instDiv",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Eq.trans",
            "Rat.instNatCast",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "PNat"
          ],
          "tactic": "simp only [one_div, PNat.mul_coe, Nat.cast_mul, mul_inv_rev, zsmul_eq_mul, Int.cast_natCast, ne_eq, Nat.cast_eq_zero,\n  PNat.ne_zero, not_false_eq_true, mul_inv_cancel_left\u2080]",
          "proofState": 198,
          "pos": {
            "line": 296,
            "column": 4
          },
          "goals": "case add.intro.intro.intro.intro\nN\u2081 : \u2115+\nz\u2081 : ZHat\nN\u2082 : \u2115+\nz\u2082 : ZHat\n\u22a2 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 + (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 = (\u2191\u2191N\u2081 \u2022 (1 / \u2191\u2191(N\u2081 * N\u2082))) \u2297\u209c[\u2124] z\u2082 + (\u2191\u2191N\u2082 \u2022 (1 / \u2191\u2191(N\u2081 * N\u2082))) \u2297\u209c[\u2124] z\u2081",
          "endPos": {
            "line": 297,
            "column": 85
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "DivInvMonoid.toInv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "TensorProduct.add",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "Ring.toNonAssocRing",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "ZHat.commRing",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionRing.toDivInvMonoid",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Rat.instDivisionRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "TensorProduct.addCommSemigroup",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "add_comm",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "Inv.inv",
            "Rat.instNormedField",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Rat.commGroupWithZero",
            "TensorProduct",
            "CommGroupWithZero.toDivisionCommMonoid",
            "QHat",
            "AddCommSemigroup.toAddCommMagma",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "AddCommMagma.toAdd",
            "instHMul"
          ],
          "tactic": "rw [add_comm]",
          "proofState": 199,
          "pos": {
            "line": 298,
            "column": 4
          },
          "goals": "case add.intro.intro.intro.intro\nN\u2081 : \u2115+\nz\u2081 : ZHat\nN\u2082 : \u2115+\nz\u2082 : ZHat\n\u22a2 (\u2191\u2191N\u2081)\u207b\u00b9 \u2297\u209c[\u2124] z\u2081 + (\u2191\u2191N\u2082)\u207b\u00b9 \u2297\u209c[\u2124] z\u2082 = (\u2191\u2191N\u2081 * ((\u2191\u2191N\u2082)\u207b\u00b9 * (\u2191\u2191N\u2081)\u207b\u00b9)) \u2297\u209c[\u2124] z\u2082 + (\u2191\u2191N\u2081)\u207b\u00b9 \u2297\u209c[\u2124] z\u2081",
          "endPos": {
            "line": 298,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Eq.rec",
            "HAdd",
            "HAdd.hAdd",
            "Eq.refl",
            "Eq"
          ],
          "tactic": "congr",
          "proofState": 200,
          "pos": {
            "line": 299,
            "column": 4
          },
          "goals": "case add.intro.intro.intro.intro\nN\u2081 : \u2115+\nz\u2081 : ZHat\nN\u2082 : \u2115+\nz\u2082 : ZHat\n\u22a2 (\u2191\u2191N\u2082)\u207b\u00b9 \u2297\u209c[\u2124] z\u2082 + (\u2191\u2191N\u2081)\u207b\u00b9 \u2297\u209c[\u2124] z\u2081 = (\u2191\u2191N\u2081 * ((\u2191\u2191N\u2082)\u207b\u00b9 * (\u2191\u2191N\u2081)\u207b\u00b9)) \u2297\u209c[\u2124] z\u2082 + (\u2191\u2191N\u2081)\u207b\u00b9 \u2297\u209c[\u2124] z\u2081",
          "endPos": {
            "line": 299,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "mul_inv_cancel_left\u2080",
            "DivInvMonoid.toInv",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "Ring.toNonAssocRing",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "DivisionRing.toDivInvMonoid",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Rat.instDivisionRing",
            "CommMagma.toMul",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "Distrib.toMul",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "mul_comm",
            "of_eq_true",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Rat.commGroupWithZero",
            "Zero.toOfNat0",
            "CommGroupWithZero.toDivisionCommMonoid",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans",
            "Rat.instNatCast",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [mul_comm]",
          "proofState": 201,
          "pos": {
            "line": 300,
            "column": 4
          },
          "goals": "case add.intro.intro.intro.intro.e_a.e_m\nN\u2081 : \u2115+\nz\u2081 : ZHat\nN\u2082 : \u2115+\nz\u2082 : ZHat\n\u22a2 (\u2191\u2191N\u2082)\u207b\u00b9 = \u2191\u2191N\u2081 * ((\u2191\u2191N\u2082)\u207b\u00b9 * (\u2191\u2191N\u2081)\u207b\u00b9)",
          "endPos": {
            "line": 300,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "ZHat"
          ],
          "tactic": "intro a b h",
          "proofState": 202,
          "pos": {
            "line": 312,
            "column": 6
          },
          "goals": "\u22a2 Function.Injective \u21d1i\u2082",
          "endPos": {
            "line": 312,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "LinearMap.rTensor_tmul",
            "CommSemiring.toSemiring",
            "TensorProduct.addCommMonoid",
            "ZHat.commRing",
            "Rat",
            "LinearMap.instFunLike",
            "Algebra.toModule",
            "Algebra.linearMap",
            "Int",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Rat.instNormedField",
            "instOfNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "letFun",
            "TensorProduct.instModule",
            "LinearMap.rTensor"
          ],
          "tactic": "have h\u2081 := LinearMap.rTensor_tmul ZHat (f := Algebra.linearMap \u2124 \u211a) a 1",
          "proofState": 203,
          "pos": {
            "line": 313,
            "column": 6
          },
          "goals": "a b : ZHat\nh : i\u2082 a = i\u2082 b\n\u22a2 a = b",
          "endPos": {
            "line": 313,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "LinearMap.rTensor_tmul",
            "CommSemiring.toSemiring",
            "TensorProduct.addCommMonoid",
            "ZHat.commRing",
            "Rat",
            "LinearMap.instFunLike",
            "Algebra.toModule",
            "Algebra.linearMap",
            "Int",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Rat.instNormedField",
            "instOfNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "letFun",
            "TensorProduct.instModule",
            "LinearMap.rTensor"
          ],
          "tactic": "have h\u2082 := LinearMap.rTensor_tmul ZHat (f := Algebra.linearMap \u2124 \u211a) b 1",
          "proofState": 204,
          "pos": {
            "line": 314,
            "column": 6
          },
          "goals": "a b : ZHat\nh : i\u2082 a = i\u2082 b\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = (Algebra.linearMap \u2124 \u211a) 1 \u2297\u209c[\u2124] a\n\u22a2 a = b",
          "endPos": {
            "line": 314,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "RingHom.instRingHomClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "TensorProduct.addCommMonoid",
            "ZHat.commRing",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearMap.instFunLike",
            "RingHom",
            "MonoidHomClass.toOneHomClass",
            "algebraMap",
            "Algebra.toModule",
            "Eq.mp",
            "RingHomClass.toMonoidWithZeroHomClass",
            "Algebra.linearMap",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "MonoidWithZeroHomClass.toMonoidHomClass",
            "LinearMap",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "instOfNat",
            "map_one",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Int.instRing",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Int.instSemiring",
            "TensorProduct.instModule",
            "LinearMap.rTensor"
          ],
          "tactic": "simp only [Algebra.linearMap_apply, map_one] at h\u2081 h\u2082",
          "proofState": 205,
          "pos": {
            "line": 315,
            "column": 6
          },
          "goals": "a b : ZHat\nh : i\u2082 a = i\u2082 b\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = (Algebra.linearMap \u2124 \u211a) 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = (Algebra.linearMap \u2124 \u211a) 1 \u2297\u209c[\u2124] b\n\u22a2 a = b",
          "endPos": {
            "line": 315,
            "column": 59
          }
        },
        {
          "usedConstants": [],
          "tactic": "dsimp at h",
          "proofState": 206,
          "pos": {
            "line": 316,
            "column": 6
          },
          "goals": "a b : ZHat\nh : i\u2082 a = i\u2082 b\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = 1 \u2297\u209c[\u2124] b\n\u22a2 a = b",
          "endPos": {
            "line": 316,
            "column": 16
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [\u2190 h\u2081, \u2190 h\u2082] at h",
          "proofState": 207,
          "pos": {
            "line": 317,
            "column": 6
          },
          "goals": "a b : ZHat\nh : 1 \u2297\u209c[\u2124] a = 1 \u2297\u209c[\u2124] b\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = 1 \u2297\u209c[\u2124] b\n\u22a2 a = b",
          "endPos": {
            "line": 317,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "RingHom.instRingHomClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "Init.Core._auxLemma.4",
            "congrArg",
            "CommSemiring.toSemiring",
            "ZHat.commRing",
            "Rat",
            "RingHom",
            "ZHat.ZHat_flat",
            "Algebra.toModule",
            "Algebra.linearMap",
            "Int",
            "eq_intCast",
            "AddGroupWithOne.toIntCast",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "instOfNat",
            "implies_congr",
            "Int.castRingHom",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "congr",
            "True",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Eq.refl",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "letFun",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Module.Flat.rTensor_preserves_injective_linearMap",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3"
          ],
          "tactic": "replace h := Module.Flat.rTensor_preserves_injective_linearMap (M := ZHat) (Algebra.linearMap \u2124 \u211a) (fun _ _ \u21a6 by simp) h",
          "proofState": 208,
          "pos": {
            "line": 318,
            "column": 6
          },
          "goals": "a b : ZHat\nh :\n  (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) =\n    (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b)\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = 1 \u2297\u209c[\u2124] b\n\u22a2 a = b",
          "endPos": {
            "line": 319,
            "column": 65
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "RingHom.instRingHomClass",
            "NormedRing.toRing",
            "Ring.toNonAssocRing",
            "Init.Core._auxLemma.4",
            "congrArg",
            "CommSemiring.toSemiring",
            "Rat",
            "RingHom",
            "Int",
            "eq_intCast",
            "AddGroupWithOne.toIntCast",
            "NonAssocRing.toAddCommGroupWithOne",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "implies_congr",
            "Int.castRingHom",
            "congr",
            "True",
            "of_eq_true",
            "Eq.refl",
            "NormedField.toNormedCommRing",
            "Int.instCommSemiring",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3"
          ],
          "tactic": "simp",
          "proofState": 209,
          "pos": {
            "line": 319,
            "column": 58
          },
          "goals": "a b : ZHat\nh :\n  (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) =\n    (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b)\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = 1 \u2297\u209c[\u2124] b\nx\u271d\u00b9 x\u271d : \u2124\n\u22a2 (Algebra.linearMap \u2124 \u211a) x\u271d\u00b9 = (Algebra.linearMap \u2124 \u211a) x\u271d \u2192 x\u271d\u00b9 = x\u271d",
          "endPos": {
            "line": 319,
            "column": 62
          }
        },
        {
          "usedConstants": [],
          "tactic": "simp at h",
          "proofState": 210,
          "pos": {
            "line": 320,
            "column": 6
          },
          "goals": "a b : ZHat\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = 1 \u2297\u209c[\u2124] b\nh : 1 \u2297\u209c[\u2124] a = 1 \u2297\u209c[\u2124] b\n\u22a2 a = b",
          "endPos": {
            "line": 320,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "TensorProduct.addCommMonoid",
            "ZHat.commRing",
            "Int",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instOfNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "RingHomInvPair.ids",
            "LinearEquiv",
            "TensorProduct.lid",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "ZHat",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "DFinsupp.instEquivLikeLinearEquiv",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "letFun",
            "EquivLike.toFunLike",
            "TensorProduct.instModule"
          ],
          "tactic": "have := congrArg (TensorProduct.lid \u2124 ZHat) h",
          "proofState": 211,
          "pos": {
            "line": 321,
            "column": 6
          },
          "goals": "a b : ZHat\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = 1 \u2297\u209c[\u2124] b\nh : 1 \u2297\u209c[\u2124] a = 1 \u2297\u209c[\u2124] b\n\u22a2 a = b",
          "endPos": {
            "line": 321,
            "column": 51
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using this",
          "proofState": 212,
          "pos": {
            "line": 322,
            "column": 6
          },
          "goals": "a b : ZHat\nh\u2081 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] a) = 1 \u2297\u209c[\u2124] a\nh\u2082 : (LinearMap.rTensor ZHat (Algebra.linearMap \u2124 \u211a)) (1 \u2297\u209c[\u2124] b) = 1 \u2297\u209c[\u2124] b\nh : 1 \u2297\u209c[\u2124] a = 1 \u2297\u209c[\u2124] b\nthis : (TensorProduct.lid \u2124 ZHat) (1 \u2297\u209c[\u2124] a) = (TensorProduct.lid \u2124 ZHat) (1 \u2297\u209c[\u2124] b)\n\u22a2 a = b",
          "endPos": {
            "line": 322,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int.natAbs_eq"
          ],
          "tactic": "cases z.natAbs_eq with\n| inl h| inr h => rw [h]; simp [-Int.natCast_natAbs]",
          "proofState": 213,
          "pos": {
            "line": 343,
            "column": 2
          },
          "goals": "z : \u2124\nN : \u2115\n\u22a2 IsUnit \u2191z.natAbs \u2194 IsUnit \u2191z",
          "endPos": {
            "line": 344,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Int.natAbs_eq"
          ],
          "tactic": "cases z.natAbs_eq with\n| inl h => rw [h]; simp [-Int.natCast_natAbs]\n| inr h => rw [h]; simp [-Int.natCast_natAbs]",
          "proofState": 214,
          "pos": {
            "line": 343,
            "column": 2
          },
          "goals": "z : \u2124\nN : \u2115\n\u22a2 IsUnit \u2191z.natAbs \u2194 IsUnit \u2191z",
          "endPos": {
            "line": 344,
            "column": 55
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases z.natAbs_eq with\n| inl h => rw [h]; simp [-Int.natCast_natAbs]\n| inr h => rw [h]; simp [-Int.natCast_natAbs]",
          "proofState": 215,
          "pos": {
            "line": 343,
            "column": 2
          },
          "goals": "z : \u2124\nN : \u2115\nx\u271d : z = \u2191z.natAbs \u2228 z = -\u2191z.natAbs\n\u22a2 IsUnit \u2191z.natAbs \u2194 IsUnit \u2191z",
          "endPos": {
            "line": 344,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "IsUnit",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "ZMod",
            "CommRing.toCommSemiring",
            "Iff",
            "Int.natAbs",
            "instNatCastInt",
            "CommRing.toRing",
            "Eq",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [h]",
          "proofState": 216,
          "pos": {
            "line": 344,
            "column": 21
          },
          "goals": "case inl\nz : \u2124\nN : \u2115\nh : z = \u2191z.natAbs\n\u22a2 IsUnit \u2191z.natAbs \u2194 IsUnit \u2191z",
          "endPos": {
            "line": 344,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Int.cast_natCast",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "IsUnit",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "ZMod",
            "iff_self",
            "CommRing.toCommSemiring",
            "Iff",
            "True",
            "Int.natAbs",
            "of_eq_true",
            "instNatCastInt",
            "CommRing.toRing",
            "Ring.toAddGroupWithOne",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [-Int.natCast_natAbs]",
          "proofState": 217,
          "pos": {
            "line": 344,
            "column": 29
          },
          "goals": "case inl\nz : \u2124\nN : \u2115\nh : z = \u2191z.natAbs\n\u22a2 IsUnit \u2191(\u2191z.natAbs).natAbs \u2194 IsUnit \u2191\u2191z.natAbs",
          "endPos": {
            "line": 344,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "ZMod.commRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "IsUnit",
            "id",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "ZMod",
            "CommRing.toCommSemiring",
            "Iff",
            "Int.natAbs",
            "instNatCastInt",
            "CommRing.toRing",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [h]",
          "proofState": 218,
          "pos": {
            "line": 344,
            "column": 21
          },
          "goals": "case inr\nz : \u2124\nN : \u2115\nh : z = -\u2191z.natAbs\n\u22a2 IsUnit \u2191z.natAbs \u2194 IsUnit \u2191z",
          "endPos": {
            "line": 344,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Int.cast_neg",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Int.cast_natCast",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "ZMod.commRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "IsUnit",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.cast",
            "ZMod",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "iff_self",
            "CommRing.toCommSemiring",
            "Iff",
            "Mathlib.Algebra.Ring.Units._auxLemma.3",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "Int.natAbs",
            "of_eq_true",
            "instNatCastInt",
            "CommRing.toRing",
            "Int.natAbs_neg",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [-Int.natCast_natAbs]",
          "proofState": 219,
          "pos": {
            "line": 344,
            "column": 29
          },
          "goals": "case inr\nz : \u2124\nN : \u2115\nh : z = -\u2191z.natAbs\n\u22a2 IsUnit \u2191(-\u2191z.natAbs).natAbs \u2194 IsUnit \u2191(-\u2191z.natAbs)",
          "endPos": {
            "line": 344,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Algebra.to_smulCommClass",
            "AlgHom.algHomClass",
            "Algebra.TensorProduct.instNonAssocRing",
            "IsScalarTower.right",
            "Ring.toNonAssocRing",
            "congrArg",
            "AlgHom",
            "AlgHom.funLike",
            "AddGroupWithOne.toAddMonoidWithOne",
            "map_intCast",
            "Algebra.toModule",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddGroupWithOne.toIntCast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "CommRing.toCommSemiring",
            "Algebra.TensorProduct.instAlgebra",
            "Algebra.TensorProduct.instSemiring",
            "One.toOfNat1",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "TensorProduct.tmul",
            "AlgHomClass.toRingHomClass",
            "OfNat.ofNat",
            "Eq.symm",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "AddCommGroupWithOne.toAddGroupWithOne"
          ],
          "tactic": "rw [\u2190 map_intCast (F := B \u2192\u2090[R] TensorProduct R A B), Algebra.TensorProduct.includeRight_apply]",
          "proofState": 220,
          "pos": {
            "line": 350,
            "column": 2
          },
          "goals": "R : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra R B\nz : \u2124\n\u22a2 1 \u2297\u209c[R] \u2191z = \u2191z",
          "endPos": {
            "line": 351,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "le_antisymm"
          ],
          "tactic": "apply le_antisymm",
          "proofState": 221,
          "pos": {
            "line": 354,
            "column": 2
          },
          "goals": "\u22a2 ratsub \u2293 zHatsub = zsub",
          "endPos": {
            "line": 354,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "QHat"
          ],
          "tactic": "intro x \u27e8\u27e8l, hl\u27e9, \u27e8r, hr\u27e9\u27e9",
          "proofState": 222,
          "pos": {
            "line": 355,
            "column": 4
          },
          "goals": "case a\n\u22a2 ratsub \u2293 zHatsub \u2264 zsub",
          "endPos": {
            "line": 355,
            "column": 30
          }
        },
        {
          "usedConstants": [],
          "tactic": "simp only [AddMonoidHom.coe_coe, Algebra.TensorProduct.includeLeft_apply,\n  Algebra.TensorProduct.includeRight_apply] at hl hr",
          "proofState": 223,
          "pos": {
            "line": 356,
            "column": 4
          },
          "goals": "case a\nx : QHat\nl : \u211a\nhl : \u2191i\u2081 l = x\nr : ZHat\nhr : \u2191i\u2082 r = x\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 357,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "QHat.lowestTerms"
          ],
          "tactic": "rcases lowestTerms x with \u27e8\u27e8N, z, hNz, hx\u27e9, unique\u27e9",
          "proofState": 224,
          "pos": {
            "line": 358,
            "column": 4
          },
          "goals": "case a\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 358,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Rat.num",
            "NormedRing.toRing",
            "AddGroupWithOne.toAddGroup",
            "QHat.IsCoprime",
            "ZHat.commRing",
            "Rat",
            "Membership.mem",
            "Rat.den",
            "Nat.toPNat'",
            "Int",
            "AddGroupWithOne.toIntCast",
            "AddSubgroup",
            "Rat.instNormedField",
            "Int.instCommRing",
            "AddSubgroup.instSetLike",
            "Ring.toIntAlgebra",
            "QHat.zsub",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "letFun"
          ],
          "tactic": "have cop1 : IsCoprime l.den.toPNat' l.num :=\n  by\n  simp_rw [IsCoprime, ZHat.intCast_val, \u2190 ZMod.isUnit_natAbs, ZMod.isUnit_iff_coprime, PNat.toPNat'_coe l.den_pos]\n  exact l.reduced",
          "proofState": 225,
          "pos": {
            "line": 359,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 362,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Rat.num",
            "QHat.IsCoprime",
            "ZHat.commRing",
            "Rat.den",
            "Nat.toPNat'",
            "id",
            "AddGroupWithOne.toIntCast",
            "ZHat",
            "CommRing.toRing",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "simp_rw [IsCoprime, ZHat.intCast_val, \u2190 ZMod.isUnit_natAbs, ZMod.isUnit_iff_coprime, PNat.toPNat'_coe l.den_pos]",
          "proofState": 226,
          "pos": {
            "line": 360,
            "column": 6
          },
          "goals": "x : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\n\u22a2 IsCoprime l.den.toPNat' \u2191l.num",
          "endPos": {
            "line": 361,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Rat.reduced"
          ],
          "tactic": "exact l.reduced",
          "proofState": 227,
          "pos": {
            "line": 362,
            "column": 6
          },
          "goals": "x : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\n\u22a2 l.num.natAbs.Coprime l.den",
          "endPos": {
            "line": 362,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "NormedRing.toRing",
            "AddGroupWithOne.toAddGroup",
            "QHat.IsCoprime",
            "ZHat.commRing",
            "Rat",
            "Membership.mem",
            "instOfNatPNatOfNeZeroNat",
            "instOfNatNat",
            "Int",
            "AddSubgroup",
            "Rat.instNormedField",
            "Int.instCommRing",
            "Nat.instNeZeroSucc",
            "AddSubgroup.instSetLike",
            "Nat",
            "Ring.toIntAlgebra",
            "QHat.zsub",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "letFun",
            "PNat"
          ],
          "tactic": "have cop2 : IsCoprime 1 r := by\n  simp only [IsCoprime, PNat.val_ofNat]\n  exact isUnit_of_subsingleton _",
          "proofState": 228,
          "pos": {
            "line": 363,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 365,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "QHat.IsCoprime",
            "id",
            "OfNat.ofNat"
          ],
          "tactic": "simp only [IsCoprime, PNat.val_ofNat]",
          "proofState": 229,
          "pos": {
            "line": 364,
            "column": 6
          },
          "goals": "x : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\n\u22a2 IsCoprime 1 r",
          "endPos": {
            "line": 364,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "ZMod.commRing",
            "CommSemiring.toSemiring",
            "ZMod.instUnique",
            "instOfNatPNatOfNeZeroNat",
            "instOfNatNat",
            "ZMod",
            "Unique.instSubsingleton",
            "CommRing.toCommSemiring",
            "ZHat.instDFunLikePNatZModVal",
            "Nat.instNeZeroSucc",
            "Nat",
            "ZHat",
            "OfNat.ofNat",
            "isUnit_of_subsingleton",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "PNat"
          ],
          "tactic": "exact isUnit_of_subsingleton _",
          "proofState": 230,
          "pos": {
            "line": 365,
            "column": 6
          },
          "goals": "x : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\n\u22a2 IsUnit (r 1)",
          "endPos": {
            "line": 365,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.num",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddGroup",
            "ZHat.commRing",
            "Rat",
            "Membership.mem",
            "Rat.den",
            "HDiv.hDiv",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "AddSubgroup",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Rat.instNormedField",
            "Int.instCommRing",
            "AddSubgroup.instSetLike",
            "Ring.toAddCommGroup",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "QHat.zsub",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "Rat.instDiv",
            "letFun",
            "Rat.addCommGroup",
            "Rat.instNatCast"
          ],
          "tactic": "have hcanon : x = (1 / (l.den : \u211a)) \u2297\u209c[\u2124] (l.num : ZHat) := by\n  nth_rw 1 [\u2190 hl, \u2190 Rat.num_div_den l, \u2190 mul_one ((l.num : \u211a) / l.den), div_mul_comm, mul_comm, \u2190 zsmul_eq_mul,\n    TensorProduct.smul_tmul, zsmul_eq_mul, mul_one]",
          "proofState": 231,
          "pos": {
            "line": 366,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 368,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Rat.num",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "ZHat.commRing",
            "Rat",
            "Rat.den",
            "Algebra.toModule",
            "id",
            "HDiv.hDiv",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast"
          ],
          "tactic": "nth_rw 1 [\u2190 hl, \u2190 Rat.num_div_den l, \u2190 mul_one ((l.num : \u211a) / l.den), div_mul_comm, mul_comm, \u2190 zsmul_eq_mul,\n  TensorProduct.smul_tmul, zsmul_eq_mul, mul_one]",
          "proofState": 232,
          "pos": {
            "line": 367,
            "column": 6
          },
          "goals": "x : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\n\u22a2 x = (1 / \u2191l.den) \u2297\u209c[\u2124] \u2191l.num",
          "endPos": {
            "line": 368,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.num",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "ZHat.commRing",
            "Rat",
            "Rat.den",
            "Nat.toPNat'",
            "Eq.mp",
            "HDiv.hDiv",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "PNat.toPNat'_coe",
            "Ring.toAddCommGroup",
            "Nat",
            "AddCommGroup.toIntModule",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "QHat",
            "Rat.den_pos",
            "ZHat",
            "TensorProduct.tmul",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast"
          ],
          "tactic": "rw [\u2190 PNat.toPNat'_coe l.den_pos, hx] at hcanon",
          "proofState": 233,
          "pos": {
            "line": 369,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhcanon : x = (1 / \u2191l.den) \u2297\u209c[\u2124] \u2191l.num\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 369,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "And.intro"
          ],
          "tactic": "obtain \u27e8rfl, rfl\u27e9 := unique _ _ _ _ \u27e8hNz, cop1, hcanon\u27e9",
          "proofState": 234,
          "pos": {
            "line": 370,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\nN : \u2115+\nz : ZHat\nhNz : IsCoprime N z\nhx : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhcanon : (1 / \u2191\u2191N) \u2297\u209c[\u2124] z = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 370,
            "column": 59
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "instHDiv",
            "NormedRing.toRing",
            "AddGroupWithOne.toAddGroup",
            "ZHat.commRing",
            "Rat",
            "Membership.mem",
            "HDiv.hDiv",
            "instOfNatPNatOfNeZeroNat",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "AddSubgroup",
            "Rat.instNormedField",
            "Int.instCommRing",
            "Nat.instNeZeroSucc",
            "AddSubgroup.instSetLike",
            "Nat",
            "Ring.toIntAlgebra",
            "QHat.zsub",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "Rat.instDiv",
            "letFun",
            "Rat.instNatCast",
            "PNat"
          ],
          "tactic": "have : 1 = 1 / (((1 : \u2115+) : \u2115) : \u211a) := by simp",
          "proofState": 235,
          "pos": {
            "line": 371,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhNz : IsCoprime l.den.toPNat' \u2191l.num\nhx : x = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nhcanon : (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 371,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "GroupWithZero.toMonoidWithZero",
            "False",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "InvOneClass.toOne",
            "NormedRing.toRing",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "congrArg",
            "NeZero.charZero_one",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "DivisionMonoid.toDivInvOneMonoid",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "AddMonoidWithOne.toOne",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "Nat",
            "True",
            "eq_self",
            "of_eq_true",
            "Mathlib.Algebra.NeZero._auxLemma.3",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "Not",
            "Rat.instDiv",
            "div_self",
            "Eq.trans",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp",
          "proofState": 236,
          "pos": {
            "line": 371,
            "column": 46
          },
          "goals": "x : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhNz : IsCoprime l.den.toPNat' \u2191l.num\nhx : x = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nhcanon : (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\n\u22a2 1 = 1 / \u2191\u21911",
          "endPos": {
            "line": 371,
            "column": 50
          }
        },
        {
          "usedConstants": [],
          "tactic": "nth_rw 1 [\u2190 hx, \u2190 hr, this] at hcanon",
          "proofState": 237,
          "pos": {
            "line": 372,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhNz : IsCoprime l.den.toPNat' \u2191l.num\nhx : x = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nhcanon : (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nthis : 1 = 1 / \u2191\u21911\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 372,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use l.num",
          "proofState": 238,
          "pos": {
            "line": 373,
            "column": 4
          },
          "goals": "case a.intro.intro.intro.intro.intro\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhNz : IsCoprime l.den.toPNat' \u2191l.num\nhx : x = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nhcanon : (1 / \u2191\u21911) \u2297\u209c[\u2124] r = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nthis : 1 = 1 / \u2191\u21911\n\u22a2 x \u2208 zsub",
          "endPos": {
            "line": 373,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "Rat.num",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QHat.zsub.proof_1",
            "NormedRing.toRing",
            "Algebra.TensorProduct.instNonAssocRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "AddMonoidHomClass.toAddMonoidHom",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "ZHat.commRing",
            "QHat.zsub.proof_5",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "RingHom",
            "Rat.den",
            "Nat.toPNat'",
            "id",
            "HDiv.hDiv",
            "Int",
            "Int.instAddMonoid",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "QHat.zsub.proof_2",
            "QHat.zsub.proof_4",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Int.instCommRing",
            "Int.castRingHom",
            "Ring.toAddCommGroup",
            "QHat.zsub.proof_3",
            "Ring.toIntAlgebra",
            "TensorProduct.addZeroClass",
            "AddCommGroup.toIntModule",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddMonoidHom",
            "Int.instCommSemiring",
            "AddMonoidHom.instFunLike",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "NonAssocRing.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "Int.instSemiring"
          ],
          "tactic": "rw [hx, (unique _ 1 _ r \u27e8hNz, cop2, hcanon.symm\u27e9).1]",
          "proofState": 239,
          "pos": {
            "line": 373,
            "column": 15
          },
          "goals": "case h\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhNz : IsCoprime l.den.toPNat' \u2191l.num\nhx : x = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nhcanon : (1 / \u2191\u21911) \u2297\u209c[\u2124] r = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nthis : 1 = 1 / \u2191\u21911\n\u22a2 \u2191(Int.castRingHom QHat) l.num = x",
          "endPos": {
            "line": 373,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "GroupWithZero.toMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "False",
            "Rat.num",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QHat.zsub.proof_1",
            "GroupWithZero.toDivisionMonoid",
            "InvOneClass.toOne",
            "NormedRing.toRing",
            "Algebra.TensorProduct.instNonAssocRing",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "Ring.toNonAssocRing",
            "congrArg",
            "NeZero.charZero_one",
            "ZHat.commRing",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "RingHom",
            "NonUnitalNonAssocRing.int_isScalarTower",
            "DivisionMonoid.toDivInvOneMonoid",
            "Algebra.toModule",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "eq_intCast",
            "AddGroupWithOne.toIntCast",
            "NonUnitalNonAssocRing.int_smulCommClass",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "QHat.zsub.proof_2",
            "QHat.zsub.proof_4",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "Int.instCommRing",
            "Int.castRingHom",
            "Ring.toAddCommGroup",
            "QHat.zsub.proof_3",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "True",
            "Ring.toIntAlgebra",
            "eq_self",
            "Algebra.TensorProduct.one_tmul_intCast",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "Mathlib.Algebra.NeZero._auxLemma.3",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "TensorProduct",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Nat.cast_one",
            "DFunLike.coe",
            "NonAssocRing.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "Not",
            "Rat.instDiv",
            "div_self",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp",
          "proofState": 240,
          "pos": {
            "line": 374,
            "column": 4
          },
          "goals": "case h\nx : QHat\nl : \u211a\nhl : l \u2297\u209c[\u2124] 1 = x\nr : ZHat\nhr : 1 \u2297\u209c[\u2124] r = x\nunique :\n  \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n    IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082\ncop1 : IsCoprime l.den.toPNat' \u2191l.num\ncop2 : IsCoprime 1 r\nhNz : IsCoprime l.den.toPNat' \u2191l.num\nhx : x = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nhcanon : (1 / \u2191\u21911) \u2297\u209c[\u2124] r = (1 / \u2191\u2191l.den.toPNat') \u2297\u209c[\u2124] \u2191l.num\nthis : 1 = 1 / \u2191\u21911\n\u22a2 \u2191(Int.castRingHom QHat) l.num = (1 / \u2191\u21911) \u2297\u209c[\u2124] \u2191l.num",
          "endPos": {
            "line": 374,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QHat.zsub.proof_1",
            "NormedRing.toRing",
            "AlgHom.algHomClass",
            "Algebra.TensorProduct.instNonAssocRing",
            "CommRing.toNonUnitalCommRing",
            "QHat.ratsub.proof_1",
            "Ring.toNonAssocRing",
            "AddMonoidHomClass.toAddMonoidHom",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AlgHom",
            "ZHat.commRing",
            "QHat.zsub.proof_5",
            "AlgHom.funLike",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Rat.addMonoid",
            "RingHom",
            "NonUnitalNonAssocRing.int_isScalarTower",
            "Membership.mem",
            "map_intCast",
            "QHat.rat_meet_zHat.match_2",
            "Rat.instIntCast",
            "id",
            "AddSubmonoid",
            "Int",
            "Int.instAddMonoid",
            "AddGroupWithOne.toIntCast",
            "NonUnitalNonAssocRing.int_smulCommClass",
            "QHat.zsub.proof_2",
            "QHat.zsub.proof_4",
            "AddSubgroup",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "SetLike.coe",
            "Int.instCommRing",
            "Int.castRingHom",
            "AddSubgroup.instSetLike",
            "Ring.toAddCommGroup",
            "QHat.i\u2082",
            "QHat.zsub.proof_3",
            "Algebra.TensorProduct.instAlgebra",
            "AddSubgroup.instMin",
            "And.intro",
            "QHat.i\u2081",
            "Algebra.TensorProduct.instSemiring",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Ring.toIntAlgebra",
            "TensorProduct.addZeroClass",
            "Exists.intro",
            "AddCommGroup.toIntModule",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "QHat.zsub",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "Rat.addGroup",
            "ZHat",
            "AlgHomClass.toRingHomClass",
            "AddMonoidWithOne.toAddMonoid",
            "QHat.zHatsub",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "QHat.zHatsub.proof_1",
            "QHat.ratsub",
            "AddMonoidHom",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCommSemiring",
            "AddMonoidHom.instFunLike",
            "AddSubmonoid.instSetLike",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Rat.semiring",
            "NonAssocRing.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "AddSubgroup.toAddSubmonoid",
            "SetLike.instMembership",
            "Min.min",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Set"
          ],
          "tactic": "exact fun x \u27e8k, hk\u27e9 \u21a6 by constructor <;> (use k; simp; exact hk)",
          "proofState": 241,
          "pos": {
            "line": 375,
            "column": 4
          },
          "goals": "case a\n\u22a2 zsub \u2264 ratsub \u2293 zHatsub",
          "endPos": {
            "line": 375,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "And.intro"
          ],
          "tactic": "constructor",
          "proofState": 242,
          "pos": {
            "line": 375,
            "column": 29
          },
          "goals": "x : QHat\nx\u271d : x \u2208 zsub\nk : \u2124\nhk : \u2191(Int.castRingHom QHat) k = x\n\u22a2 x \u2208 ratsub \u2293 zHatsub",
          "endPos": {
            "line": 375,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use k",
          "proofState": 243,
          "pos": {
            "line": 375,
            "column": 46
          },
          "goals": "case left\nx : QHat\nx\u271d : x \u2208 zsub\nk : \u2124\nhk : \u2191(Int.castRingHom QHat) k = x\n\u22a2 x \u2208 \u2191ratsub.toAddSubmonoid",
          "endPos": {
            "line": 375,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "AlgHom.algHomClass",
            "Algebra.TensorProduct.instNonAssocRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AlgHom",
            "ZHat.commRing",
            "AlgHom.funLike",
            "Rat",
            "NonUnitalNonAssocRing.int_isScalarTower",
            "map_intCast",
            "id",
            "Int",
            "AddGroupWithOne.toIntCast",
            "NonUnitalNonAssocRing.int_smulCommClass",
            "NonAssocRing.toAddCommGroupWithOne",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Int.instCommRing",
            "Ring.toAddCommGroup",
            "Algebra.TensorProduct.instAlgebra",
            "QHat.i\u2081",
            "Algebra.TensorProduct.instSemiring",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "QHat",
            "ZHat",
            "AlgHomClass.toRingHomClass",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCommSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp",
          "proofState": 244,
          "pos": {
            "line": 375,
            "column": 53
          },
          "goals": "case h\nx : QHat\nx\u271d : x \u2208 zsub\nk : \u2124\nhk : \u2191(Int.castRingHom QHat) k = x\n\u22a2 \u2191i\u2081 \u2191k = x",
          "endPos": {
            "line": 375,
            "column": 57
          }
        },
        {
          "usedConstants": [],
          "tactic": "exact hk",
          "proofState": 245,
          "pos": {
            "line": 375,
            "column": 59
          },
          "goals": "case h\nx : QHat\nx\u271d : x \u2208 zsub\nk : \u2124\nhk : \u2191(Int.castRingHom QHat) k = x\n\u22a2 \u2191k = x",
          "endPos": {
            "line": 375,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use k",
          "proofState": 246,
          "pos": {
            "line": 375,
            "column": 46
          },
          "goals": "case right\nx : QHat\nx\u271d : x \u2208 zsub\nk : \u2124\nhk : \u2191(Int.castRingHom QHat) k = x\n\u22a2 x \u2208 \u2191zHatsub.toAddSubmonoid",
          "endPos": {
            "line": 375,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "AlgHom.algHomClass",
            "Algebra.TensorProduct.instNonAssocRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AlgHom",
            "ZHat.commRing",
            "AlgHom.funLike",
            "Rat",
            "NonUnitalNonAssocRing.int_isScalarTower",
            "map_intCast",
            "id",
            "Int",
            "AddGroupWithOne.toIntCast",
            "NonUnitalNonAssocRing.int_smulCommClass",
            "NonAssocRing.toAddCommGroupWithOne",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "Int.instCommRing",
            "Ring.toAddCommGroup",
            "QHat.i\u2082",
            "Algebra.TensorProduct.instAlgebra",
            "Algebra.TensorProduct.instSemiring",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Ring.toIntAlgebra",
            "AddCommGroup.toIntModule",
            "QHat",
            "ZHat",
            "AlgHomClass.toRingHomClass",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCommSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp",
          "proofState": 247,
          "pos": {
            "line": 375,
            "column": 53
          },
          "goals": "case h\nx : QHat\nx\u271d : x \u2208 zsub\nk : \u2124\nhk : \u2191(Int.castRingHom QHat) k = x\n\u22a2 \u2191i\u2082 \u2191k = x",
          "endPos": {
            "line": 375,
            "column": 57
          }
        },
        {
          "usedConstants": [],
          "tactic": "exact hk",
          "proofState": 248,
          "pos": {
            "line": 375,
            "column": 59
          },
          "goals": "case h\nx : QHat\nx\u271d : x \u2208 zsub\nk : \u2124\nhk : \u2191(Int.castRingHom QHat) k = x\n\u22a2 \u2191k = x",
          "endPos": {
            "line": 375,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Eq.mpr",
            "AddSubgroup.instCompleteLattice",
            "Lattice.toSemilatticeSup",
            "NormedRing.toRing",
            "eq_top_iff",
            "CompleteLattice.instOmegaCompletePartialOrder",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "ZHat.commRing",
            "Rat",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "CompleteLattice.toConditionallyCompleteLattice",
            "SemilatticeSup.toMax",
            "CompleteLattice.toBoundedOrder",
            "id",
            "Int",
            "LE.le",
            "AddSubgroup",
            "Rat.instNormedField",
            "OrderTop.toTop",
            "Int.instCommRing",
            "Max.max",
            "BoundedOrder.toOrderTop",
            "Ring.toIntAlgebra",
            "OmegaCompletePartialOrder.toPartialOrder",
            "propext",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "QHat.zHatsub",
            "ConditionallyCompleteLattice.toLattice",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "QHat.ratsub",
            "Top.top",
            "AddSubgroup.instTop",
            "Eq",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "rw [eq_top_iff]",
          "proofState": 249,
          "pos": {
            "line": 378,
            "column": 2
          },
          "goals": "\u22a2 ratsub \u2294 zHatsub = \u22a4",
          "endPos": {
            "line": 378,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "QHat"
          ],
          "tactic": "intro x _",
          "proofState": 250,
          "pos": {
            "line": 379,
            "column": 2
          },
          "goals": "\u22a2 \u22a4 \u2264 ratsub \u2294 zHatsub",
          "endPos": {
            "line": 379,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "QHat.canonicalForm"
          ],
          "tactic": "rcases x.canonicalForm with \u27e8N, z, hNz\u27e9",
          "proofState": 251,
          "pos": {
            "line": 380,
            "column": 2
          },
          "goals": "x : QHat\na\u271d : x \u2208 \u22a4\n\u22a2 x \u2208 ratsub \u2294 zHatsub",
          "endPos": {
            "line": 380,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "ZHat.nat_dense"
          ],
          "tactic": "rcases ZHat.nat_dense N z with \u27e8q, r, hz, _\u27e9",
          "proofState": 252,
          "pos": {
            "line": 381,
            "column": 2
          },
          "goals": "case intro.intro\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\n\u22a2 x \u2208 ratsub \u2294 zHatsub",
          "endPos": {
            "line": 381,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "AddSubgroup.instCompleteLattice",
            "Lattice.toSemilatticeSup",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddGroup",
            "ZHat.commRing",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Membership.mem",
            "CompleteLattice.toConditionallyCompleteLattice",
            "SemilatticeSup.toMax",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "Nat.cast",
            "AddSubgroup",
            "SubNegMonoid.toSub",
            "instHSub",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Int.instCommRing",
            "Distrib.toMul",
            "Max.max",
            "AddSubgroup.instSetLike",
            "Ring.toIntAlgebra",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "sub_eq_of_eq_add",
            "QHat.zHatsub",
            "ConditionallyCompleteLattice.toLattice",
            "NormedField.toNormedCommRing",
            "CommRing.toRing",
            "QHat.ratsub",
            "Eq",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "letFun",
            "instHMul"
          ],
          "tactic": "have h : z - r = N * q := sub_eq_of_eq_add hz",
          "proofState": 253,
          "pos": {
            "line": 382,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.intro\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\n\u22a2 x \u2208 ratsub \u2294 zHatsub",
          "endPos": {
            "line": 382,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Eq.mpr",
            "AddSubgroup.instCompleteLattice",
            "Lattice.toSemilatticeSup",
            "NormedRing.toRing",
            "CompleteLattice.toLattice",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "Membership.mem",
            "Exists",
            "CompleteLattice.toConditionallyCompleteLattice",
            "SemilatticeSup.toMax",
            "id",
            "Int",
            "AddSubgroup",
            "instHAdd",
            "And",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Int.instCommRing",
            "HAdd.hAdd",
            "Max.max",
            "AddSubgroup.instSetLike",
            "Ring.toAddCommGroup",
            "AddSubgroup.mem_sup",
            "Ring.toIntAlgebra",
            "propext",
            "AddCommGroup.toIntModule",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "QHat.zHatsub",
            "ConditionallyCompleteLattice.toLattice",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "QHat.ratsub",
            "Int.instCommSemiring",
            "AddZeroClass.toAdd",
            "Eq",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "Rat.addCommGroup"
          ],
          "tactic": "rw [AddSubgroup.mem_sup]",
          "proofState": 254,
          "pos": {
            "line": 383,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.intro\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 x \u2208 ratsub \u2294 zHatsub",
          "endPos": {
            "line": 383,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use ((r : \u2124) / N : \u211a) \u2297\u209c[\u2124] 1",
          "proofState": 255,
          "pos": {
            "line": 384,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.intro\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 \u2203 y \u2208 ratsub, \u2203 z \u2208 zHatsub, y + z = x",
          "endPos": {
            "line": 384,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "And.intro"
          ],
          "tactic": "constructor",
          "proofState": 256,
          "pos": {
            "line": 385,
            "column": 2
          },
          "goals": "case h\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 (\u2191\u2191r / \u2191\u2191N) \u2297\u209c[\u2124] 1 \u2208 ratsub \u2227 \u2203 z \u2208 zHatsub, (\u2191\u2191r / \u2191\u2191N) \u2297\u209c[\u2124] 1 + z = x",
          "endPos": {
            "line": 385,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Init.PropLemmas._auxLemma.47",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Int.cast_natCast",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "QHat.ratsub.proof_1",
            "AddMonoidHomClass.toAddMonoidHom",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "AlgHom",
            "ZHat.commRing",
            "AlgHom.funLike",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Rat.addMonoid",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "Membership.mem",
            "Exists",
            "Algebra.toModule",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "AddSubgroup",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Int.instCommRing",
            "AddSubgroup.instSetLike",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Algebra.TensorProduct.instAlgebra",
            "QHat.i\u2081",
            "Algebra.TensorProduct.instSemiring",
            "True",
            "Ring.toIntAlgebra",
            "TensorProduct.addZeroClass",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "Rat.addGroup",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "QHat.ratsub",
            "AddMonoidHom",
            "Int.instCommSemiring",
            "AddMonoidHom.instFunLike",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "Rat.instDiv",
            "Mathlib.Algebra.Group.Subgroup.Ker._auxLemma.3",
            "Rat.addCommGroup",
            "Eq.trans",
            "Rat.instNatCast"
          ],
          "tactic": "simp",
          "proofState": 257,
          "pos": {
            "line": 386,
            "column": 4
          },
          "goals": "case h.left\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 (\u2191\u2191r / \u2191\u2191N) \u2297\u209c[\u2124] 1 \u2208 ratsub",
          "endPos": {
            "line": 386,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use 1 \u2297\u209c[\u2124] q",
          "proofState": 258,
          "pos": {
            "line": 387,
            "column": 2
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 \u2203 z \u2208 zHatsub, (\u2191\u2191r / \u2191\u2191N) \u2297\u209c[\u2124] 1 + z = x",
          "endPos": {
            "line": 387,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "And.intro"
          ],
          "tactic": "constructor",
          "proofState": 259,
          "pos": {
            "line": 388,
            "column": 2
          },
          "goals": "case h\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 1 \u2297\u209c[\u2124] q \u2208 zHatsub \u2227 (\u2191\u2191r / \u2191\u2191N) \u2297\u209c[\u2124] 1 + 1 \u2297\u209c[\u2124] q = x",
          "endPos": {
            "line": 388,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "Init.PropLemmas._auxLemma.47",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "AddMonoidHomClass.toAddMonoidHom",
            "AddGroupWithOne.toAddGroup",
            "CommSemiring.toSemiring",
            "AlgHom",
            "ZHat.commRing",
            "AlgHom.funLike",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidHom.range",
            "Membership.mem",
            "Exists",
            "Algebra.toModule",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddSubgroup",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "CommRing.toCommSemiring",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Int.instCommRing",
            "AddSubgroup.instSetLike",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "QHat.i\u2082",
            "Algebra.TensorProduct.instAlgebra",
            "Algebra.TensorProduct.instSemiring",
            "True",
            "Ring.toIntAlgebra",
            "TensorProduct.addZeroClass",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instRing",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "QHat.zHatsub.proof_1",
            "AddMonoidHom",
            "Int.instCommSemiring",
            "AddMonoidHom.instFunLike",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "SetLike.instMembership",
            "Mathlib.Algebra.Group.Subgroup.Ker._auxLemma.3",
            "Rat.addCommGroup",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 260,
          "pos": {
            "line": 389,
            "column": 4
          },
          "goals": "case h.left\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 1 \u2297\u209c[\u2124] q \u2208 zHatsub",
          "endPos": {
            "line": 389,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "MulOneClass.toMul",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "Nat.cast",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "MulOneClass.toOne",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "QHat",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "mul_one",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul"
          ],
          "tactic": "nth_rw 1 [\u2190 mul_one ((r : \u2124) / N : \u211a), div_mul_comm, mul_comm, \u2190 zsmul_eq_mul, TensorProduct.smul_tmul, zsmul_eq_mul,\n  mul_one]",
          "proofState": 261,
          "pos": {
            "line": 390,
            "column": 2
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 (\u2191\u2191r / \u2191\u2191N) \u2297\u209c[\u2124] 1 + 1 \u2297\u209c[\u2124] q = x",
          "endPos": {
            "line": 391,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "Ring.toNonAssocRing",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "Rat.instIntCast",
            "HDiv.hDiv",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "MulOneClass.toOne",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "QHat",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Rat.instDiv",
            "letFun",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul"
          ],
          "tactic": "have : 1 = 1 / (N : \u211a) * (N : \u2124) := by simp",
          "proofState": 262,
          "pos": {
            "line": 392,
            "column": 2
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 (1 / \u2191\u2191N) \u2297\u209c[\u2124] \u2191\u2191r + 1 \u2297\u209c[\u2124] q = x",
          "endPos": {
            "line": 392,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "Int.cast",
            "GroupWithZero.toMonoidWithZero",
            "Int.cast_natCast",
            "False",
            "Rat.instMul",
            "DivInvMonoid.toInv",
            "instHDiv",
            "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
            "NormedRing.toRing",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "Mathlib.Data.PNat.Defs._auxLemma.4",
            "Monoid.toMulOneClass",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "DivisionRing.toDivInvMonoid",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Rat.instDivisionRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "MulZeroOneClass.toMulOneClass",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "Rat.instNormedField",
            "Rat.instCharZero",
            "MonoidWithZero.toMulZeroOneClass",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "one_div",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "DivInvMonoid.toDiv",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Rat.instLinearOrderedField",
            "Eq",
            "inv_mul_cancel\u2080",
            "Ring.toAddGroupWithOne",
            "Not",
            "Eq.trans",
            "Rat.instNatCast",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 263,
          "pos": {
            "line": 392,
            "column": 41
          },
          "goals": "x : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\n\u22a2 1 = 1 / \u2191\u2191N * \u2191\u2191\u2191N",
          "endPos": {
            "line": 392,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "Ring.toNonAssocRing",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "MulOneClass.toOne",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "QHat",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Rat.instDiv",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul"
          ],
          "tactic": "nth_rw 2 [this]",
          "proofState": 264,
          "pos": {
            "line": 393,
            "column": 2
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\nthis : 1 = 1 / \u2191\u2191N * \u2191\u2191\u2191N\n\u22a2 (1 / \u2191\u2191N) \u2297\u209c[\u2124] \u2191\u2191r + 1 \u2297\u209c[\u2124] q = x",
          "endPos": {
            "line": 393,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Rat.instMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "Ring.toNonAssocRing",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "Rat.instIntCast",
            "id",
            "HDiv.hDiv",
            "CommMagma.toMul",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "MulOneClass.toOne",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "mul_comm",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "QHat",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Rat.semiring",
            "Rat.instDiv",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "rw [mul_comm, \u2190 zsmul_eq_mul, TensorProduct.smul_tmul, zsmul_eq_mul]",
          "proofState": 265,
          "pos": {
            "line": 394,
            "column": 2
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\nthis : 1 = 1 / \u2191\u2191N * \u2191\u2191\u2191N\n\u22a2 (1 / \u2191\u2191N) \u2297\u209c[\u2124] \u2191\u2191r + (1 / \u2191\u2191N * \u2191\u2191\u2191N) \u2297\u209c[\u2124] q = x",
          "endPos": {
            "line": 394,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "Int.cast_natCast",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "Ring.toNonAssocRing",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "congr",
            "MulOneClass.toOne",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Rat.commGroupWithZero",
            "TensorProduct",
            "CommGroupWithZero.toDivisionCommMonoid",
            "QHat",
            "instNatCastInt",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Rat.semiring",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Rat.addCommGroup",
            "Eq.trans",
            "Rat.instNatCast",
            "instHMul"
          ],
          "tactic": "norm_cast",
          "proofState": 266,
          "pos": {
            "line": 395,
            "column": 2
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\nthis : 1 = 1 / \u2191\u2191N * \u2191\u2191\u2191N\n\u22a2 (1 / \u2191\u2191N) \u2297\u209c[\u2124] \u2191\u2191r + (1 / \u2191\u2191N) \u2297\u209c[\u2124] (\u2191\u2191\u2191N * q) = x",
          "endPos": {
            "line": 395,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "NormedCommRing.toNormedRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "TensorProduct.addCommGroup",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toSub",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "instHSub",
            "Rat.instNormedField",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Rat.commGroupWithZero",
            "CommGroupWithZero.toDivisionCommMonoid",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "NormedField.toNormedCommRing",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul"
          ],
          "tactic": "rw [\u2190 h, \u2190 TensorProduct.tmul_add]",
          "proofState": 267,
          "pos": {
            "line": 395,
            "column": 13
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\nthis : 1 = 1 / \u2191\u2191N * \u2191\u2191\u2191N\n\u22a2 (1 / \u2191\u2191N) \u2297\u209c[\u2124] \u2191r + (1 / \u2191\u2191N) \u2297\u209c[\u2124] (\u2191\u2191N * q) = x",
          "endPos": {
            "line": 395,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Rat.instOfNat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Monoid.toMulOneClass",
            "congrArg",
            "ZHat.commRing",
            "AddMonoid.toAddZeroClass",
            "Rat",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "DivisionRing.toDivInvMonoid",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Rat.instDivisionRing",
            "Int",
            "Nat.cast",
            "SubNegMonoid.toSub",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "add_sub_cancel",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "congr",
            "one_div",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "DivInvMonoid.toDiv",
            "AddCommGroup.toIntModule",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "QHat",
            "ZHat",
            "TensorProduct.tmul",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Rat.instDiv",
            "Rat.addCommGroup",
            "Eq.trans",
            "Rat.instNatCast"
          ],
          "tactic": "simp [hNz]",
          "proofState": 268,
          "pos": {
            "line": 396,
            "column": 2
          },
          "goals": "case h.right\nx : QHat\na\u271d : x \u2208 \u22a4\nN : \u2115+\nz : ZHat\nhNz : x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z\nq : ZHat\nr : \u2115\nhz : z = \u2191\u2191N * q + \u2191r\nright\u271d : r < \u2191N\nh : z - \u2191r = \u2191\u2191N * q\nthis : 1 = 1 / \u2191\u2191N * \u2191\u2191\u2191N\n\u22a2 (1 / \u2191\u2191N) \u2297\u209c[\u2124] (\u2191r + (z - \u2191r)) = x",
          "endPos": {
            "line": 396,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Hurwitz"
          ],
          "tactic": "intro z",
          "proofState": 269,
          "pos": {
            "line": 446,
            "column": 2
          },
          "goals": "\u22a2 Function.LeftInverse fromQuaternion toQuaternion",
          "endPos": {
            "line": 446,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "sub_sub_sub_cancel_right",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "False",
            "mul_inv_cancel_left\u2080",
            "Real",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "Int.floor",
            "Int.floor_intCast",
            "Real.instRCLike",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "add_sub_sub_cancel",
            "DivisionSemiring.toGroupWithZero",
            "AddCommGroup.toAddGroup",
            "Real.semiring",
            "Distrib.toAdd",
            "Real.instFloorRing",
            "AddMonoidWithOne.toNatCast",
            "Real.instAddGroup",
            "Real.instRing",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "add_add_sub_cancel",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Real.instAddCommGroup",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "Hurwitz",
            "instNatAtLeastTwo",
            "sub_add_add_cancel",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "of_eq_true",
            "Hurwitz.mk",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "_auxLemma.23",
            "AddMonoidWithOne.toAddMonoid",
            "add_sub_cancel_right",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "not_false_eq_true",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "sub_add_cancel",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "Eq.trans",
            "_auxLemma.24",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [fromQuaternion, toQuaternion, sub_add_add_cancel, sub_add_cancel, Int.floor_intCast, add_add_sub_cancel, \u2190\n  two_mul, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, mul_inv_cancel_left\u2080, sub_sub_sub_cancel_right,\n  add_sub_cancel_right, add_sub_sub_cancel]",
          "proofState": 270,
          "pos": {
            "line": 447,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 fromQuaternion z.toQuaternion = z",
          "endPos": {
            "line": 449,
            "column": 93
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Set.LeftInvOn",
            "Real",
            "Real.instZero",
            "Real.instInv",
            "setOf",
            "QuaternionAlgebra.mk",
            "Exists",
            "instOfNatNat",
            "Int",
            "Real.instAdd",
            "Real.instOne",
            "Hurwitz.toQuaternion",
            "instHAdd",
            "Inv.inv",
            "Hurwitz",
            "instNatAtLeastTwo",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Real.instNeg",
            "Real.instIntCast",
            "Int.instAdd",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Or",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Neg.neg",
            "Quaternion",
            "Real.instNatCast"
          ],
          "tactic": "have h\u2080 (x y : \u2124) : (x + 2\u207b\u00b9 : \u211d) + (y + 2\u207b\u00b9) = \u2191(x + y + 1) := by field_simp; norm_cast; ring",
          "proofState": 271,
          "pos": {
            "line": 458,
            "column": 2
          },
          "goals": "\u22a2 Set.LeftInvOn toQuaternion fromQuaternion\n    {q |\n      \u2203 a b c d,\n        q = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n          q = { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }}",
          "endPos": {
            "line": 459,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instDivInvMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.11",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "instOfNatNat",
            "div_mul_eq_mul_div",
            "Int",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "DivisionMonoid.toDivInvMonoid",
            "add_div'",
            "Real.instAdd",
            "AddMonoidWithOne.toOne",
            "mul_div_cancel_right\u2080",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Bool",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 272,
          "pos": {
            "line": 459,
            "column": 4
          },
          "goals": "x y : \u2124\n\u22a2 \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)",
          "endPos": {
            "line": 459,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Real.instDivInvMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "Int.instMul",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "congr",
            "MulOneClass.toOne",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Int.cast_one",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 273,
          "pos": {
            "line": 459,
            "column": 16
          },
          "goals": "x y : \u2124\n\u22a2 \u2191x * 2 + 1 + (\u2191y * 2 + 1) = (\u2191x + \u2191y + 1) * 2",
          "endPos": {
            "line": 459,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "HMul.hMul",
            "Nat.rawCast",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "AddMonoidWithOne.toOne",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 274,
          "pos": {
            "line": 459,
            "column": 27
          },
          "goals": "x y : \u2124\n\u22a2 x * 2 + 1 + (y * 2 + 1) = (x + y + 1) * 2",
          "endPos": {
            "line": 459,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "Real.instOne",
            "Real.instNeg",
            "Quaternion"
          ],
          "tactic": "intro q hq",
          "proofState": 275,
          "pos": {
            "line": 460,
            "column": 2
          },
          "goals": "h\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\n\u22a2 Set.LeftInvOn toQuaternion fromQuaternion\n    {q |\n      \u2203 a b c d,\n        q = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n          q = { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }}",
          "endPos": {
            "line": 460,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "_auxLemma.25",
            "Real.instZero",
            "Real.instInv",
            "setOf",
            "QuaternionAlgebra.mk",
            "Membership.mem",
            "Exists",
            "Eq.mp",
            "instOfNatNat",
            "Int",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "Real.instNeg",
            "Real.instIntCast",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Or",
            "OfNat.ofNat",
            "Eq",
            "Set.instMembership",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Quaternion",
            "Real.instNatCast",
            "Set"
          ],
          "tactic": "simp only [Set.mem_setOf] at hq",
          "proofState": 276,
          "pos": {
            "line": 461,
            "column": 2
          },
          "goals": "h\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\nq : \u210d\nhq :\n  q \u2208\n    {q |\n      \u2203 a b c d,\n        q = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n          q = { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }}\n\u22a2 (fromQuaternion q).toQuaternion = q",
          "endPos": {
            "line": 461,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "id",
            "Real.instOne",
            "Hurwitz.toQuaternion",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "Eq",
            "Quaternion"
          ],
          "tactic": "simp only [toQuaternion, fromQuaternion]",
          "proofState": 277,
          "pos": {
            "line": 462,
            "column": 2
          },
          "goals": "h\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\nq : \u210d\nhq :\n  \u2203 a b c d,\n    q = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      q = { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }\n\u22a2 (fromQuaternion q).toQuaternion = q",
          "endPos": {
            "line": 462,
            "column": 42
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain \u27e8a, b, c, d, rfl | rfl\u27e9 := hq",
          "proofState": 278,
          "pos": {
            "line": 463,
            "column": 2
          },
          "goals": "h\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\nq : \u210d\nhq :\n  \u2203 a b c d,\n    q = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      q = { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }\n\u22a2 { re := \u2191\u230aq.re + q.imJ\u230b - 2\u207b\u00b9 * \u2191\u230aq.imJ + q.imK\u230b - 2\u207b\u00b9 * \u2191\u230aq.imJ - q.imK\u230b,\n      imI := \u2191\u230aq.imI - q.imK\u230b + 2\u207b\u00b9 * \u2191\u230aq.imJ + q.imK\u230b - 2\u207b\u00b9 * \u2191\u230aq.imJ - q.imK\u230b,\n      imJ := 2\u207b\u00b9 * \u2191\u230aq.imJ + q.imK\u230b + 2\u207b\u00b9 * \u2191\u230aq.imJ - q.imK\u230b, imK := 2\u207b\u00b9 * \u2191\u230aq.imJ + q.imK\u230b - 2\u207b\u00b9 * \u2191\u230aq.imJ - q.imK\u230b } =\n    q",
          "endPos": {
            "line": 463,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 279,
          "pos": {
            "line": 464,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n      re :=\n        \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.re + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n      imI :=\n        \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imI - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n      imJ :=\n        2\u207b\u00b9 * \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n      imK :=\n        2\u207b\u00b9 * \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b } =\n    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }",
          "endPos": {
            "line": 464,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 280,
          "pos": {
            "line": 464,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n      re :=\n        \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.re +\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n      imI :=\n        \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imI -\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n      imJ :=\n        2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n      imK :=\n        2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n          2\u207b\u00b9 *\n            \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                  { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b } =\n    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 464,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 281,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.re + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imI - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ -\n                    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b }.re =\n    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.re",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 282,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.re + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imI - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ -\n                    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b }.imI =\n    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imI",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "QuaternionAlgebra.imJ",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 283,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.re + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imI - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ -\n                    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b }.imJ =\n    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 284,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.re + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imI - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ +\n                      { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ - { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ + { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imJ -\n                    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK\u230b }.imK =\n    { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d }.imK",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "Int.floor_add_one",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "add_sub_add_right_eq_sub",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 285,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.re +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imI -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b }.re =\n    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.re",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "Int.floor_add_one",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "add_sub_add_right_eq_sub",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 286,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.re +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imI -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b }.imI =\n    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imI",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "Int.floor_add_one",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "add_sub_add_right_eq_sub",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "QuaternionAlgebra.imJ",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 287,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.re +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imI -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b }.imJ =\n    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "Int.floor_add_one",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Int.floor",
            "Int.floor_intCast",
            "Ring.toNonAssocRing",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Int.floor_sub_int",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instFloorRing",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Int.floor_add_int",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "Real.instMul",
            "congr",
            "Real.instIntCast",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "add_sub_add_right_eq_sub",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp only [h\u2080, add_sub_add_right_eq_sub, Int.floor_sub_int, Int.floor_intCast, Int.cast_sub, Int.cast_add, Int.cast_one,\n  Int.floor_add_one, Int.floor_add_int]",
          "proofState": 288,
          "pos": {
            "line": 465,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 {\n        re :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.re +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ\u230b -\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imI :=\n          \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imI -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n              2\u207b\u00b9 *\n                \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                      { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imJ :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b +\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b,\n        imK :=\n          2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ +\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b -\n            2\u207b\u00b9 *\n              \u2191\u230a{ re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imJ -\n                    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK\u230b }.imK =\n    { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }.imK",
          "endPos": {
            "line": 466,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.11",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "MulZeroOneClass.toMulOneClass",
            "SubNegMonoid.toSub",
            "mul_div_cancel_right\u2080",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 289,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 \u2191a + \u2191c - 2\u207b\u00b9 * (\u2191c + \u2191d) - 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191a",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.11",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "mul_div_cancel_right\u2080",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 290,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 \u2191b - \u2191d + 2\u207b\u00b9 * (\u2191c + \u2191d) - 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191b",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Real.partialOrder",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "ZeroLEOneClass.neZero.two",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "OrderedAddCommGroup.toAddLeftMono",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "Real.orderedSemiring",
            "congrArg",
            "Real.instDivInvMonoid",
            "NeZero.charZero_one",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommGroup.toAddGroup",
            "OrderedSemiring.zeroLEOneClass",
            "Real.semiring",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "add_add_sub_cancel",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "Real.instAddCommGroup",
            "DivisionMonoid.toDivInvMonoid",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "mul_div_cancel_right\u2080",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Real.orderedAddCommGroup",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "True",
            "MulOneClass.toOne",
            "Real.field",
            "eq_self",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Bool",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "add_self_div_two",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 291,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 2\u207b\u00b9 * (\u2191c + \u2191d) + 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191c",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Real.partialOrder",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "ZeroLEOneClass.neZero.two",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "OrderedAddCommGroup.toAddLeftMono",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "Real.orderedSemiring",
            "congrArg",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "NeZero.charZero_one",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "add_sub_sub_cancel",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommGroup.toAddGroup",
            "OrderedSemiring.zeroLEOneClass",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "Real.instAddCommGroup",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "MulZeroOneClass.toMulOneClass",
            "SubNegMonoid.toSub",
            "mul_div_cancel_right\u2080",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Real.orderedAddCommGroup",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "True",
            "MulOneClass.toOne",
            "Real.field",
            "eq_self",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "Bool",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "add_self_div_two",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 292,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 2\u207b\u00b9 * (\u2191c + \u2191d) - 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191d",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 293,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 \u2191a + \u2191c + 1 - 2\u207b\u00b9 * (\u2191c + \u2191d + 1) - 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191a + 2\u207b\u00b9",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 294,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 \u2191b - \u2191d + 2\u207b\u00b9 * (\u2191c + \u2191d + 1) - 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191b + 2\u207b\u00b9",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "DivisionMonoid.toDivInvMonoid",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 295,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 2\u207b\u00b9 * (\u2191c + \u2191d + 1) + 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191c + 2\u207b\u00b9",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 296,
          "pos": {
            "line": 467,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 2\u207b\u00b9 * (\u2191c + \u2191d + 1) - 2\u207b\u00b9 * (\u2191c - \u2191d) = \u2191d + 2\u207b\u00b9",
          "endPos": {
            "line": 467,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "id",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "Field.toCommRing",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Real.field",
            "Real.instIntCast",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Int.instSub",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 297,
          "pos": {
            "line": 468,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (\u2191a + \u2191c) * 2 - (\u2191c + \u2191d) - (\u2191c - \u2191d) = \u2191a * 2",
          "endPos": {
            "line": 468,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "Real.field",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Int.instSub",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 298,
          "pos": {
            "line": 468,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (\u2191b - \u2191d) * 2 + (\u2191c + \u2191d) - (\u2191c - \u2191d) = \u2191b * 2",
          "endPos": {
            "line": 468,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Real.instDivInvMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "Field.toCommRing",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "congr",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Int.instSub",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Int.cast_one",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 299,
          "pos": {
            "line": 468,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (\u2191a + \u2191c + 1) * 2 - (\u2191c + \u2191d + 1) - (\u2191c - \u2191d) = \u2191a * 2 + 1",
          "endPos": {
            "line": 468,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "Real",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Real.instDivInvMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "congr",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Int.instSub",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Int.cast_one",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 300,
          "pos": {
            "line": 468,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (\u2191b - \u2191d) * 2 + (\u2191c + \u2191d + 1) - (\u2191c - \u2191d) = \u2191b * 2 + 1",
          "endPos": {
            "line": 468,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "Real",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Real.instDivInvMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "congr",
            "MulOneClass.toOne",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Int.instSub",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Int.cast_one",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 301,
          "pos": {
            "line": 468,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 \u2191c + \u2191d + 1 + (\u2191c - \u2191d) = \u2191c * 2 + 1",
          "endPos": {
            "line": 468,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "Real",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Real.instDivInvMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "id",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "congr",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Int.instSub",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Int.cast_one",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 302,
          "pos": {
            "line": 468,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 \u2191c + \u2191d + 1 - (\u2191c - \u2191d) = \u2191d * 2 + 1",
          "endPos": {
            "line": 468,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 303,
          "pos": {
            "line": 469,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (a + c) * 2 - (c + d) - (c - d) = a * 2",
          "endPos": {
            "line": 469,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 304,
          "pos": {
            "line": 469,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inl.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (b - d) * 2 + (c + d) - (c - d) = b * 2",
          "endPos": {
            "line": 469,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "AddMonoidWithOne.toOne",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 305,
          "pos": {
            "line": 469,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (a + c + 1) * 2 - (c + d + 1) - (c - d) = a * 2 + 1",
          "endPos": {
            "line": 469,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "AddMonoidWithOne.toOne",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 306,
          "pos": {
            "line": 469,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 (b - d) * 2 + (c + d + 1) - (c - d) = b * 2 + 1",
          "endPos": {
            "line": 469,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "AddMonoidWithOne.toOne",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 307,
          "pos": {
            "line": 469,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 c + d + 1 + (c - d) = c * 2 + 1",
          "endPos": {
            "line": 469,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "AddMonoidWithOne.toOne",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 308,
          "pos": {
            "line": 469,
            "column": 2
          },
          "goals": "case intro.intro.intro.intro.inr.a\nh\u2080 : \u2200 (x y : \u2124), \u2191x + 2\u207b\u00b9 + (\u2191y + 2\u207b\u00b9) = \u2191(x + y + 1)\na b c d : \u2124\n\u22a2 c + d + 1 - (c - d) = d * 2 + 1",
          "endPos": {
            "line": 469,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 309,
          "pos": {
            "line": 491,
            "column": 2
          },
          "goals": "\u22a2 toQuaternion 0 = 0",
          "endPos": {
            "line": 491,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddCommGroupWithOne.toAddCommGroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 310,
          "pos": {
            "line": 491,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 0).re = QuaternionAlgebra.re 0",
          "endPos": {
            "line": 491,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddCommGroupWithOne.toAddCommGroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 311,
          "pos": {
            "line": 491,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 0).imI = QuaternionAlgebra.imI 0",
          "endPos": {
            "line": 491,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddCommGroupWithOne.toAddCommGroup",
            "QuaternionAlgebra.imJ",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 312,
          "pos": {
            "line": 491,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 0).imJ = QuaternionAlgebra.imJ 0",
          "endPos": {
            "line": 491,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "QuaternionAlgebra.imK",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddCommGroupWithOne.toAddCommGroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 313,
          "pos": {
            "line": 491,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 0).imK = QuaternionAlgebra.imK 0",
          "endPos": {
            "line": 491,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 314,
          "pos": {
            "line": 513,
            "column": 2
          },
          "goals": "\u22a2 toQuaternion 1 = 1",
          "endPos": {
            "line": 513,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "sub_zero",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Int.cast_one",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 315,
          "pos": {
            "line": 513,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 1).re = QuaternionAlgebra.re 1",
          "endPos": {
            "line": 513,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "sub_zero",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddCommGroupWithOne.toAddCommGroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 316,
          "pos": {
            "line": 513,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 1).imI = QuaternionAlgebra.imI 1",
          "endPos": {
            "line": 513,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "sub_zero",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddCommGroupWithOne.toAddCommGroup",
            "QuaternionAlgebra.imJ",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 317,
          "pos": {
            "line": 513,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 1).imJ = QuaternionAlgebra.imJ 1",
          "endPos": {
            "line": 513,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "sub_self",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "sub_zero",
            "Int.cast_zero",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Real.instAddGroup",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "instOfNat",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "True",
            "Real.instNeg",
            "eq_self",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "QuaternionAlgebra.imK",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddCommGroupWithOne.toAddCommGroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 318,
          "pos": {
            "line": 513,
            "column": 10
          },
          "goals": "case a\n\u22a2 (toQuaternion 1).imK = QuaternionAlgebra.imK 1",
          "endPos": {
            "line": 513,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 319,
          "pos": {
            "line": 533,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 (-z).toQuaternion = -z.toQuaternion",
          "endPos": {
            "line": 533,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "neg_sub",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instNeg",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 320,
          "pos": {
            "line": 533,
            "column": 10
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-z).toQuaternion.re = (-z.toQuaternion).re",
          "endPos": {
            "line": 533,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "neg_sub",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instNeg",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 321,
          "pos": {
            "line": 533,
            "column": 10
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-z).toQuaternion.imI = (-z.toQuaternion).imI",
          "endPos": {
            "line": 533,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instNeg",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "QuaternionAlgebra.imJ",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 322,
          "pos": {
            "line": 533,
            "column": 10
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-z).toQuaternion.imJ = (-z.toQuaternion).imJ",
          "endPos": {
            "line": 533,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "neg_sub",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instNeg",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "QuaternionAlgebra.imK",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 323,
          "pos": {
            "line": 533,
            "column": 10
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-z).toQuaternion.imK = (-z.toQuaternion).imK",
          "endPos": {
            "line": 533,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "SubNegZeroMonoid.toNegZeroClass",
            "Mathlib.Tactic.Ring.of_eq",
            "Real.instAddCommGroup",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 324,
          "pos": {
            "line": 533,
            "column": 34
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 -\u2191z.re + 2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi = 2\u207b\u00b9 * \u2191z.im_oi - (\u2191z.re - 2\u207b\u00b9 * \u2191z.im_o)",
          "endPos": {
            "line": 533,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "SubNegZeroMonoid.toNegZeroClass",
            "Mathlib.Tactic.Ring.of_eq",
            "Real.instAddCommGroup",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 325,
          "pos": {
            "line": 533,
            "column": 34
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 -\u2191z.im_i + -(2\u207b\u00b9 * \u2191z.im_o) + 2\u207b\u00b9 * \u2191z.im_oi = 2\u207b\u00b9 * \u2191z.im_oi - (\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o)",
          "endPos": {
            "line": 533,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Tactic.Ring.of_eq",
            "Real.instAddCommGroup",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 326,
          "pos": {
            "line": 533,
            "column": 34
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 -(2\u207b\u00b9 * \u2191z.im_o) + -(2\u207b\u00b9 * \u2191z.im_oi) = -(2\u207b\u00b9 * \u2191z.im_oi) + -(2\u207b\u00b9 * \u2191z.im_o)",
          "endPos": {
            "line": 533,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Tactic.Ring.of_eq",
            "Real.instAddCommGroup",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 327,
          "pos": {
            "line": 533,
            "column": 34
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 -(2\u207b\u00b9 * \u2191z.im_o) + 2\u207b\u00b9 * \u2191z.im_oi = 2\u207b\u00b9 * \u2191z.im_oi - 2\u207b\u00b9 * \u2191z.im_o",
          "endPos": {
            "line": 533,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 328,
          "pos": {
            "line": 553,
            "column": 2
          },
          "goals": "z w : \ud835\udcde\n\u22a2 (z + w).toQuaternion = z.toQuaternion + w.toQuaternion",
          "endPos": {
            "line": 553,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 329,
          "pos": {
            "line": 553,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z + w).toQuaternion.re = (z.toQuaternion + w.toQuaternion).re",
          "endPos": {
            "line": 553,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 330,
          "pos": {
            "line": 553,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z + w).toQuaternion.imI = (z.toQuaternion + w.toQuaternion).imI",
          "endPos": {
            "line": 553,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "QuaternionAlgebra.imJ",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 331,
          "pos": {
            "line": 553,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z + w).toQuaternion.imJ = (z.toQuaternion + w.toQuaternion).imJ",
          "endPos": {
            "line": 553,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Inv.inv",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 332,
          "pos": {
            "line": 553,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z + w).toQuaternion.imK = (z.toQuaternion + w.toQuaternion).imK",
          "endPos": {
            "line": 553,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 333,
          "pos": {
            "line": 553,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 \u2191z.re + \u2191w.re - 2\u207b\u00b9 * (\u2191z.im_o + \u2191w.im_o) - 2\u207b\u00b9 * (\u2191z.im_oi + \u2191w.im_oi) =\n    \u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi + (\u2191w.re - 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 553,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 334,
          "pos": {
            "line": 553,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 \u2191z.im_i + \u2191w.im_i + 2\u207b\u00b9 * (\u2191z.im_o + \u2191w.im_o) - 2\u207b\u00b9 * (\u2191z.im_oi + \u2191w.im_oi) =\n    \u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi + (\u2191w.im_i + 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 553,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Distrib.toAdd",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 335,
          "pos": {
            "line": 553,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 2\u207b\u00b9 * (\u2191z.im_o + \u2191w.im_o) + 2\u207b\u00b9 * (\u2191z.im_oi + \u2191w.im_oi) =\n    2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi + (2\u207b\u00b9 * \u2191w.im_o + 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 553,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Real.instRCLike",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Tactic.Ring.add_mul",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 336,
          "pos": {
            "line": 553,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 2\u207b\u00b9 * (\u2191z.im_o + \u2191w.im_o) - 2\u207b\u00b9 * (\u2191z.im_oi + \u2191w.im_oi) =\n    2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi + (2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 553,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "Hurwitz.instAdd",
            "HSub.hSub",
            "Quaternion.instNormedAddCommGroupReal",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NormedAddGroup.toAddGroup",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "Hurwitz.toQuaternion",
            "Hurwitz.toQuaternion_add",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Hurwitz.instNeg",
            "NormedAddCommGroup.toNormedAddGroup",
            "Real.instNeg",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.instSub",
            "Eq",
            "Quaternion.instRing",
            "Neg.neg",
            "Quaternion"
          ],
          "tactic": "convert toQuaternion_add z (-w) using 1",
          "proofState": 337,
          "pos": {
            "line": 560,
            "column": 2
          },
          "goals": "z w : \ud835\udcde\n\u22a2 (z - w).toQuaternion = z.toQuaternion - w.toQuaternion",
          "endPos": {
            "line": 560,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "sub_eq_add_neg",
            "HSub.hSub",
            "Quaternion.instNormedAddCommGroupReal",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NormedAddGroup.toAddGroup",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "Hurwitz.toQuaternion",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Hurwitz.instNeg",
            "NormedAddCommGroup.toNormedAddGroup",
            "Real.instNeg",
            "SubNegMonoid.toNeg",
            "NonUnitalNonAssocSemiring.toDistrib",
            "SubNegMonoid.toAddMonoid",
            "AddZeroClass.toAdd",
            "Eq",
            "Quaternion.instRing",
            "Neg.neg",
            "Quaternion"
          ],
          "tactic": "rw [sub_eq_add_neg, toQuaternion_neg]\n  -- instance : AddCommGroup \ud835\udcde where\n  --   add_assoc := by intros; ext <;> simp [add_assoc]\n  --   zero_add := by intros; ext <;> simp\n  --   add_zero := by intros; ext <;> simp\n  --   nsmul := nsmulRec\n  --   zsmul := zsmulRec\n  --   add_left_neg := by intros; ext <;> simp\n  --   add_comm := by intros; ext <;> simp [add_comm]",
          "proofState": 338,
          "pos": {
            "line": 561,
            "column": 2
          },
          "goals": "case h.e'_3\nz w : \ud835\udcde\n\u22a2 z.toQuaternion - w.toQuaternion = z.toQuaternion + (-w).toQuaternion",
          "endPos": {
            "line": 561,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Nat.recAux"
          ],
          "tactic": "induction n with\n| zero => rw [nsmulRec, zero, zero_smul]\n| succ n ih => rw [nsmulRec, add, add_nsmul, one_nsmul, ih]",
          "proofState": 339,
          "pos": {
            "line": 579,
            "column": 2
          },
          "goals": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : Add M\ninst\u271d : AddMonoid N\nf : M \u2192 N\nzero : f 0 = 0\nadd : \u2200 (x y : M), f (x + y) = f x + f y\nn : \u2115\nx : M\n\u22a2 f (nsmulRec n x) = n \u2022 f x",
          "endPos": {
            "line": 581,
            "column": 61
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction n with\n| zero => rw [nsmulRec, zero, zero_smul]\n| succ n ih => rw [nsmulRec, add, add_nsmul, one_nsmul, ih]",
          "proofState": 340,
          "pos": {
            "line": 579,
            "column": 2
          },
          "goals": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : Add M\ninst\u271d : AddMonoid N\nf : M \u2192 N\nzero : f 0 = 0\nadd : \u2200 (x y : M), f (x + y) = f x + f y\nn : \u2115\nx : M\n\u22a2 f (nsmulRec n x) = n \u2022 f x",
          "endPos": {
            "line": 581,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "instHSMul",
            "congrArg",
            "id",
            "instOfNatNat",
            "nsmulRec",
            "Nat",
            "AddMonoid.toNatSMul",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "OfNat.ofNat",
            "Eq",
            "nsmulRec.eq_1"
          ],
          "tactic": "rw [nsmulRec, zero, zero_smul]",
          "proofState": 341,
          "pos": {
            "line": 580,
            "column": 12
          },
          "goals": "case zero\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : Add M\ninst\u271d : AddMonoid N\nf : M \u2192 N\nzero : f 0 = 0\nadd : \u2200 (x y : M), f (x + y) = f x + f y\nx : M\n\u22a2 f (nsmulRec 0 x) = 0 \u2022 f x",
          "endPos": {
            "line": 580,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "instHSMul",
            "congrArg",
            "id",
            "instOfNatNat",
            "nsmulRec.eq_2",
            "instHAdd",
            "HAdd.hAdd",
            "nsmulRec",
            "Nat",
            "instAddNat",
            "AddMonoid.toNatSMul",
            "HSMul.hSMul",
            "OfNat.ofNat",
            "Nat.succ",
            "Eq"
          ],
          "tactic": "rw [nsmulRec, add, add_nsmul, one_nsmul, ih]",
          "proofState": 342,
          "pos": {
            "line": 581,
            "column": 17
          },
          "goals": "case succ\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : Add M\ninst\u271d : AddMonoid N\nf : M \u2192 N\nzero : f 0 = 0\nadd : \u2200 (x y : M), f (x + y) = f x + f y\nx : M\nn : \u2115\nih : f (nsmulRec n x) = n \u2022 f x\n\u22a2 f (nsmulRec (n + 1) x) = (n + 1) \u2022 f x",
          "endPos": {
            "line": 581,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "Int.rec"
          ],
          "tactic": "induction z with\n| ofNat n => rw [zsmulRec, nsmul, Int.ofNat_eq_coe, natCast_zsmul]\n| negSucc n => rw [zsmulRec, neg, nsmul, negSucc_zsmul]",
          "proofState": 343,
          "pos": {
            "line": 595,
            "column": 2
          },
          "goals": "G : Type u_1\nH : Type u_2\ninst\u271d\u2074 : Zero G\ninst\u271d\u00b3 : Add G\ninst\u271d\u00b2 : Neg G\ninst\u271d\u00b9 : SMul \u2115 G\ninst\u271d : SubNegMonoid H\nf : G \u2192 H\nnsmul : \u2200 (g : G) (n : \u2115), f (n \u2022 g) = n \u2022 f g\nneg : \u2200 (x : G), f (-x) = -f x\nz : \u2124\ng : G\n\u22a2 f (zsmulRec (fun x1 x2 => x1 \u2022 x2) z g) = z \u2022 f g",
          "endPos": {
            "line": 599,
            "column": 44
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction z with\n| ofNat n => rw [zsmulRec, nsmul, Int.ofNat_eq_coe, natCast_zsmul]\n| negSucc n => rw [zsmulRec, neg, nsmul, negSucc_zsmul]",
          "proofState": 344,
          "pos": {
            "line": 595,
            "column": 2
          },
          "goals": "G : Type u_1\nH : Type u_2\ninst\u271d\u2074 : Zero G\ninst\u271d\u00b3 : Add G\ninst\u271d\u00b2 : Neg G\ninst\u271d\u00b9 : SMul \u2115 G\ninst\u271d : SubNegMonoid H\nf : G \u2192 H\nnsmul : \u2200 (g : G) (n : \u2115), f (n \u2022 g) = n \u2022 f g\nneg : \u2200 (x : G), f (-x) = -f x\nz : \u2124\ng : G\n\u22a2 f (zsmulRec (fun x1 x2 => x1 \u2022 x2) z g) = z \u2022 f g",
          "endPos": {
            "line": 599,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "instHSMul",
            "congrArg",
            "id",
            "Int.ofNat",
            "Int",
            "zsmulRec",
            "Nat",
            "HSMul.hSMul",
            "zsmulRec.eq_1",
            "Eq",
            "SubNegMonoid.toZSMul"
          ],
          "tactic": "rw [zsmulRec, nsmul, Int.ofNat_eq_coe, natCast_zsmul]",
          "proofState": 345,
          "pos": {
            "line": 597,
            "column": 4
          },
          "goals": "case ofNat\nG : Type u_1\nH : Type u_2\ninst\u271d\u2074 : Zero G\ninst\u271d\u00b3 : Add G\ninst\u271d\u00b2 : Neg G\ninst\u271d\u00b9 : SMul \u2115 G\ninst\u271d : SubNegMonoid H\nf : G \u2192 H\nnsmul : \u2200 (g : G) (n : \u2115), f (n \u2022 g) = n \u2022 f g\nneg : \u2200 (x : G), f (-x) = -f x\ng : G\nn : \u2115\n\u22a2 f (zsmulRec (fun x1 x2 => x1 \u2022 x2) (Int.ofNat n) g) = Int.ofNat n \u2022 f g",
          "endPos": {
            "line": 597,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "instHSMul",
            "congrArg",
            "id",
            "Int",
            "zsmulRec",
            "zsmulRec.eq_2",
            "Nat",
            "HSMul.hSMul",
            "Int.negSucc",
            "Nat.succ",
            "Eq",
            "Neg.neg",
            "SubNegMonoid.toZSMul"
          ],
          "tactic": "rw [zsmulRec, neg, nsmul, negSucc_zsmul]",
          "proofState": 346,
          "pos": {
            "line": 599,
            "column": 4
          },
          "goals": "case negSucc\nG : Type u_1\nH : Type u_2\ninst\u271d\u2074 : Zero G\ninst\u271d\u00b3 : Add G\ninst\u271d\u00b2 : Neg G\ninst\u271d\u00b9 : SMul \u2115 G\ninst\u271d : SubNegMonoid H\nf : G \u2192 H\nnsmul : \u2200 (g : G) (n : \u2115), f (n \u2022 g) = n \u2022 f g\nneg : \u2200 (x : G), f (-x) = -f x\ng : G\nn : \u2115\n\u22a2 f (zsmulRec (fun x1 x2 => x1 \u2022 x2) (Int.negSucc n) g) = Int.negSucc n \u2022 f g",
          "endPos": {
            "line": 599,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 347,
          "pos": {
            "line": 647,
            "column": 2
          },
          "goals": "z w : \ud835\udcde\n\u22a2 (z * w).toQuaternion = z.toQuaternion * w.toQuaternion",
          "endPos": {
            "line": 647,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "Quaternion.mul_re",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMul",
            "Real.instAdd",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Int.cast_mul",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Quaternion.instRing",
            "Neg.neg",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 348,
          "pos": {
            "line": 647,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z * w).toQuaternion.re = (z.toQuaternion * w.toQuaternion).re",
          "endPos": {
            "line": 647,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMul",
            "Real.instAdd",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Int.cast_mul",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Quaternion.mul_imI",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Quaternion.instRing",
            "Neg.neg",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 349,
          "pos": {
            "line": 647,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z * w).toQuaternion.imI = (z.toQuaternion * w.toQuaternion).imI",
          "endPos": {
            "line": 647,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMul",
            "Real.instAdd",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Int.cast_mul",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Quaternion.instRing",
            "Neg.neg",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Hurwitz.re",
            "Quaternion.mul_imJ",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 350,
          "pos": {
            "line": 647,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z * w).toQuaternion.imJ = (z.toQuaternion * w.toQuaternion).imJ",
          "endPos": {
            "line": 647,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Quaternion.mul_imK",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "QuaternionAlgebra",
            "Int.cast_add",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMul",
            "Real.instAdd",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Int.cast_mul",
            "instHSub",
            "Inv.inv",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Int.instSub",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Quaternion.instRing",
            "Neg.neg",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "simp [toQuaternion]",
          "proofState": 351,
          "pos": {
            "line": 647,
            "column": 10
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 (z * w).toQuaternion.imK = (z.toQuaternion * w.toQuaternion).imK",
          "endPos": {
            "line": 647,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "NonAssocRing.toAddCommGroupWithOne",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 352,
          "pos": {
            "line": 647,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 \u2191z.re * \u2191w.re - \u2191z.im_o * \u2191w.im_o - \u2191z.im_i * \u2191w.im_o - \u2191z.im_i * \u2191w.im_i + \u2191z.im_i * \u2191w.im_oi - \u2191z.im_oi * \u2191w.im_oi -\n        2\u207b\u00b9 *\n          (\u2191z.im_o * \u2191w.re + \u2191z.re * \u2191w.im_o - \u2191z.im_o * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_i +\n            \u2191z.im_i * \u2191w.im_oi) -\n      2\u207b\u00b9 *\n        (\u2191z.im_oi * \u2191w.re - \u2191z.im_i * \u2191w.im_o + \u2191z.im_o * \u2191w.im_i + \u2191z.re * \u2191w.im_oi - \u2191z.im_o * \u2191w.im_oi -\n          \u2191z.im_oi * \u2191w.im_oi) =\n    (\u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.re - 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) -\n          (\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.im_i + 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) -\n        (2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o + 2\u207b\u00b9 * \u2191w.im_oi) -\n      (2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 647,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "NonAssocRing.toAddCommGroupWithOne",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 353,
          "pos": {
            "line": 647,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 \u2191z.im_i * \u2191w.re - \u2191z.im_i * \u2191w.im_o + \u2191z.im_oi * \u2191w.im_o + \u2191z.re * \u2191w.im_i - \u2191z.im_o * \u2191w.im_oi - \u2191z.im_i * \u2191w.im_oi +\n        2\u207b\u00b9 *\n          (\u2191z.im_o * \u2191w.re + \u2191z.re * \u2191w.im_o - \u2191z.im_o * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_i +\n            \u2191z.im_i * \u2191w.im_oi) -\n      2\u207b\u00b9 *\n        (\u2191z.im_oi * \u2191w.re - \u2191z.im_i * \u2191w.im_o + \u2191z.im_o * \u2191w.im_i + \u2191z.re * \u2191w.im_oi - \u2191z.im_o * \u2191w.im_oi -\n          \u2191z.im_oi * \u2191w.im_oi) =\n    (\u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.im_i + 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) +\n          (\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.re - 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) +\n        (2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) -\n      (2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o + 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 647,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "NonAssocRing.toAddCommGroupWithOne",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 354,
          "pos": {
            "line": 647,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 2\u207b\u00b9 *\n        (\u2191z.im_o * \u2191w.re + \u2191z.re * \u2191w.im_o - \u2191z.im_o * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_i +\n          \u2191z.im_i * \u2191w.im_oi) +\n      2\u207b\u00b9 *\n        (\u2191z.im_oi * \u2191w.re - \u2191z.im_i * \u2191w.im_o + \u2191z.im_o * \u2191w.im_i + \u2191z.re * \u2191w.im_oi - \u2191z.im_o * \u2191w.im_oi -\n          \u2191z.im_oi * \u2191w.im_oi) =\n    (\u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o + 2\u207b\u00b9 * \u2191w.im_oi) -\n          (\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) +\n        (2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.re - 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) +\n      (2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.im_i + 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 647,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Nat.rawCast",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "AddMonoid.toAddSemigroup",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Real.instInv",
            "Mathlib.Tactic.Ring.inv_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "DivisionMonoid.toDivInvOneMonoid",
            "Monoid.toNatPow",
            "Rat.rawCast",
            "DivisionRing.toDivisionSemiring",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsInt.to_isRat",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Real.commRing",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "Mathlib.Tactic.Ring.add_mul",
            "NonAssocRing.toAddCommGroupWithOne",
            "Mathlib.Tactic.Ring.inv_single",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsRat.to_raw_eq",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "AddGroup.toSubNegMonoid",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsRat.den_nz",
            "Mathlib.Meta.NormNum.IsRat.of_raw",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Nat",
            "Real.instMul",
            "Mathlib.Tactic.Ring.mul_one",
            "Real.instDivisionRing",
            "Real.instIntCast",
            "Int.mul",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "InvOneClass.toInv",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "AddMonoidWithOne.toAddMonoid",
            "CommRing.toRing",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "ring",
          "proofState": 355,
          "pos": {
            "line": 647,
            "column": 34
          },
          "goals": "case a\nz w : \ud835\udcde\n\u22a2 2\u207b\u00b9 *\n        (\u2191z.im_o * \u2191w.re + \u2191z.re * \u2191w.im_o - \u2191z.im_o * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_o - \u2191z.im_oi * \u2191w.im_i +\n          \u2191z.im_i * \u2191w.im_oi) -\n      2\u207b\u00b9 *\n        (\u2191z.im_oi * \u2191w.re - \u2191z.im_i * \u2191w.im_o + \u2191z.im_o * \u2191w.im_i + \u2191z.re * \u2191w.im_oi - \u2191z.im_o * \u2191w.im_oi -\n          \u2191z.im_oi * \u2191w.im_oi) =\n    (\u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) +\n          (\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (2\u207b\u00b9 * \u2191w.im_o + 2\u207b\u00b9 * \u2191w.im_oi) -\n        (2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.im_i + 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi) +\n      (2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) * (\u2191w.re - 2\u207b\u00b9 * \u2191w.im_o - 2\u207b\u00b9 * \u2191w.im_oi)",
          "endPos": {
            "line": 647,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ext"
          ],
          "tactic": "ext",
          "proofState": 356,
          "pos": {
            "line": 652,
            "column": 2
          },
          "goals": "\u22a2 { re := 0, im_o := 1, im_i := 0, im_oi := 0 } * { re := 0, im_o := 0, im_i := 1, im_oi := 0 } =\n    { re := 0, im_o := 0, im_i := 0, im_oi := 1 }",
          "endPos": {
            "line": 652,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "sub_self",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "Int.instAddMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "MulZeroClass.mul_zero",
            "MulZeroOneClass.toMulOneClass",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "instOfNat",
            "HAdd.hAdd",
            "congr",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "mul_one",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 357,
          "pos": {
            "line": 652,
            "column": 10
          },
          "goals": "case re\n\u22a2 ({ re := 0, im_o := 1, im_i := 0, im_oi := 0 } * { re := 0, im_o := 0, im_i := 1, im_oi := 0 }).re =\n    { re := 0, im_o := 0, im_i := 0, im_oi := 1 }.re",
          "endPos": {
            "line": 652,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "sub_self",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "Int.instAddMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "MulZeroClass.mul_zero",
            "MulZeroOneClass.toMulOneClass",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "instOfNat",
            "HAdd.hAdd",
            "congr",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "mul_one",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 358,
          "pos": {
            "line": 652,
            "column": 10
          },
          "goals": "case im_o\n\u22a2 ({ re := 0, im_o := 1, im_i := 0, im_oi := 0 } * { re := 0, im_o := 0, im_i := 1, im_oi := 0 }).im_o =\n    { re := 0, im_o := 0, im_i := 0, im_oi := 1 }.im_o",
          "endPos": {
            "line": 652,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "sub_self",
            "MulOneClass.toMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "Int.instAddMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "MulZeroClass.mul_zero",
            "MulZeroOneClass.toMulOneClass",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "instOfNat",
            "HAdd.hAdd",
            "congr",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "mul_one",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 359,
          "pos": {
            "line": 652,
            "column": 10
          },
          "goals": "case im_i\n\u22a2 ({ re := 0, im_o := 1, im_i := 0, im_oi := 0 } * { re := 0, im_o := 0, im_i := 1, im_oi := 0 }).im_i =\n    { re := 0, im_o := 0, im_i := 0, im_oi := 1 }.im_i",
          "endPos": {
            "line": 652,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "sub_self",
            "MulOneClass.toMul",
            "congrArg",
            "sub_zero",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "Int.instAddMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "MulZeroOneClass.toMulOneClass",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "instOfNat",
            "HAdd.hAdd",
            "congr",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "mul_one",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 360,
          "pos": {
            "line": 652,
            "column": 10
          },
          "goals": "case im_oi\n\u22a2 ({ re := 0, im_o := 1, im_i := 0, im_oi := 0 } * { re := 0, im_o := 0, im_i := 1, im_oi := 0 }).im_oi =\n    { re := 0, im_o := 0, im_i := 0, im_oi := 1 }.im_oi",
          "endPos": {
            "line": 652,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Nat.recAux"
          ],
          "tactic": "induction n with\n| zero => rw [npowRec, one, pow_zero]\n| succ n ih => rw [npowRec, pow_succ, mul, ih]",
          "proofState": 361,
          "pos": {
            "line": 659,
            "column": 2
          },
          "goals": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : Mul M\ninst\u271d : Monoid N\nf : M \u2192 N\none : f 1 = 1\nmul : \u2200 (x y : M), f (x * y) = f x * f y\nz : M\nn : \u2115\n\u22a2 f (npowRec n z) = f z ^ n",
          "endPos": {
            "line": 661,
            "column": 48
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction n with\n| zero => rw [npowRec, one, pow_zero]\n| succ n ih => rw [npowRec, pow_succ, mul, ih]",
          "proofState": 362,
          "pos": {
            "line": 659,
            "column": 2
          },
          "goals": "M : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : Mul M\ninst\u271d : Monoid N\nf : M \u2192 N\none : f 1 = 1\nmul : \u2200 (x y : M), f (x * y) = f x * f y\nz : M\nn : \u2115\n\u22a2 f (npowRec n z) = f z ^ n",
          "endPos": {
            "line": 661,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "npowRec",
            "HPow.hPow",
            "Nat",
            "One.toOfNat1",
            "instHPow",
            "npowRec.eq_1",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [npowRec, one, pow_zero]",
          "proofState": 363,
          "pos": {
            "line": 660,
            "column": 12
          },
          "goals": "case zero\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : Mul M\ninst\u271d : Monoid N\nf : M \u2192 N\none : f 1 = 1\nmul : \u2200 (x y : M), f (x * y) = f x * f y\nz : M\n\u22a2 f (npowRec 0 z) = f z ^ 0",
          "endPos": {
            "line": 660,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "HMul.hMul",
            "congrArg",
            "npowRec.eq_2",
            "Monoid.toNatPow",
            "id",
            "instOfNatNat",
            "npowRec",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "instAddNat",
            "instHPow",
            "OfNat.ofNat",
            "Nat.succ",
            "Eq",
            "instHMul"
          ],
          "tactic": "rw [npowRec, pow_succ, mul, ih]",
          "proofState": 364,
          "pos": {
            "line": 661,
            "column": 17
          },
          "goals": "case succ\nM : Type u_1\nN : Type u_2\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : Mul M\ninst\u271d : Monoid N\nf : M \u2192 N\none : f 1 = 1\nmul : \u2200 (x y : M), f (x * y) = f x * f y\nz : M\nn : \u2115\nih : f (npowRec n z) = f z ^ n\n\u22a2 f (npowRec (n + 1) z) = f z ^ (n + 1)",
          "endPos": {
            "line": 661,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "Nat.recAux"
          ],
          "tactic": "induction n with\n| zero => rw [Nat.unaryCast, zero, Nat.cast_zero]\n| succ n ih => rw [Nat.unaryCast, add, one, Nat.cast_add, Nat.cast_one, ih]",
          "proofState": 365,
          "pos": {
            "line": 672,
            "column": 2
          },
          "goals": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : One R\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddMonoidWithOne S\nf : R \u2192 S\nzero : f 0 = 0\none : f 1 = 1\nadd : \u2200 (x y : R), f (x + y) = f x + f y\nn : \u2115\n\u22a2 f n.unaryCast = \u2191n",
          "endPos": {
            "line": 674,
            "column": 77
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction n with\n| zero => rw [Nat.unaryCast, zero, Nat.cast_zero]\n| succ n ih => rw [Nat.unaryCast, add, one, Nat.cast_add, Nat.cast_one, ih]",
          "proofState": 366,
          "pos": {
            "line": 672,
            "column": 2
          },
          "goals": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : One R\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddMonoidWithOne S\nf : R \u2192 S\nzero : f 0 = 0\none : f 1 = 1\nadd : \u2200 (x y : R), f (x + y) = f x + f y\nn : \u2115\n\u22a2 f n.unaryCast = \u2191n",
          "endPos": {
            "line": 674,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "Nat.unaryCast.eq_1",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "Nat",
            "Zero.toOfNat0",
            "Nat.unaryCast",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [Nat.unaryCast, zero, Nat.cast_zero]",
          "proofState": 367,
          "pos": {
            "line": 673,
            "column": 12
          },
          "goals": "case zero\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : One R\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddMonoidWithOne S\nf : R \u2192 S\nzero : f 0 = 0\none : f 1 = 1\nadd : \u2200 (x y : R), f (x + y) = f x + f y\n\u22a2 f (Nat.unaryCast 0) = \u21910",
          "endPos": {
            "line": 673,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "Nat.unaryCast.eq_2",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Nat.cast",
            "instHAdd",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "instAddNat",
            "Nat.unaryCast",
            "OfNat.ofNat",
            "Nat.succ",
            "Eq"
          ],
          "tactic": "rw [Nat.unaryCast, add, one, Nat.cast_add, Nat.cast_one, ih]",
          "proofState": 368,
          "pos": {
            "line": 674,
            "column": 17
          },
          "goals": "case succ\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b3 : One R\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddMonoidWithOne S\nf : R \u2192 S\nzero : f 0 = 0\none : f 1 = 1\nadd : \u2200 (x y : R), f (x + y) = f x + f y\nn : \u2115\nih : f n.unaryCast = \u2191n\n\u22a2 f (n + 1).unaryCast = \u2191(n + 1)",
          "endPos": {
            "line": 674,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "Int",
            "Eq.refl"
          ],
          "tactic": "cases n with\n| ofNat n => rw [Int.castDef_ofNat, natCast, Int.ofNat_eq_coe, Int.cast_natCast]\n| negSucc _ => rw [Int.castDef_negSucc, neg, natCast, Int.cast_negSucc]",
          "proofState": 369,
          "pos": {
            "line": 691,
            "column": 2
          },
          "goals": "R : Type u_1\nS : Type u_2\ninst\u271d\u2075 : One R\ninst\u271d\u2074 : Zero R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : NatCast R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroupWithOne S\nf : R \u2192 S\nnatCast : \u2200 (n : \u2115), f \u2191n = \u2191n\nneg : \u2200 (x : R), f (-x) = -f x\nn : \u2124\n\u22a2 f n.castDef = \u2191n",
          "endPos": {
            "line": 693,
            "column": 73
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases n with\n| ofNat n => rw [Int.castDef_ofNat, natCast, Int.ofNat_eq_coe, Int.cast_natCast]\n| negSucc _ => rw [Int.castDef_negSucc, neg, natCast, Int.cast_negSucc]",
          "proofState": 370,
          "pos": {
            "line": 691,
            "column": 2
          },
          "goals": "R : Type u_1\nS : Type u_2\ninst\u271d\u2075 : One R\ninst\u271d\u2074 : Zero R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : NatCast R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroupWithOne S\nf : R \u2192 S\nnatCast : \u2200 (n : \u2115), f \u2191n = \u2191n\nneg : \u2200 (x : R), f (-x) = -f x\nn : \u2124\n\u22a2 f n.castDef = \u2191n",
          "endPos": {
            "line": 693,
            "column": 73
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "congrArg",
            "id",
            "Int.ofNat",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "Int.castDef",
            "Hurwitz.Int.castDef_ofNat",
            "Eq"
          ],
          "tactic": "rw [Int.castDef_ofNat, natCast, Int.ofNat_eq_coe, Int.cast_natCast]",
          "proofState": 371,
          "pos": {
            "line": 692,
            "column": 15
          },
          "goals": "case ofNat\nR : Type u_1\nS : Type u_2\ninst\u271d\u2075 : One R\ninst\u271d\u2074 : Zero R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : NatCast R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroupWithOne S\nf : R \u2192 S\nnatCast : \u2200 (n : \u2115), f \u2191n = \u2191n\nneg : \u2200 (x : R), f (-x) = -f x\nn : \u2115\n\u22a2 f (Int.ofNat n).castDef = \u2191(Int.ofNat n)",
          "endPos": {
            "line": 692,
            "column": 82
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "congrArg",
            "id",
            "instOfNatNat",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "instHAdd",
            "HAdd.hAdd",
            "Nat",
            "Int.castDef",
            "Hurwitz.Int.castDef_negSucc",
            "instAddNat",
            "Int.negSucc",
            "OfNat.ofNat",
            "Eq",
            "Neg.neg"
          ],
          "tactic": "rw [Int.castDef_negSucc, neg, natCast, Int.cast_negSucc]",
          "proofState": 372,
          "pos": {
            "line": 693,
            "column": 17
          },
          "goals": "case negSucc\nR : Type u_1\nS : Type u_2\ninst\u271d\u2075 : One R\ninst\u271d\u2074 : Zero R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : NatCast R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroupWithOne S\nf : R \u2192 S\nnatCast : \u2200 (n : \u2115), f \u2191n = \u2191n\nneg : \u2200 (x : R), f (-x) = -f x\na\u271d : \u2115\n\u22a2 f (Int.negSucc a\u271d).castDef = \u2191(Int.negSucc a\u271d)",
          "endPos": {
            "line": 693,
            "column": 73
          }
        },
        {
          "usedConstants": [
            "Nat.recAux"
          ],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 373,
          "pos": {
            "line": 714,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).re = \u2191n",
          "endPos": {
            "line": 716,
            "column": 22
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 374,
          "pos": {
            "line": 714,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).re = \u2191n",
          "endPos": {
            "line": 716,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "CharP.cast_eq_zero",
            "Hurwitz.ring",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Hurwitz",
            "instOfNat",
            "Int.instRing",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Zero.toOfNat0",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "CharP.ofCharZero",
            "Int.instCharZero",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "Hurwitz.re"
          ],
          "tactic": "simp",
          "proofState": 375,
          "pos": {
            "line": 715,
            "column": 12
          },
          "goals": "case zero\n\u22a2 (\u21910).re = \u21910",
          "endPos": {
            "line": 715,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Hurwitz.ring",
            "AddMonoid.toAddSemigroup",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddCancelMonoid.toIsCancelAdd",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "congr",
            "Int.instAdd",
            "Int.instAddGroup",
            "One.toOfNat1",
            "instAddNat",
            "AddMonoidWithOne.toAddMonoid",
            "AddGroup.toAddCancelMonoid",
            "OfNat.ofNat",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "IsCancelAdd.toIsRightCancelAdd",
            "Mathlib.Algebra.Group.Basic._auxLemma.4",
            "Eq.trans",
            "Hurwitz.re"
          ],
          "tactic": "simpa",
          "proofState": 376,
          "pos": {
            "line": 716,
            "column": 17
          },
          "goals": "case succ\nn : \u2115\nih : (\u2191n).re = \u2191n\n\u22a2 (\u2191(n + 1)).re = \u2191(n + 1)",
          "endPos": {
            "line": 716,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Nat.recAux"
          ],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 377,
          "pos": {
            "line": 718,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).im_o = 0",
          "endPos": {
            "line": 720,
            "column": 22
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 378,
          "pos": {
            "line": 718,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).im_o = 0",
          "endPos": {
            "line": 720,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ring",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Hurwitz",
            "instOfNat",
            "Nat",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Zero.toOfNat0",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 379,
          "pos": {
            "line": 719,
            "column": 12
          },
          "goals": "case zero\n\u22a2 (\u21910).im_o = 0",
          "endPos": {
            "line": 719,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Hurwitz.ring",
            "AddMonoid.toAddSemigroup",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "instAddNat",
            "AddMonoidWithOne.toAddMonoid",
            "add_zero",
            "OfNat.ofNat",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simpa",
          "proofState": 380,
          "pos": {
            "line": 720,
            "column": 17
          },
          "goals": "case succ\nn : \u2115\nih : (\u2191n).im_o = 0\n\u22a2 (\u2191(n + 1)).im_o = 0",
          "endPos": {
            "line": 720,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Nat.recAux"
          ],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 381,
          "pos": {
            "line": 722,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).im_i = 0",
          "endPos": {
            "line": 724,
            "column": 22
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 382,
          "pos": {
            "line": 722,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).im_i = 0",
          "endPos": {
            "line": 724,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ring",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Hurwitz",
            "instOfNat",
            "Nat",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 383,
          "pos": {
            "line": 723,
            "column": 12
          },
          "goals": "case zero\n\u22a2 (\u21910).im_i = 0",
          "endPos": {
            "line": 723,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Hurwitz.ring",
            "AddMonoid.toAddSemigroup",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "instAddNat",
            "Hurwitz.im_i",
            "AddMonoidWithOne.toAddMonoid",
            "add_zero",
            "OfNat.ofNat",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simpa",
          "proofState": 384,
          "pos": {
            "line": 724,
            "column": 17
          },
          "goals": "case succ\nn : \u2115\nih : (\u2191n).im_i = 0\n\u22a2 (\u2191(n + 1)).im_i = 0",
          "endPos": {
            "line": 724,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Nat.recAux"
          ],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 385,
          "pos": {
            "line": 726,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).im_oi = 0",
          "endPos": {
            "line": 728,
            "column": 22
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction n with\n| zero => simp\n| succ n ih => simpa",
          "proofState": 386,
          "pos": {
            "line": 726,
            "column": 2
          },
          "goals": "n : \u2115\n\u22a2 (\u2191n).im_oi = 0",
          "endPos": {
            "line": 728,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ring",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Nat.cast",
            "Hurwitz",
            "instOfNat",
            "Nat",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "Hurwitz.im_oi",
            "of_eq_true",
            "Zero.toOfNat0",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 387,
          "pos": {
            "line": 727,
            "column": 12
          },
          "goals": "case zero\n\u22a2 (\u21910).im_oi = 0",
          "endPos": {
            "line": 727,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Hurwitz.ring",
            "AddMonoid.toAddSemigroup",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "id",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Hurwitz.im_oi",
            "One.toOfNat1",
            "instAddNat",
            "AddMonoidWithOne.toAddMonoid",
            "add_zero",
            "OfNat.ofNat",
            "Eq",
            "Nat.cast_one",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simpa",
          "proofState": 388,
          "pos": {
            "line": 728,
            "column": 17
          },
          "goals": "case succ\nn : \u2115\nih : (\u2191n).im_oi = 0\n\u22a2 (\u2191(n + 1)).im_oi = 0",
          "endPos": {
            "line": 728,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int",
            "Eq.refl"
          ],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 389,
          "pos": {
            "line": 731,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).re = n",
          "endPos": {
            "line": 733,
            "column": 44
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 390,
          "pos": {
            "line": 731,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).re = n",
          "endPos": {
            "line": 733,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "Hurwitz.natCast_re",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "Hurwitz",
            "True",
            "eq_self",
            "of_eq_true",
            "instNatCastInt",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans",
            "Hurwitz.re"
          ],
          "tactic": "simp",
          "proofState": 391,
          "pos": {
            "line": 732,
            "column": 15
          },
          "goals": "case ofNat\na\u271d : \u2115\n\u22a2 (\u2191(Int.ofNat a\u271d)).re = Int.ofNat a\u271d",
          "endPos": {
            "line": 732,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "AddGroup.toSubtractionMonoid",
            "Int.cast_neg",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "Hurwitz.natCast_re",
            "AddMonoid.toAddSemigroup",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_add",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "congr",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "of_eq_true",
            "Int.instAdd",
            "One.toOfNat1",
            "instAddNat",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "Hurwitz.instNatCast",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Nat.cast_one",
            "Hurwitz.instIntCast",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans",
            "Hurwitz.re"
          ],
          "tactic": "simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 392,
          "pos": {
            "line": 733,
            "column": 17
          },
          "goals": "case negSucc\na\u271d : \u2115\n\u22a2 (\u2191(Int.negSucc a\u271d)).re = Int.negSucc a\u271d",
          "endPos": {
            "line": 733,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int",
            "Eq.refl"
          ],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 393,
          "pos": {
            "line": 735,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).im_o = 0",
          "endPos": {
            "line": 737,
            "column": 44
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 394,
          "pos": {
            "line": 735,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).im_o = 0",
          "endPos": {
            "line": 737,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "Hurwitz",
            "instOfNat",
            "True",
            "eq_self",
            "of_eq_true",
            "instNatCastInt",
            "Hurwitz.natCast_im_o",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 395,
          "pos": {
            "line": 736,
            "column": 15
          },
          "goals": "case ofNat\na\u271d : \u2115\n\u22a2 (\u2191(Int.ofNat a\u271d)).im_o = 0",
          "endPos": {
            "line": 736,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "AddGroup.toSubtractionMonoid",
            "Int.cast_neg",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "AddMonoid.toAddSemigroup",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_add",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "congr",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "of_eq_true",
            "Int.instAdd",
            "One.toOfNat1",
            "instAddNat",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Hurwitz.natCast_im_o",
            "AddMonoidWithOne.toAddMonoid",
            "Hurwitz.instNatCast",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "add_zero",
            "OfNat.ofNat",
            "neg_zero",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Nat.cast_one",
            "Hurwitz.instIntCast",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans"
          ],
          "tactic": "simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 396,
          "pos": {
            "line": 737,
            "column": 17
          },
          "goals": "case negSucc\na\u271d : \u2115\n\u22a2 (\u2191(Int.negSucc a\u271d)).im_o = 0",
          "endPos": {
            "line": 737,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int",
            "Eq.refl"
          ],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 397,
          "pos": {
            "line": 739,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).im_i = 0",
          "endPos": {
            "line": 741,
            "column": 44
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 398,
          "pos": {
            "line": 739,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).im_i = 0",
          "endPos": {
            "line": 741,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "congrArg",
            "Hurwitz.natCast_im_i",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "Hurwitz",
            "instOfNat",
            "True",
            "eq_self",
            "of_eq_true",
            "Hurwitz.im_i",
            "instNatCastInt",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 399,
          "pos": {
            "line": 740,
            "column": 15
          },
          "goals": "case ofNat\na\u271d : \u2115\n\u22a2 (\u2191(Int.ofNat a\u271d)).im_i = 0",
          "endPos": {
            "line": 740,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "AddGroup.toSubtractionMonoid",
            "Int.cast_neg",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "AddMonoid.toAddSemigroup",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Hurwitz.natCast_im_i",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_add",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "congr",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "of_eq_true",
            "Int.instAdd",
            "One.toOfNat1",
            "instAddNat",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "Hurwitz.instNatCast",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "add_zero",
            "OfNat.ofNat",
            "neg_zero",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Nat.cast_one",
            "Hurwitz.instIntCast",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans"
          ],
          "tactic": "simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 400,
          "pos": {
            "line": 741,
            "column": 17
          },
          "goals": "case negSucc\na\u271d : \u2115\n\u22a2 (\u2191(Int.negSucc a\u271d)).im_i = 0",
          "endPos": {
            "line": 741,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int",
            "Eq.refl"
          ],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 401,
          "pos": {
            "line": 743,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).im_oi = 0",
          "endPos": {
            "line": 745,
            "column": 44
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases n with\n| ofNat _ => simp\n| negSucc _ => simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 402,
          "pos": {
            "line": 743,
            "column": 2
          },
          "goals": "n : \u2124\n\u22a2 (\u2191n).im_oi = 0",
          "endPos": {
            "line": 745,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "congrArg",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Nat.cast",
            "Hurwitz",
            "instOfNat",
            "True",
            "eq_self",
            "Hurwitz.natCast_im_oi",
            "Hurwitz.im_oi",
            "of_eq_true",
            "instNatCastInt",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Eq.trans"
          ],
          "tactic": "simp",
          "proofState": 403,
          "pos": {
            "line": 744,
            "column": 15
          },
          "goals": "case ofNat\na\u271d : \u2115\n\u22a2 (\u2191(Int.ofNat a\u271d)).im_oi = 0",
          "endPos": {
            "line": 744,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "AddGroup.toSubtractionMonoid",
            "Int.cast_neg",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Int.cast_natCast",
            "Hurwitz.ring",
            "AddMonoid.toAddSemigroup",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Int.cast_add",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "Nat.cast_add",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Hurwitz",
            "instOfNat",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "congr",
            "True",
            "eq_self",
            "SubNegMonoid.toNeg",
            "Hurwitz.natCast_im_oi",
            "Hurwitz.im_oi",
            "of_eq_true",
            "Int.instAdd",
            "One.toOfNat1",
            "instAddNat",
            "Zero.toOfNat0",
            "instNatCastInt",
            "AddMonoidWithOne.toAddMonoid",
            "Hurwitz.instNatCast",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "add_zero",
            "OfNat.ofNat",
            "neg_zero",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Nat.cast_one",
            "Hurwitz.instIntCast",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "Int.cast_one",
            "Eq.trans"
          ],
          "tactic": "simp [\u2190 Int.neg_ofNat_succ]",
          "proofState": 404,
          "pos": {
            "line": 745,
            "column": 17
          },
          "goals": "case negSucc\na\u271d : \u2115\n\u22a2 (\u2191(Int.negSucc a\u271d)).im_oi = 0",
          "endPos": {
            "line": 745,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ext"
          ],
          "tactic": "ext",
          "proofState": 405,
          "pos": {
            "line": 751,
            "column": 26
          },
          "goals": "x : \ud835\udcde\n\u22a2 star (star x) = x",
          "endPos": {
            "line": 751,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "id",
            "Int",
            "Eq",
            "Hurwitz.re"
          ],
          "tactic": "simp only",
          "proofState": 406,
          "pos": {
            "line": 751,
            "column": 34
          },
          "goals": "case re\nx : \ud835\udcde\n\u22a2 (star (star x)).re = x.re",
          "endPos": {
            "line": 751,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "id",
            "Hurwitz.im_o",
            "Int",
            "Eq"
          ],
          "tactic": "simp only",
          "proofState": 407,
          "pos": {
            "line": 751,
            "column": 34
          },
          "goals": "case im_o\nx : \ud835\udcde\n\u22a2 (star (star x)).im_o = x.im_o",
          "endPos": {
            "line": 751,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "id",
            "Int",
            "Hurwitz.im_i",
            "Eq"
          ],
          "tactic": "simp only",
          "proofState": 408,
          "pos": {
            "line": 751,
            "column": 34
          },
          "goals": "case im_i\nx : \ud835\udcde\n\u22a2 (star (star x)).im_i = x.im_i",
          "endPos": {
            "line": 751,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "id",
            "Int",
            "Hurwitz.im_oi",
            "Eq"
          ],
          "tactic": "simp only",
          "proofState": 409,
          "pos": {
            "line": 751,
            "column": 34
          },
          "goals": "case im_oi\nx : \ud835\udcde\n\u22a2 (star (star x)).im_oi = x.im_oi",
          "endPos": {
            "line": 751,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 410,
          "pos": {
            "line": 751,
            "column": 48
          },
          "goals": "case re\nx : \ud835\udcde\n\u22a2 x.re - x.im_o - x.im_oi - -x.im_o - -x.im_oi = x.re",
          "endPos": {
            "line": 751,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 411,
          "pos": {
            "line": 751,
            "column": 48
          },
          "goals": "case im_o\nx : \ud835\udcde\n\u22a2 - -x.im_o = x.im_o",
          "endPos": {
            "line": 751,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 412,
          "pos": {
            "line": 751,
            "column": 48
          },
          "goals": "case im_i\nx : \ud835\udcde\n\u22a2 - -x.im_i = x.im_i",
          "endPos": {
            "line": 751,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 413,
          "pos": {
            "line": 751,
            "column": 48
          },
          "goals": "case im_oi\nx : \ud835\udcde\n\u22a2 - -x.im_oi = x.im_oi",
          "endPos": {
            "line": 751,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ext"
          ],
          "tactic": "ext",
          "proofState": 414,
          "pos": {
            "line": 752,
            "column": 21
          },
          "goals": "x y : \ud835\udcde\n\u22a2 star (x * y) = star y * star x",
          "endPos": {
            "line": 752,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "neg_sub",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "neg_neg",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "neg_mul",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 415,
          "pos": {
            "line": 752,
            "column": 29
          },
          "goals": "case re\nx y : \ud835\udcde\n\u22a2 (star (x * y)).re = (star y * star x).re",
          "endPos": {
            "line": 752,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "neg_sub",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "neg_neg",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "neg_mul",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 416,
          "pos": {
            "line": 752,
            "column": 29
          },
          "goals": "case im_o\nx y : \ud835\udcde\n\u22a2 (star (x * y)).im_o = (star y * star x).im_o",
          "endPos": {
            "line": 752,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "neg_sub",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "neg_neg",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "neg_mul",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 417,
          "pos": {
            "line": 752,
            "column": 29
          },
          "goals": "case im_i\nx y : \ud835\udcde\n\u22a2 (star (x * y)).im_i = (star y * star x).im_i",
          "endPos": {
            "line": 752,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "neg_sub",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "neg_neg",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "neg_mul",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp",
          "proofState": 418,
          "pos": {
            "line": 752,
            "column": 29
          },
          "goals": "case im_oi\nx y : \ud835\udcde\n\u22a2 (star (x * y)).im_oi = (star y * star x).im_oi",
          "endPos": {
            "line": 752,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.mul_one",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 419,
          "pos": {
            "line": 752,
            "column": 38
          },
          "goals": "case re\nx y : \ud835\udcde\n\u22a2 x.re * y.re - x.im_o * y.im_o - x.im_i * y.im_o - x.im_i * y.im_i + x.im_i * y.im_oi - x.im_oi * y.im_oi -\n        (x.im_o * y.re + x.re * y.im_o - x.im_o * y.im_o - x.im_oi * y.im_o - x.im_oi * y.im_i + x.im_i * y.im_oi) -\n      (x.im_oi * y.re - x.im_i * y.im_o + x.im_o * y.im_i + x.re * y.im_oi - x.im_o * y.im_oi - x.im_oi * y.im_oi) =\n    (y.re - y.im_o - y.im_oi) * (x.re - x.im_o - x.im_oi) - y.im_o * x.im_o - y.im_i * x.im_o - y.im_i * x.im_i +\n        y.im_i * x.im_oi -\n      y.im_oi * x.im_oi",
          "endPos": {
            "line": 752,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.mul_one",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "SubNegMonoid.toNeg",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 420,
          "pos": {
            "line": 752,
            "column": 38
          },
          "goals": "case im_o\nx y : \ud835\udcde\n\u22a2 -(x.im_i * y.im_oi) + (x.im_oi * y.im_i - (x.im_o * y.re + x.re * y.im_o - x.im_o * y.im_o - x.im_oi * y.im_o)) =\n    -(y.im_o * (x.re - x.im_o - x.im_oi)) + -((y.re - y.im_o - y.im_oi) * x.im_o) - y.im_o * x.im_o - y.im_oi * x.im_o -\n        y.im_oi * x.im_i +\n      y.im_i * x.im_oi",
          "endPos": {
            "line": 752,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.mul_one",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 421,
          "pos": {
            "line": 752,
            "column": 38
          },
          "goals": "case im_i\nx y : \ud835\udcde\n\u22a2 x.im_i * y.im_oi - (x.im_i * y.re - x.im_i * y.im_o + x.im_oi * y.im_o + x.re * y.im_i - x.im_o * y.im_oi) =\n    -(y.im_i * (x.re - x.im_o - x.im_oi)) - y.im_i * x.im_o + y.im_oi * x.im_o + -((y.re - y.im_o - y.im_oi) * x.im_i) -\n        y.im_o * x.im_oi -\n      y.im_i * x.im_oi",
          "endPos": {
            "line": 752,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.mul_one",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 422,
          "pos": {
            "line": 752,
            "column": 38
          },
          "goals": "case im_oi\nx y : \ud835\udcde\n\u22a2 x.im_oi * y.im_oi - (x.im_oi * y.re - x.im_i * y.im_o + x.im_o * y.im_i + x.re * y.im_oi - x.im_o * y.im_oi) =\n    -(y.im_oi * (x.re - x.im_o - x.im_oi)) - y.im_i * x.im_o + y.im_o * x.im_i +\n          -((y.re - y.im_o - y.im_oi) * x.im_oi) -\n        y.im_o * x.im_oi -\n      y.im_oi * x.im_oi",
          "endPos": {
            "line": 752,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ext"
          ],
          "tactic": "ext",
          "proofState": 423,
          "pos": {
            "line": 753,
            "column": 21
          },
          "goals": "x y : \ud835\udcde\n\u22a2 star (x + y) = star x + star y",
          "endPos": {
            "line": 753,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "id",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "HAdd.hAdd",
            "congr",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "Hurwitz.im_i",
            "Int.instSub",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Hurwitz.re"
          ],
          "tactic": "simp",
          "proofState": 424,
          "pos": {
            "line": 753,
            "column": 29
          },
          "goals": "case re\nx y : \ud835\udcde\n\u22a2 (star (x + y)).re = (star x + star y).re",
          "endPos": {
            "line": 753,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "id",
            "Int.instNegInt",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "HAdd.hAdd",
            "congr",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "Hurwitz.im_i",
            "Int.instSub",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Hurwitz.re"
          ],
          "tactic": "simp",
          "proofState": 425,
          "pos": {
            "line": 753,
            "column": 29
          },
          "goals": "case im_o\nx y : \ud835\udcde\n\u22a2 (star (x + y)).im_o = (star x + star y).im_o",
          "endPos": {
            "line": 753,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "id",
            "Int.instNegInt",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "HAdd.hAdd",
            "congr",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "Hurwitz.im_i",
            "Int.instSub",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Hurwitz.re"
          ],
          "tactic": "simp",
          "proofState": 426,
          "pos": {
            "line": 753,
            "column": 29
          },
          "goals": "case im_i\nx y : \ud835\udcde\n\u22a2 (star (x + y)).im_i = (star x + star y).im_i",
          "endPos": {
            "line": 753,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Int.instAddCommGroup",
            "Eq.mpr",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "id",
            "Int.instNegInt",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "HAdd.hAdd",
            "congr",
            "SubNegMonoid.toNeg",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.mk",
            "Hurwitz.im_i",
            "Int.instSub",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "AddZeroClass.toAdd",
            "Eq",
            "Neg.neg",
            "Hurwitz.re"
          ],
          "tactic": "simp",
          "proofState": 427,
          "pos": {
            "line": 753,
            "column": 29
          },
          "goals": "case im_oi\nx y : \ud835\udcde\n\u22a2 (star (x + y)).im_oi = (star x + star y).im_oi",
          "endPos": {
            "line": 753,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "instHSub",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 428,
          "pos": {
            "line": 753,
            "column": 38
          },
          "goals": "case re\nx y : \ud835\udcde\n\u22a2 x.re + y.re - (x.im_o + y.im_o) - (x.im_oi + y.im_oi) = x.re - x.im_o - x.im_oi + (y.re - y.im_o - y.im_oi)",
          "endPos": {
            "line": 753,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "SubNegMonoid.toNeg",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 429,
          "pos": {
            "line": 753,
            "column": 38
          },
          "goals": "case im_o\nx y : \ud835\udcde\n\u22a2 -y.im_o + -x.im_o = -x.im_o + -y.im_o",
          "endPos": {
            "line": 753,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "SubNegMonoid.toNeg",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 430,
          "pos": {
            "line": 753,
            "column": 38
          },
          "goals": "case im_i\nx y : \ud835\udcde\n\u22a2 -y.im_i + -x.im_i = -x.im_i + -y.im_i",
          "endPos": {
            "line": 753,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "SubNegMonoid.toNeg",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 431,
          "pos": {
            "line": 753,
            "column": 38
          },
          "goals": "case im_oi\nx y : \ud835\udcde\n\u22a2 -y.im_oi + -x.im_oi = -x.im_oi + -y.im_oi",
          "endPos": {
            "line": 753,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 432,
          "pos": {
            "line": 761,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 (star z).toQuaternion = star z.toQuaternion",
          "endPos": {
            "line": 761,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Quaternion.star_re",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "id",
            "Int.instNegInt",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "Int",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "Quaternion.instStar",
            "instHSub",
            "Inv.inv",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Int.instSub",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Quaternion",
            "Hurwitz.re",
            "instHMul",
            "Star.star",
            "Real.instNatCast"
          ],
          "tactic": "simp only [star_re, star_im_o, star_im_i, star_im_oi, toQuaternion, Quaternion.star_re, Quaternion.star_imI,\n  Quaternion.star_imJ, Quaternion.star_imK]",
          "proofState": 433,
          "pos": {
            "line": 762,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (star z).toQuaternion.re = (star z.toQuaternion).re",
          "endPos": {
            "line": 763,
            "column": 86
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "AddMonoidWithOne.toOne",
            "Ring.toAddCommGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp only [star_re, star_im_o, star_im_i, star_im_oi, toQuaternion, Quaternion.star_re, Quaternion.star_imI,\n  Quaternion.star_imJ, Quaternion.star_imK]",
          "proofState": 434,
          "pos": {
            "line": 762,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (star z).toQuaternion.imI = (star z.toQuaternion).imI",
          "endPos": {
            "line": 763,
            "column": 86
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "AddMonoidWithOne.toOne",
            "Ring.toAddCommGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MulZeroClass.toZero",
            "QuaternionAlgebra.imJ"
          ],
          "tactic": "simp only [star_re, star_im_o, star_im_i, star_im_oi, toQuaternion, Quaternion.star_re, Quaternion.star_imI,\n  Quaternion.star_imJ, Quaternion.star_imK]",
          "proofState": 435,
          "pos": {
            "line": 762,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (star z).toQuaternion.imJ = (star z.toQuaternion).imJ",
          "endPos": {
            "line": 763,
            "column": 86
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "AddMonoidWithOne.toOne",
            "Ring.toAddCommGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp only [star_re, star_im_o, star_im_i, star_im_oi, toQuaternion, Quaternion.star_re, Quaternion.star_imI,\n  Quaternion.star_imJ, Quaternion.star_imK]",
          "proofState": 436,
          "pos": {
            "line": 762,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (star z).toQuaternion.imK = (star z.toQuaternion).imK",
          "endPos": {
            "line": 763,
            "column": 86
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Int.cast_sub",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "Int",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "Hurwitz.im_oi",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Int.instSub",
            "Nat.cast_zero",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "one_mul",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 437,
          "pos": {
            "line": 764,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 \u2191(z.re - z.im_o - z.im_oi) - 2\u207b\u00b9 * \u2191(-z.im_o) - 2\u207b\u00b9 * \u2191(-z.im_oi) = \u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi",
          "endPos": {
            "line": 764,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "neg_div'",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "DivInvMonoid.toInv",
            "neg_sub",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "Int",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "neg_mul",
            "Nat.cast_zero",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "one_mul",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 438,
          "pos": {
            "line": 764,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 \u2191(-z.im_i) + 2\u207b\u00b9 * \u2191(-z.im_o) - 2\u207b\u00b9 * \u2191(-z.im_oi) = -(\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi)",
          "endPos": {
            "line": 764,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "neg_add_rev",
            "Real.instLinearOrderedField",
            "neg_div'",
            "AddGroup.toSubtractionMonoid",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "div_add'",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.11",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "Int",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "DivisionMonoid.toDivInvMonoid",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Nat",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Bool",
            "Mathlib.Meta.NormNum.isNat_mul",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "neg_mul",
            "Nat.cast_zero",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "div_div",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 439,
          "pos": {
            "line": 764,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 2\u207b\u00b9 * \u2191(-z.im_o) + 2\u207b\u00b9 * \u2191(-z.im_oi) = -(2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi)",
          "endPos": {
            "line": 764,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "neg_div'",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast_neg",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "NegZeroClass.toNeg",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "DivInvMonoid.toInv",
            "neg_sub",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.11",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "NonAssocSemiring.toMulZeroOneClass",
            "div_mul_eq_mul_div",
            "Int",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "Real.instMul",
            "congr",
            "Semifield.toCommGroupWithZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "DivInvMonoid.toDiv",
            "Hurwitz.im_oi",
            "Bool",
            "Mathlib.Meta.NormNum.isNat_mul",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "neg_mul",
            "div_sub'",
            "Nat.cast_zero",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "div_div",
            "SubNegMonoid.toAddMonoid",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "sub_div'",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Field.toEuclideanDomain",
            "one_mul",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 440,
          "pos": {
            "line": 764,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 2\u207b\u00b9 * \u2191(-z.im_o) - 2\u207b\u00b9 * \u2191(-z.im_oi) = -(2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi)",
          "endPos": {
            "line": 764,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "id",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "Field.toCommRing",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Nat",
            "congr",
            "Real.field",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Int.instSub",
            "instNatCastInt",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Hurwitz.re",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 441,
          "pos": {
            "line": 765,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (\u2191z.re - \u2191z.im_o - \u2191z.im_oi) * 2 + \u2191z.im_o + \u2191z.im_oi = \u2191z.re * 2 - \u2191z.im_o - \u2191z.im_oi",
          "endPos": {
            "line": 765,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.4",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "LinearOrderedSemifield.toSemifield",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "Real.normedCommRing",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "instNatCastInt",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 442,
          "pos": {
            "line": 765,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 -(\u2191z.im_i * 2) + -\u2191z.im_o + \u2191z.im_oi = \u2191z.im_oi - (\u2191z.im_i * 2 + \u2191z.im_o)",
          "endPos": {
            "line": 765,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "NegZeroClass.toNeg",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.4",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "instMulNat",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "Real.normedCommRing",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "Semifield.toCommGroupWithZero",
            "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instIntCast",
            "SubNegMonoid.toNeg",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "CommGroupWithZero.toDivisionCommMonoid",
            "instNatCastInt",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 443,
          "pos": {
            "line": 765,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-(\u2191z.im_o * 2) + -(\u2191z.im_oi * 2)) * 2 = (-\u2191z.im_oi + -\u2191z.im_o) * (2 * 2)",
          "endPos": {
            "line": 765,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.4",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Real.semiring",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "instMulNat",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "SubNegMonoid.toSub",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "Real.normedCommRing",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "Semifield.toCommGroupWithZero",
            "Mathlib.Data.Nat.Cast.Basic._auxLemma.1",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Int.instSub",
            "instNatCastInt",
            "MulZeroOneClass.toMulZeroClass",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Hurwitz.toQuaternion.proof_1",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 444,
          "pos": {
            "line": 765,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-(\u2191z.im_o * 2) + 2 * \u2191z.im_oi) * 2 = (\u2191z.im_oi - \u2191z.im_o) * (2 * 2)",
          "endPos": {
            "line": 765,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 445,
          "pos": {
            "line": 766,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (z.re - z.im_o - z.im_oi) * 2 + z.im_o + z.im_oi = z.re * 2 - z.im_o - z.im_oi",
          "endPos": {
            "line": 766,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 446,
          "pos": {
            "line": 766,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 -(z.im_i * 2) + -z.im_o + z.im_oi = z.im_oi - (z.im_i * 2 + z.im_o)",
          "endPos": {
            "line": 766,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "instMulNat",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_natCast",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Mathlib.Meta.NormNum.isNat_mul",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 447,
          "pos": {
            "line": 766,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-(z.im_o * 2) + -(z.im_oi * 2)) * 2 = (-z.im_oi + -z.im_o) * \u2191(2 * 2)",
          "endPos": {
            "line": 766,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.instNegInt",
            "Int.ofNat",
            "instMulNat",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_natCast",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.mul_one",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Mathlib.Meta.NormNum.isNat_mul",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 448,
          "pos": {
            "line": 766,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 (-(z.im_o * 2) + 2 * z.im_oi) * 2 = (z.im_oi - z.im_o) * \u2191(2 * 2)",
          "endPos": {
            "line": 766,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "Hurwitz.ring",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "congrArg",
            "Function.comp",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.commRing",
            "StarAddMonoid.toInvolutiveStar",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instOne",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "StarRing.toStarAddMonoid",
            "Hurwitz.toQuaternion",
            "Quaternion.instStar",
            "Hurwitz",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "InvolutiveStar.toStar",
            "AddCommMonoid.toAddMonoid",
            "_auxLemma.28",
            "Eq",
            "Hurwitz.starRing",
            "Quaternion",
            "Star.star"
          ],
          "tactic": "simp only [Function.comp_apply, \u2190 toQuaternion_star]",
          "proofState": 449,
          "pos": {
            "line": 769,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 star z = (fromQuaternion \u2218 star \u2218 toQuaternion) z",
          "endPos": {
            "line": 769,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Hurwitz.ring",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.leftInverse_fromQuaternion_toQuaternion",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "StarAddMonoid.toInvolutiveStar",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "StarRing.toStarAddMonoid",
            "Hurwitz.toQuaternion",
            "Hurwitz",
            "Hurwitz.fromQuaternion",
            "InvolutiveStar.toStar",
            "AddCommMonoid.toAddMonoid",
            "Eq",
            "Hurwitz.starRing",
            "Star.star"
          ],
          "tactic": "rw [leftInverse_fromQuaternion_toQuaternion]",
          "proofState": 450,
          "pos": {
            "line": 770,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 star z = fromQuaternion (star z).toQuaternion",
          "endPos": {
            "line": 770,
            "column": 46
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa [Hurwitz.ext_iff] using hxy",
          "proofState": 451,
          "pos": {
            "line": 773,
            "column": 31
          },
          "goals": "x y : \u2115\nhxy : \u2191x = \u2191y\n\u22a2 x = y",
          "endPos": {
            "line": 773,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ext"
          ],
          "tactic": "ext",
          "proofState": 452,
          "pos": {
            "line": 780,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 \u2191z.norm = z * star z",
          "endPos": {
            "line": 780,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.instIntCast",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Hurwitz.intCast_re"
          ],
          "tactic": "simp [norm, \u2190 Int.cast_add]",
          "proofState": 453,
          "pos": {
            "line": 780,
            "column": 10
          },
          "goals": "case re\nz : \ud835\udcde\n\u22a2 (\u2191z.norm).re = (z * star z).re",
          "endPos": {
            "line": 780,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "Hurwitz.intCast_im_o",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.instIntCast",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [norm, \u2190 Int.cast_add]",
          "proofState": 454,
          "pos": {
            "line": 780,
            "column": 10
          },
          "goals": "case im_o\nz : \ud835\udcde\n\u22a2 (\u2191z.norm).im_o = (z * star z).im_o",
          "endPos": {
            "line": 780,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "Hurwitz.intCast_im_i",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.instIntCast",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [norm, \u2190 Int.cast_add]",
          "proofState": 455,
          "pos": {
            "line": 780,
            "column": 10
          },
          "goals": "case im_i\nz : \ud835\udcde\n\u22a2 (\u2191z.norm).im_i = (z * star z).im_i",
          "endPos": {
            "line": 780,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Int.cast",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "Hurwitz.intCast_im_oi",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Hurwitz.im_o",
            "Int",
            "SubtractionMonoid.toSubNegMonoid",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "Hurwitz",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "congr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Int.instSub",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Hurwitz.instIntCast",
            "Neg.neg",
            "sub_neg_eq_add",
            "Eq.trans",
            "mul_neg",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [norm, \u2190 Int.cast_add]",
          "proofState": 456,
          "pos": {
            "line": 780,
            "column": 10
          },
          "goals": "case im_oi\nz : \ud835\udcde\n\u22a2 (\u2191z.norm).im_oi = (z * star z).im_oi",
          "endPos": {
            "line": 780,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 457,
          "pos": {
            "line": 780,
            "column": 42
          },
          "goals": "case re\nz : \ud835\udcde\n\u22a2 z.re * z.re + z.im_o * z.im_o + z.im_i * z.im_i + z.im_oi * z.im_oi - z.re * (z.im_o + z.im_oi) +\n      z.im_i * (z.im_o - z.im_oi) =\n    z.re * (z.re - z.im_o - z.im_oi) + z.im_o * z.im_o + z.im_i * z.im_o + z.im_i * z.im_i + -(z.im_i * z.im_oi) +\n      z.im_oi * z.im_oi",
          "endPos": {
            "line": 780,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.cast_zero",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 458,
          "pos": {
            "line": 780,
            "column": 42
          },
          "goals": "case im_o\nz : \ud835\udcde\n\u22a2 0 =\n    z.im_o * (z.re - z.im_o - z.im_oi) + -(z.re * z.im_o) + z.im_o * z.im_o + z.im_oi * z.im_o + z.im_oi * z.im_i +\n      -(z.im_i * z.im_oi)",
          "endPos": {
            "line": 780,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.cast_zero",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 459,
          "pos": {
            "line": 780,
            "column": 42
          },
          "goals": "case im_i\nz : \ud835\udcde\n\u22a2 0 =\n    z.im_i * (z.re - z.im_o - z.im_oi) + z.im_i * z.im_o + -(z.im_oi * z.im_o) + -(z.re * z.im_i) + z.im_o * z.im_oi +\n      z.im_i * z.im_oi",
          "endPos": {
            "line": 780,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_congr",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "AddMonoid.toAddZeroClass",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.cast_zero",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Hurwitz.im_o",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMul",
            "NonUnitalNonAssocRing.toHasDistribNeg",
            "Int.instNormedCommRing",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "HasDistribNeg.toInvolutiveNeg",
            "SubNegMonoid.toAddMonoid",
            "Mathlib.Tactic.Ring.atom_pf",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "InvolutiveNeg.toNeg",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 460,
          "pos": {
            "line": 780,
            "column": 42
          },
          "goals": "case im_oi\nz : \ud835\udcde\n\u22a2 0 =\n    z.im_oi * (z.re - z.im_o - z.im_oi) + z.im_i * z.im_o + -(z.im_o * z.im_i) + -(z.re * z.im_oi) + z.im_o * z.im_oi +\n      z.im_oi * z.im_oi",
          "endPos": {
            "line": 780,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real",
            "Hurwitz.norm.eq_1",
            "HMul.hMul",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "HSub.hSub",
            "Monoid.toNatPow",
            "id",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "Int.instMul",
            "Real.instAdd",
            "Real.instMonoid",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "Real.instMul",
            "Hurwitz.norm",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Hurwitz.im_i",
            "Int.instSub",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "rw [norm]",
          "proofState": 461,
          "pos": {
            "line": 788,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 \u2191z.norm =\n    (\u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) ^ 2 + (\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) ^ 2 +\n        (2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi) ^ 2 +\n      (2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) ^ 2",
          "endPos": {
            "line": 788,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Real.instInv",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Int.cast_sub",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Field.toDivisionRing",
            "Monoid.toNatPow",
            "Int.cast_add",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "div_mul_eq_mul_div",
            "Int",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "AddGroupWithOne.toIntCast",
            "inv_eq_one_div",
            "Nat.instAddMonoidWithOne",
            "DivisionMonoid.toDivInvMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Field.toCommRing",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Int.instMul",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "Real.instMonoid",
            "mul_div_cancel_right\u2080",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.12",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "Int.cast_mul",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "div_pow",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Bool",
            "Int.instAdd",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Int.instSub",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "sub_div'",
            "Mathlib.Meta.NormNum.isNat_pow",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp",
          "proofState": 462,
          "pos": {
            "line": 789,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 \u2191(z.re * z.re + z.im_o * z.im_o + z.im_i * z.im_i + z.im_oi * z.im_oi - z.re * (z.im_o + z.im_oi) +\n        z.im_i * (z.im_o - z.im_oi)) =\n    (\u2191z.re - 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) ^ 2 + (\u2191z.im_i + 2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) ^ 2 +\n        (2\u207b\u00b9 * \u2191z.im_o + 2\u207b\u00b9 * \u2191z.im_oi) ^ 2 +\n      (2\u207b\u00b9 * \u2191z.im_o - 2\u207b\u00b9 * \u2191z.im_oi) ^ 2",
          "endPos": {
            "line": 789,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Data.Nat.Cast.Basic._auxLemma.2",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Nat.instMonoid",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "Monoid.toNatPow",
            "Real.semiring",
            "id",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Field.toCommRing",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "Semifield.toCommGroupWithZero",
            "Real.field",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Hurwitz.re",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast",
          "proofState": 463,
          "pos": {
            "line": 790,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 (\u2191z.re * \u2191z.re + \u2191z.im_o * \u2191z.im_o + \u2191z.im_i * \u2191z.im_i + \u2191z.im_oi * \u2191z.im_oi - \u2191z.re * (\u2191z.im_o + \u2191z.im_oi) +\n        \u2191z.im_i * (\u2191z.im_o - \u2191z.im_oi)) *\n      2 ^ 2 =\n    (\u2191z.re * 2 - \u2191z.im_o - \u2191z.im_oi) ^ 2 + (\u2191z.im_i * 2 + \u2191z.im_o - \u2191z.im_oi) ^ 2 + (\u2191z.im_o + \u2191z.im_oi) ^ 2 +\n      (\u2191z.im_o - \u2191z.im_oi) ^ 2",
          "endPos": {
            "line": 790,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Mathlib.Tactic.Ring.mul_pp_pf_overlap",
            "Mathlib.Tactic.Ring.pow_one",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_add",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "HMul.hMul",
            "Mathlib.Tactic.Ring.coeff_one",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.mul_zero",
            "Mathlib.Tactic.Ring.mul_pf_left",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Nat.instMonoid",
            "Mathlib.Tactic.Ring.neg_zero",
            "Mathlib.Tactic.Ring.mul_pf_right",
            "Int.rawCast",
            "Mathlib.Tactic.Ring.one_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Tactic.Ring.zero_mul",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "Mathlib.Tactic.Ring.add_pf_add_overlap",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "Nat.instAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_natCast",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Tactic.Ring.mul_congr",
            "Int.instMonoid",
            "Int.instMul",
            "Mathlib.Tactic.Ring.pow_one_cast",
            "Mathlib.Tactic.Ring.add_mul",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "instNatAtLeastTwo",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Mathlib.Tactic.Ring.pow_add",
            "Mathlib.Tactic.Ring.add_overlap_pf",
            "Int.instRing",
            "Nat",
            "Mathlib.Tactic.Ring.pow_bit0",
            "Mathlib.Tactic.Ring.mul_one",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "Hurwitz.im_oi",
            "Mathlib.Meta.NormNum.isNat_mul",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Int.instSub",
            "Mathlib.Tactic.Ring.pow_nat",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instNatCastInt",
            "instHPow",
            "Mathlib.Tactic.Ring.cast_pos",
            "Mathlib.Tactic.Ring.atom_pf",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Meta.NormNum.isNat_pow",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "MonoidWithZero.toMonoid",
            "Mathlib.Tactic.Ring.mul_add",
            "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Mathlib.Tactic.Ring.pow_congr",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Hurwitz.re",
            "Mathlib.Tactic.Ring.pow_zero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 464,
          "pos": {
            "line": 791,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 (z.re * z.re + z.im_o * z.im_o + z.im_i * z.im_i + z.im_oi * z.im_oi - z.re * (z.im_o + z.im_oi) +\n        z.im_i * (z.im_o - z.im_oi)) *\n      \u2191(2 ^ 2) =\n    (z.re * 2 - z.im_o - z.im_oi) ^ 2 + (z.im_i * 2 + z.im_o - z.im_oi) ^ 2 + (z.im_o + z.im_oi) ^ 2 +\n      (z.im_o - z.im_oi) ^ 2",
          "endPos": {
            "line": 791,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "sub_self",
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "Int.instAddMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "MulZeroClass.mul_zero",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "HAdd.hAdd",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [norm]",
          "proofState": 465,
          "pos": {
            "line": 793,
            "column": 35
          },
          "goals": "\u22a2 norm 0 = 0",
          "endPos": {
            "line": 793,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "sub_self",
            "MulOneClass.toMul",
            "congrArg",
            "sub_zero",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "Int.instAddMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroClass.mul_zero",
            "MulZeroOneClass.toMulOneClass",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "Int.instNormedCommRing",
            "instHAdd",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "HAdd.hAdd",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "MulOneClass.toOne",
            "eq_self",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "mul_one",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "simp [norm]",
          "proofState": 466,
          "pos": {
            "line": 795,
            "column": 34
          },
          "goals": "\u22a2 norm 1 = 1",
          "endPos": {
            "line": 795,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Hurwitz.ring",
            "HMul.hMul",
            "Int.cast_inj",
            "congrArg",
            "Hurwitz.instMul",
            "id",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.instMul",
            "Hurwitz",
            "Hurwitz.norm",
            "propext",
            "Hurwitz.instCharZero",
            "Eq.symm",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "rw [\u2190 Int.cast_inj (\u03b1 := \ud835\udcde)]",
          "proofState": 467,
          "pos": {
            "line": 798,
            "column": 2
          },
          "goals": "x y : \ud835\udcde\n\u22a2 (x * y).norm = x.norm * y.norm",
          "endPos": {
            "line": 798,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Hurwitz.ring",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.instMul",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int",
            "AddGroupWithOne.toIntCast",
            "StarAddMonoid.toInvolutiveStar",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMul",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "StarRing.toStarAddMonoid",
            "Hurwitz",
            "Hurwitz.norm",
            "Hurwitz.norm_eq_mul_conj",
            "InvolutiveStar.toStar",
            "AddCommMonoid.toAddMonoid",
            "Eq",
            "Hurwitz.instIntCast",
            "Ring.toAddGroupWithOne",
            "Hurwitz.starRing",
            "instHMul",
            "Star.star"
          ],
          "tactic": "simp_rw [norm_eq_mul_conj, star_mul]",
          "proofState": 468,
          "pos": {
            "line": 799,
            "column": 2
          },
          "goals": "x y : \ud835\udcde\n\u22a2 \u2191(x * y).norm = \u2191(x.norm * y.norm)",
          "endPos": {
            "line": 799,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Semigroup.toMul",
            "Hurwitz.ring",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.instMul",
            "mul_assoc",
            "SemigroupWithZero.toSemigroup",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int",
            "AddGroupWithOne.toIntCast",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMul",
            "Hurwitz",
            "Hurwitz.norm",
            "StarMul.toInvolutiveStar",
            "Semiring.toNonUnitalSemiring",
            "InvolutiveStar.toStar",
            "StarRing.toStarMul",
            "Ring.toSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Hurwitz.starRing",
            "instHMul",
            "Star.star"
          ],
          "tactic": "rw [mul_assoc, \u2190 mul_assoc y, \u2190 norm_eq_mul_conj]",
          "proofState": 469,
          "pos": {
            "line": 800,
            "column": 2
          },
          "goals": "x y : \ud835\udcde\n\u22a2 x * y * (star y * star x) = \u2191(x.norm * y.norm)",
          "endPos": {
            "line": 800,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Semigroup.toMul",
            "Hurwitz.ring",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.instMul",
            "SemigroupWithZero.toSemigroup",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int",
            "AddGroupWithOne.toIntCast",
            "NonUnitalSemiring.toSemigroupWithZero",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Int.instMul",
            "NonAssocRing.toAddCommGroupWithOne",
            "Hurwitz",
            "Distrib.toMul",
            "Int.cast_comm",
            "Hurwitz.norm",
            "StarMul.toInvolutiveStar",
            "Semiring.toNonUnitalSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "InvolutiveStar.toStar",
            "StarRing.toStarMul",
            "Ring.toSemiring",
            "Eq",
            "Hurwitz.instIntCast",
            "Ring.toAddGroupWithOne",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Hurwitz.starRing",
            "instHMul",
            "Star.star"
          ],
          "tactic": "rw [Int.cast_comm, \u2190 mul_assoc, \u2190 norm_eq_mul_conj, Int.cast_mul]",
          "proofState": 470,
          "pos": {
            "line": 801,
            "column": 2
          },
          "goals": "x y : \ud835\udcde\n\u22a2 x * (\u2191y.norm * star x) = \u2191(x.norm * y.norm)",
          "endPos": {
            "line": 801,
            "column": 67
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "OrderedAddCommGroup.toAddLeftMono",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "Real.orderedSemiring",
            "congrArg",
            "NeZero.charZero_one",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Preorder.toLE",
            "OrderedSemiring.zeroLEOneClass",
            "id",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_nonneg",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toAddCommGroupWithOne",
            "instOfNat",
            "Real.orderedAddCommGroup",
            "Hurwitz.norm",
            "propext",
            "Zero.toOfNat0",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Eq.symm",
            "NegZeroClass.toZero",
            "Eq",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Int.instLEInt",
            "AddCommGroupWithOne.toAddCommGroup"
          ],
          "tactic": "rw [\u2190 Int.cast_nonneg (R := \u211d), coe_norm]",
          "proofState": 471,
          "pos": {
            "line": 804,
            "column": 2
          },
          "goals": "x : \ud835\udcde\n\u22a2 0 \u2264 x.norm",
          "endPos": {
            "line": 804,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Int.cast",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.partialOrder",
            "Real",
            "HMul.hMul",
            "OrderedAddCommGroup.toAddLeftMono",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "Real.instInv",
            "OrderedAddCommMonoid.toPartialOrder",
            "Real.instSub",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Real.instAdd",
            "StrictOrderedRing.toRing",
            "Real.instMonoid",
            "instHAdd",
            "even_two_mul",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Real.orderedAddCommGroup",
            "Nat",
            "Real.instMul",
            "AddGroup.existsAddOfLE",
            "Real.instIntCast",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Hurwitz.re",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "positivity",
          "proofState": 472,
          "pos": {
            "line": 805,
            "column": 2
          },
          "goals": "x : \ud835\udcde\n\u22a2 0 \u2264\n    (\u2191x.re - 2\u207b\u00b9 * \u2191x.im_o - 2\u207b\u00b9 * \u2191x.im_oi) ^ 2 + (\u2191x.im_i + 2\u207b\u00b9 * \u2191x.im_o - 2\u207b\u00b9 * \u2191x.im_oi) ^ 2 +\n        (2\u207b\u00b9 * \u2191x.im_o + 2\u207b\u00b9 * \u2191x.im_oi) ^ 2 +\n      (2\u207b\u00b9 * \u2191x.im_o - 2\u207b\u00b9 * \u2191x.im_oi) ^ 2",
          "endPos": {
            "line": 805,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Iff.intro"
          ],
          "tactic": "constructor",
          "proofState": 473,
          "pos": {
            "line": 808,
            "column": 2
          },
          "goals": "x : \ud835\udcde\n\u22a2 x.norm = 0 \u2194 x = 0",
          "endPos": {
            "line": 808,
            "column": 13
          }
        },
        {
          "usedConstants": [],
          "tactic": "swap",
          "proofState": 474,
          "pos": {
            "line": 809,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\n\u22a2 x.norm = 0 \u2192 x = 0\ncase mpr\nx : \ud835\udcde\n\u22a2 x = 0 \u2192 x.norm = 0",
          "endPos": {
            "line": 809,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Hurwitz.instZero",
            "Hurwitz",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rintro rfl",
          "proofState": 475,
          "pos": {
            "line": 810,
            "column": 4
          },
          "goals": "case mpr\nx : \ud835\udcde\n\u22a2 x = 0 \u2192 x.norm = 0",
          "endPos": {
            "line": 810,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Hurwitz.norm_zero"
          ],
          "tactic": "exact norm_zero",
          "proofState": 476,
          "pos": {
            "line": 810,
            "column": 16
          },
          "goals": "case mpr\n\u22a2 norm 0 = 0",
          "endPos": {
            "line": 810,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Int",
            "instOfNat",
            "Hurwitz.norm",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "intro h",
          "proofState": 477,
          "pos": {
            "line": 811,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\n\u22a2 x.norm = 0 \u2192 x = 0",
          "endPos": {
            "line": 811,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "Int.cast",
            "Real",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Eq.mp",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "instOfNat",
            "Hurwitz.norm",
            "propext",
            "Int.cast_eq_zero",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq.symm",
            "NegZeroClass.toZero",
            "Eq",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "rw [\u2190 Int.cast_eq_zero (\u03b1 := \u211d), coe_norm] at h",
          "proofState": 478,
          "pos": {
            "line": 812,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh : x.norm = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 812,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "GroupWithZero.toMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "Real",
            "DivInvMonoid.toInv",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "MulZeroClass.toMul",
            "Monoid.toMulOneClass",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "MulOneClass.toMul",
            "congrArg",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "Real.instDivInvMonoid",
            "Real.instSub",
            "MulZeroClass.zero_mul",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.11",
            "Field.toDivisionRing",
            "Monoid.toNatPow",
            "DivisionRing.toDivInvMonoid",
            "Real.semiring",
            "Eq.mp",
            "Distrib.toAdd",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "div_mul_eq_mul_div",
            "Real.instMonoidWithZero",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "inv_eq_one_div",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.instAddMonoidWithOne",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "add_div'",
            "MulZeroOneClass.toMulOneClass",
            "Real.instAdd",
            "SubNegMonoid.toSub",
            "Real.instMonoid",
            "mul_div_cancel_right\u2080",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Real.normedCommRing",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Real.instMul",
            "div_pow",
            "congr",
            "Semifield.toCommGroupWithZero",
            "MulOneClass.toOne",
            "Real.field",
            "Real.instIntCast",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "instHPow",
            "Nat.cast_zero",
            "MulZeroOneClass.toMulZeroClass",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Bool.false",
            "LinearOrderedField.toLinearOrderedSemifield",
            "NegZeroClass.toZero",
            "Mathlib.Meta.NormNum.isNat_eq_false",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "sub_div'",
            "Mathlib.Meta.NormNum.isNat_pow",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "Real.instNatCast",
            "EuclideanDomain.toMulDivCancelClass"
          ],
          "tactic": "field_simp at h",
          "proofState": 479,
          "pos": {
            "line": 813,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (\u2191x.re - 2\u207b\u00b9 * \u2191x.im_o - 2\u207b\u00b9 * \u2191x.im_oi) ^ 2 + (\u2191x.im_i + 2\u207b\u00b9 * \u2191x.im_o - 2\u207b\u00b9 * \u2191x.im_oi) ^ 2 +\n        (2\u207b\u00b9 * \u2191x.im_o + 2\u207b\u00b9 * \u2191x.im_oi) ^ 2 +\n      (2\u207b\u00b9 * \u2191x.im_o - 2\u207b\u00b9 * \u2191x.im_oi) ^ 2 =\n    0\n\u22a2 x = 0",
          "endPos": {
            "line": 813,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "AddMonoid.toAddSemigroup",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.1",
            "Int.cast_zero",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Mathlib.Algebra.Ring.Int.Defs._auxLemma.2",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.8",
            "Field.toDivisionRing",
            "Monoid.toNatPow",
            "Eq.mp",
            "Distrib.toAdd",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.cast_ofNat",
            "SubNegZeroMonoid.toNegZeroClass",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toCommRing",
            "Int.instMonoid",
            "Int.instMul",
            "SubNegMonoid.toSub",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHAdd",
            "AddSemigroup.toAdd",
            "instHSub",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "HPow.hPow",
            "instOfNat",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "Semifield.toCommGroupWithZero",
            "Real.field",
            "Real.instIntCast",
            "DivisionSemiring.toSemiring",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "CommGroupWithZero.toDivisionCommMonoid",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "Nat.cast_zero",
            "AddMonoidWithOne.toAddMonoid",
            "Mathlib.Data.Int.Cast.Basic._auxLemma.7",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "Eq.trans",
            "Hurwitz.re",
            "Mathlib.Data.Int.Cast.Lemmas._auxLemma.3",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_cast at h",
          "proofState": 480,
          "pos": {
            "line": 814,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (\u2191x.re * 2 - \u2191x.im_o - \u2191x.im_oi) ^ 2 + (\u2191x.im_i * 2 + \u2191x.im_o - \u2191x.im_oi) ^ 2 + (\u2191x.im_o + \u2191x.im_oi) ^ 2 +\n      (\u2191x.im_o - \u2191x.im_oi) ^ 2 =\n    0\n\u22a2 x = 0",
          "endPos": {
            "line": 814,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "eq_zero_of_add_nonpos_right",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Hurwitz.instZero",
            "covariant_swap_add_of_covariant_add",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "Eq.le",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMonoid",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "instHSub",
            "Hurwitz",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "AddZeroClass.toZero",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Int.instAddLeftMono",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "letFun",
            "Int.instAddCommSemigroup",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "have h4 := eq_zero_of_add_nonpos_right (by positivity) (by positivity) h.le",
          "proofState": 481,
          "pos": {
            "line": 815,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\n\u22a2 x = 0",
          "endPos": {
            "line": 815,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMonoid",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Int.instAddLeftMono",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 482,
          "pos": {
            "line": 815,
            "column": 45
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\n\u22a2 0 \u2264 (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2",
          "endPos": {
            "line": 815,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "Int.instSub",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 483,
          "pos": {
            "line": 815,
            "column": 61
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\n\u22a2 0 \u2264 (x.im_o - x.im_oi) ^ 2",
          "endPos": {
            "line": 815,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "StrictOrderedSemiring.toOrderedSemiring",
            "LinearOrderedSemiring.noZeroDivisors",
            "congrArg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "Eq.mp",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "instHSub",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Nat",
            "AddGroup.existsAddOfLE",
            "propext",
            "Hurwitz.im_oi",
            "Int.instAddGroup",
            "Zero.toOfNat0",
            "Int.instSub",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Eq",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "sq_eq_zero_iff"
          ],
          "tactic": "rw [sq_eq_zero_iff, sub_eq_zero] at h4",
          "proofState": 484,
          "pos": {
            "line": 816,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : (x.im_o - x.im_oi) ^ 2 = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 816,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "Eq.le",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMonoid",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "instHSub",
            "Hurwitz",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Int.instRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "AddZeroClass.toZero",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Int.instAddLeftMono",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "eq_zero_of_add_nonpos_left",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "letFun",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "have h1 := eq_zero_of_add_nonpos_left (by positivity) (by positivity) h.le",
          "proofState": 485,
          "pos": {
            "line": 817,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\n\u22a2 x = 0",
          "endPos": {
            "line": 817,
            "column": 76
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMonoid",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Int.instAddLeftMono",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 486,
          "pos": {
            "line": 817,
            "column": 44
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\n\u22a2 0 \u2264 (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2",
          "endPos": {
            "line": 817,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Hurwitz.im_oi",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "Int.instSub",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 487,
          "pos": {
            "line": 817,
            "column": 60
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\n\u22a2 0 \u2264 (x.im_o - x.im_oi) ^ 2",
          "endPos": {
            "line": 817,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "eq_zero_of_add_nonpos_right",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Hurwitz.instZero",
            "covariant_swap_add_of_covariant_add",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "Eq.le",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMonoid",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "instHSub",
            "Hurwitz",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "AddZeroClass.toZero",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Int.instAddLeftMono",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "letFun",
            "Int.instAddCommSemigroup",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "have h3 := eq_zero_of_add_nonpos_right (by positivity) (by positivity) h1.le",
          "proofState": 488,
          "pos": {
            "line": 818,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\nh1 : (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 818,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMonoid",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Int.instAddLeftMono",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 489,
          "pos": {
            "line": 818,
            "column": 45
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\nh1 : (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 = 0\n\u22a2 0 \u2264 (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2",
          "endPos": {
            "line": 818,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 490,
          "pos": {
            "line": 818,
            "column": 61
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\nh1 : (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 = 0\n\u22a2 0 \u2264 (x.im_o + x.im_oi) ^ 2",
          "endPos": {
            "line": 818,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "congrArg",
            "AddMonoid.toAddZeroClass",
            "Monoid.toNatPow",
            "Eq.mp",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "Int.instMonoid",
            "instHAdd",
            "HPow.hPow",
            "HAdd.hAdd",
            "Nat",
            "AddZeroClass.toZero",
            "Hurwitz.im_oi",
            "Int.instAdd",
            "Zero.toOfNat0",
            "instHPow",
            "OfNat.ofNat",
            "Eq"
          ],
          "tactic": "rw [h4] at h3",
          "proofState": 491,
          "pos": {
            "line": 819,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\nh1 : (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 = 0\nh3 : (x.im_o + x.im_oi) ^ 2 = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 819,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "StrictOrderedSemiring.toOrderedSemiring",
            "False",
            "LinearOrderedSemiring.noZeroDivisors",
            "congrArg",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Nat.instCharZero",
            "Monoid.toNatPow",
            "Eq.mp",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Nat.instAddMonoidWithOne",
            "instHAdd",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "AddZeroClass.toZero",
            "True",
            "Hurwitz.im_oi",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "_auxLemma.31",
            "Zero.toOfNat0",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "Int.instCharZero",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOfNatAtLeastTwo",
            "Not",
            "_auxLemma.32",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "_auxLemma.24",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, pow_eq_zero_iff, add_self_eq_zero] at h3",
          "proofState": 492,
          "pos": {
            "line": 820,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\nh1 : (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 = 0\nh3 : (x.im_oi + x.im_oi) ^ 2 = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 820,
            "column": 100
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [h3] at h4",
          "proofState": 493,
          "pos": {
            "line": 821,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = x.im_oi\nh1 : (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 = 0\nh3 : x.im_oi = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 821,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "False",
            "HMul.hMul",
            "congrArg",
            "sub_zero",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Nat.instCharZero",
            "Monoid.toNatPow",
            "Eq.mp",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Hurwitz.im_o",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "Nat.instAddMonoidWithOne",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Int.instMonoid",
            "Int.instMul",
            "instHAdd",
            "instHSub",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "AddZeroClass.toZero",
            "True",
            "Hurwitz.im_oi",
            "of_eq_true",
            "Int.instAdd",
            "Hurwitz.im_i",
            "Zero.toOfNat0",
            "Int.instSub",
            "instNatCastInt",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "AddCommGroup.toDivisionAddCommMonoid",
            "add_zero",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOfNatAtLeastTwo",
            "Not",
            "zero_pow",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "_auxLemma.24",
            "Hurwitz.re",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp only [h4, sub_zero, h3, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow] at h1",
          "proofState": 494,
          "pos": {
            "line": 822,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh1 : (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 = 0\nh3 : x.im_oi = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 823,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "eq_zero_of_add_nonpos_right",
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Hurwitz.instZero",
            "covariant_swap_add_of_covariant_add",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "Eq.le",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMonoid",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "instHAdd",
            "even_two_mul",
            "Hurwitz",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "AddZeroClass.toZero",
            "Int.instAdd",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "instNatCastInt",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Int.instAddLeftMono",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "letFun",
            "Int.instAddCommSemigroup",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "have h2 := eq_zero_of_add_nonpos_right (by positivity) (by positivity) h1.le",
          "proofState": 495,
          "pos": {
            "line": 824,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh1 : (x.re * 2) ^ 2 + (x.im_i * 2) ^ 2 = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 824,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "even_two_mul",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Nat.instSemiring",
            "instNatCastInt",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Hurwitz.re",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 496,
          "pos": {
            "line": 824,
            "column": 45
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh1 : (x.re * 2) ^ 2 + (x.im_i * 2) ^ 2 = 0\n\u22a2 0 \u2264 (x.re * 2) ^ 2",
          "endPos": {
            "line": 824,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "StrictOrderedSemiring.toOrderedSemiring",
            "HMul.hMul",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "Int.instMul",
            "StrictOrderedRing.toRing",
            "even_two_mul",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "AddGroup.existsAddOfLE",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Hurwitz.im_i",
            "Nat.instSemiring",
            "instNatCastInt",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 497,
          "pos": {
            "line": 824,
            "column": 61
          },
          "goals": "x : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh1 : (x.re * 2) ^ 2 + (x.im_i * 2) ^ 2 = 0\n\u22a2 0 \u2264 (x.im_i * 2) ^ 2",
          "endPos": {
            "line": 824,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "False",
            "LinearOrderedSemiring.noZeroDivisors",
            "_auxLemma.33",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "congrArg",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Nat.instCharZero",
            "Monoid.toNatPow",
            "Eq.mp",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Nat.instAddMonoidWithOne",
            "Int.instMul",
            "Int.instNormedCommRing",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Int.instRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "AddZeroClass.toZero",
            "True",
            "of_eq_true",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Hurwitz.im_i",
            "_auxLemma.31",
            "Zero.toOfNat0",
            "or_false",
            "Or",
            "instNatCastInt",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Int.instCharZero",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "_auxLemma.24",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp only [ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, pow_eq_zero_iff, mul_eq_zero, or_false] at h2",
          "proofState": 498,
          "pos": {
            "line": 825,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh1 : (x.re * 2) ^ 2 + (x.im_i * 2) ^ 2 = 0\nh2 : (x.im_i * 2) ^ 2 = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 826,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "StrictOrderedSemiring.toOrderedSemiring",
            "False",
            "LinearOrderedSemiring.noZeroDivisors",
            "_auxLemma.33",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "MulZeroClass.toMul",
            "congrArg",
            "OrderedAddCommMonoid.toPartialOrder",
            "MulZeroClass.zero_mul",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Nat.instCharZero",
            "Monoid.toNatPow",
            "Eq.mp",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "Nat.instAddMonoidWithOne",
            "Int.instMonoid",
            "Int.instMul",
            "Int.instNormedCommRing",
            "instHAdd",
            "instNatAtLeastTwo",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "HAdd.hAdd",
            "Int.instRing",
            "Nat",
            "AddGroup.existsAddOfLE",
            "AddZeroClass.toZero",
            "True",
            "of_eq_true",
            "Int.instAdd",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Hurwitz.im_i",
            "_auxLemma.31",
            "Zero.toOfNat0",
            "or_false",
            "Or",
            "instNatCastInt",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "add_zero",
            "Int.instCharZero",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Not",
            "zero_pow",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "_auxLemma.24",
            "Hurwitz.re",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp only [h2, zero_mul, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, zero_pow, add_zero, pow_eq_zero_iff,\n  mul_eq_zero, or_false] at h1",
          "proofState": 499,
          "pos": {
            "line": 827,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh1 : (x.re * 2) ^ 2 + (x.im_i * 2) ^ 2 = 0\nh2 : x.im_i = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 828,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ext"
          ],
          "tactic": "ext",
          "proofState": 500,
          "pos": {
            "line": 829,
            "column": 2
          },
          "goals": "case mp\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh2 : x.im_i = 0\nh1 : x.re = 0\n\u22a2 x = 0",
          "endPos": {
            "line": 829,
            "column": 5
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption",
          "proofState": 501,
          "pos": {
            "line": 829,
            "column": 10
          },
          "goals": "case mp.re\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh2 : x.im_i = 0\nh1 : x.re = 0\n\u22a2 x.re = re 0",
          "endPos": {
            "line": 829,
            "column": 20
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption",
          "proofState": 502,
          "pos": {
            "line": 829,
            "column": 10
          },
          "goals": "case mp.im_o\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh2 : x.im_i = 0\nh1 : x.re = 0\n\u22a2 x.im_o = im_o 0",
          "endPos": {
            "line": 829,
            "column": 20
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption",
          "proofState": 503,
          "pos": {
            "line": 829,
            "column": 10
          },
          "goals": "case mp.im_i\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh2 : x.im_i = 0\nh1 : x.re = 0\n\u22a2 x.im_i = im_i 0",
          "endPos": {
            "line": 829,
            "column": 20
          }
        },
        {
          "usedConstants": [],
          "tactic": "assumption",
          "proofState": 504,
          "pos": {
            "line": 829,
            "column": 10
          },
          "goals": "case mp.im_oi\nx : \ud835\udcde\nh :\n  (x.re * 2 - x.im_o - x.im_oi) ^ 2 + (x.im_i * 2 + x.im_o - x.im_oi) ^ 2 + (x.im_o + x.im_oi) ^ 2 +\n      (x.im_o - x.im_oi) ^ 2 =\n    0\nh4 : x.im_o = 0\nh3 : x.im_oi = 0\nh2 : x.im_i = 0\nh1 : x.re = 0\n\u22a2 x.im_oi = im_oi 0",
          "endPos": {
            "line": 829,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "Quaternion.coe_injective"
          ],
          "tactic": "apply coe_injective",
          "proofState": 505,
          "pos": {
            "line": 833,
            "column": 2
          },
          "goals": "z : \ud835\udcde\n\u22a2 normSq z.toQuaternion = \u2191z.norm",
          "endPos": {
            "line": 833,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Quaternion.coe",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Quaternion.normSq",
            "MonoidWithZeroHom.funLike",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "CommRing.toCommSemiring",
            "MonoidWithZeroHom",
            "Quaternion.instStar",
            "Distrib.toMul",
            "Quaternion.self_mul_star",
            "Ring.toAddCommGroup",
            "Hurwitz.norm",
            "Real.instIntCast",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Quaternion.instRing",
            "MulZeroClass.toZero",
            "Quaternion",
            "instHMul",
            "Star.star"
          ],
          "tactic": "rw [\u2190 self_mul_star, \u2190 toQuaternion_star, \u2190 toQuaternion_mul, \u2190 norm_eq_mul_conj, toQuaternion_intCast, coe_intCast]",
          "proofState": 506,
          "pos": {
            "line": 834,
            "column": 2
          },
          "goals": "case a\nz : \ud835\udcde\n\u22a2 \u2191(normSq z.toQuaternion) = \u2191\u2191z.norm",
          "endPos": {
            "line": 835,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Hurwitz.leftInvOn_toQuaternion_fromQuaternion"
          ],
          "tactic": "apply leftInvOn_toQuaternion_fromQuaternion",
          "proofState": 507,
          "pos": {
            "line": 838,
            "column": 2
          },
          "goals": "x y z w : \u2124\n\u22a2 (fromQuaternion { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w }).toQuaternion =\n    { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w }",
          "endPos": {
            "line": 838,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real",
            "_auxLemma.25",
            "Real.instZero",
            "Real.instInv",
            "setOf",
            "QuaternionAlgebra.mk",
            "Membership.mem",
            "Exists",
            "id",
            "instOfNatNat",
            "Int",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "Real.instNeg",
            "Real.instIntCast",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Or",
            "OfNat.ofNat",
            "Eq",
            "Set.instMembership",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Quaternion",
            "Real.instNatCast",
            "Set"
          ],
          "tactic": "simp only [Set.mem_setOf]",
          "proofState": 508,
          "pos": {
            "line": 839,
            "column": 2
          },
          "goals": "case a\nx y z w : \u2124\n\u22a2 { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w } \u2208\n    {q |\n      \u2203 a b c d,\n        q = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n          q = { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }}",
          "endPos": {
            "line": 839,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use x, y, z, w",
          "proofState": 509,
          "pos": {
            "line": 840,
            "column": 2
          },
          "goals": "case a\nx y z w : \u2124\n\u22a2 \u2203 a b c d,\n    { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w } = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w } =\n        { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 840,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "true_or",
            "QuaternionAlgebra.mk",
            "instOfNatNat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "True",
            "Real.instNeg",
            "eq_self",
            "Real.instIntCast",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Or",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "Quaternion",
            "Real.instNatCast"
          ],
          "tactic": "simp",
          "proofState": 510,
          "pos": {
            "line": 841,
            "column": 2
          },
          "goals": "case h\nx y z w : \u2124\n\u22a2 { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w } = { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w } \u2228\n    { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w } =\n      { re := \u2191x + 2\u207b\u00b9, imI := \u2191y + 2\u207b\u00b9, imJ := \u2191z + 2\u207b\u00b9, imK := \u2191w + 2\u207b\u00b9 }",
          "endPos": {
            "line": 841,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "lt_of_le_of_ne"
          ],
          "tactic": "apply lt_of_le_of_ne",
          "proofState": 511,
          "pos": {
            "line": 846,
            "column": 2
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : \u00ac(a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9)\n\u22a2 a + b + c + d < 1",
          "endPos": {
            "line": 846,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real.instLE",
            "Real",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "Trans.trans",
            "Mathlib.Meta.NormNum.isNat_eq_true",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "OrderedAddCommGroup.toAddLeftMono",
            "Real.instRCLike",
            "Real.instInv",
            "covariant_swap_add_of_covariant_add",
            "add_le_add",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "LE.le",
            "Real.instAddCommSemigroup",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "Real.orderedAddCommGroup",
            "Nat",
            "Real.instDivisionRing",
            "One.toOfNat1",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "instTransEq_1",
            "OfNat.ofNat",
            "Eq",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instPreorder",
            "Real.instNatCast"
          ],
          "tactic": "calc\n  _ \u2264 (4 : \u211d)\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 := by gcongr\n  _ = 1 := by norm_num",
          "proofState": 512,
          "pos": {
            "line": 847,
            "column": 4
          },
          "goals": "case a\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : \u00ac(a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9)\n\u22a2 a + b + c + d \u2264 1",
          "endPos": {
            "line": 849,
            "column": 26
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  _ \u2264 (4 : \u211d)\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 := by gcongr\n  _ = 1 := by norm_num",
          "proofState": 513,
          "pos": {
            "line": 848,
            "column": 6
          },
          "goals": "no goals",
          "endPos": {
            "line": 849,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "add_le_add"
          ],
          "tactic": "gcongr",
          "proofState": 514,
          "pos": {
            "line": 848,
            "column": 44
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : \u00ac(a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9)\n\u22a2 a + b + c + d \u2264 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9",
          "endPos": {
            "line": 848,
            "column": 50
          }
        },
        {
          "usedConstants": [
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "Mathlib.Meta.NormNum.instAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_eq_true",
            "Mathlib.Meta.NormNum.IsRat.to_isInt",
            "Real.instRCLike",
            "Real.instInv",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "Nat",
            "Real.instDivisionRing",
            "One.toOfNat1",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "OfNat.ofNat",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "norm_num",
          "proofState": 515,
          "pos": {
            "line": 849,
            "column": 18
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : \u00ac(a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9)\n\u22a2 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 = 1",
          "endPos": {
            "line": 849,
            "column": 26
          }
        },
        {
          "usedConstants": [],
          "tactic": "contrapose! H",
          "proofState": 516,
          "pos": {
            "line": 850,
            "column": 2
          },
          "goals": "case a\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : \u00ac(a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9)\n\u22a2 a + b + c + d \u2260 1",
          "endPos": {
            "line": 850,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instInv",
            "Real.instSub",
            "HSub.hSub",
            "instOfNatNat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "And",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Real.instNatCast"
          ],
          "tactic": "have invs : (1 : \u211d) - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9 := by norm_num",
          "proofState": 517,
          "pos": {
            "line": 851,
            "column": 2
          },
          "goals": "case a\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\n\u22a2 a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9",
          "endPos": {
            "line": 851,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "Real.instRCLike",
            "Real.instInv",
            "Real.instSub",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.isRat_eq_true",
            "Nat",
            "Real.instDivisionRing",
            "One.toOfNat1",
            "Eq.refl",
            "Mathlib.Meta.NormNum.isRat_add",
            "OfNat.ofNat",
            "Mathlib.Meta.NormNum.isRat_sub",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "norm_num",
          "proofState": 518,
          "pos": {
            "line": 851,
            "column": 52
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\n\u22a2 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9",
          "endPos": {
            "line": 851,
            "column": 60
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instInv",
            "instOfNatNat",
            "And",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "And.intro",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "refine \u27e8?_, ?_, ?_, ?_\u27e9 <;> apply le_antisymm \u2039_\u203a <;> [(have : a = 1 - (b + c + d) := by rw [\u2190 H]; ring);\n  (have : b = 1 - (a + c + d) := by rw [\u2190 H]; ring); (have : c = 1 - (a + b + d) := by rw [\u2190 H]; ring);\n  (have : d = 1 - (a + b + c) := by rw [\u2190 H]; ring)]",
          "proofState": 519,
          "pos": {
            "line": 852,
            "column": 2
          },
          "goals": "case a\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9",
          "endPos": {
            "line": 856,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instInv",
            "instOfNatNat",
            "And",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "And.intro",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "refine \u27e8?_, ?_, ?_, ?_\u27e9",
          "proofState": 520,
          "pos": {
            "line": 852,
            "column": 2
          },
          "goals": "case a\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 a = 4\u207b\u00b9 \u2227 b = 4\u207b\u00b9 \u2227 c = 4\u207b\u00b9 \u2227 d = 4\u207b\u00b9",
          "endPos": {
            "line": 852,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instInv",
            "instOfNatNat",
            "le_antisymm",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "OfNat.ofNat",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "apply le_antisymm \u2039_\u203a",
          "proofState": 521,
          "pos": {
            "line": 852,
            "column": 30
          },
          "goals": "case a.refine_1\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 a = 4\u207b\u00b9",
          "endPos": {
            "line": 852,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instInv",
            "instOfNatNat",
            "le_antisymm",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "OfNat.ofNat",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "apply le_antisymm \u2039_\u203a",
          "proofState": 522,
          "pos": {
            "line": 852,
            "column": 30
          },
          "goals": "case a.refine_2\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 b = 4\u207b\u00b9",
          "endPos": {
            "line": 852,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instInv",
            "instOfNatNat",
            "le_antisymm",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "OfNat.ofNat",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "apply le_antisymm \u2039_\u203a",
          "proofState": 523,
          "pos": {
            "line": 852,
            "column": 30
          },
          "goals": "case a.refine_3\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 c = 4\u207b\u00b9",
          "endPos": {
            "line": 852,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instInv",
            "instOfNatNat",
            "le_antisymm",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "OfNat.ofNat",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "apply le_antisymm \u2039_\u203a",
          "proofState": 524,
          "pos": {
            "line": 852,
            "column": 30
          },
          "goals": "case a.refine_4\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 d = 4\u207b\u00b9",
          "endPos": {
            "line": 852,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Real.partialOrder",
            "Real",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Real.instNatCast"
          ],
          "tactic": "have : a = 1 - (b + c + d) := by rw [\u2190 H]; ring",
          "proofState": 525,
          "pos": {
            "line": 853,
            "column": 5
          },
          "goals": "case a.refine_1\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 4\u207b\u00b9 \u2264 a",
          "endPos": {
            "line": 853,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "congrArg",
            "Real.instSub",
            "HSub.hSub",
            "id",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "HAdd.hAdd",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 H]",
          "proofState": 526,
          "pos": {
            "line": 853,
            "column": 38
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 a = 1 - (b + c + d)",
          "endPos": {
            "line": 853,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Int.rawCast",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Real.instRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "instHAdd",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 527,
          "pos": {
            "line": 853,
            "column": 48
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 a = a + b + c + d - (b + c + d)",
          "endPos": {
            "line": 853,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Real.partialOrder",
            "Real",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Real.instNatCast"
          ],
          "tactic": "have : b = 1 - (a + c + d) := by rw [\u2190 H]; ring",
          "proofState": 528,
          "pos": {
            "line": 854,
            "column": 5
          },
          "goals": "case a.refine_2\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 4\u207b\u00b9 \u2264 b",
          "endPos": {
            "line": 854,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "congrArg",
            "Real.instSub",
            "HSub.hSub",
            "id",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "HAdd.hAdd",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 H]",
          "proofState": 529,
          "pos": {
            "line": 854,
            "column": 38
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 b = 1 - (a + c + d)",
          "endPos": {
            "line": 854,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Int.rawCast",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Real.instRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 530,
          "pos": {
            "line": 854,
            "column": 48
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 b = a + b + c + d - (a + c + d)",
          "endPos": {
            "line": 854,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Real.partialOrder",
            "Real",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Real.instNatCast"
          ],
          "tactic": "have : c = 1 - (a + b + d) := by rw [\u2190 H]; ring",
          "proofState": 531,
          "pos": {
            "line": 855,
            "column": 5
          },
          "goals": "case a.refine_3\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 4\u207b\u00b9 \u2264 c",
          "endPos": {
            "line": 855,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "congrArg",
            "Real.instSub",
            "HSub.hSub",
            "id",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "HAdd.hAdd",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 H]",
          "proofState": 532,
          "pos": {
            "line": 855,
            "column": 38
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 c = 1 - (a + b + d)",
          "endPos": {
            "line": 855,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Int.rawCast",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Real.instRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 533,
          "pos": {
            "line": 855,
            "column": 48
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 c = a + b + c + d - (a + b + d)",
          "endPos": {
            "line": 855,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Real.partialOrder",
            "Real",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Real.instNatCast"
          ],
          "tactic": "have : d = 1 - (a + b + c) := by rw [\u2190 H]; ring",
          "proofState": 534,
          "pos": {
            "line": 856,
            "column": 5
          },
          "goals": "case a.refine_4\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 4\u207b\u00b9 \u2264 d",
          "endPos": {
            "line": 856,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "congrArg",
            "Real.instSub",
            "HSub.hSub",
            "id",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "HAdd.hAdd",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq.symm",
            "Eq"
          ],
          "tactic": "rw [\u2190 H]",
          "proofState": 535,
          "pos": {
            "line": 856,
            "column": 38
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 d = 1 - (a + b + c)",
          "endPos": {
            "line": 856,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "HMul.hMul",
            "Nat.rawCast",
            "Ring.toNonAssocRing",
            "Mathlib.Tactic.Ring.add_pf_add_gt",
            "CommSemiring.toSemiring",
            "Mathlib.Tactic.Ring.add_overlap_pf_zero",
            "Mathlib.Tactic.Ring.neg_zero",
            "Real.instSub",
            "Int.rawCast",
            "HSub.hSub",
            "Mathlib.Meta.NormNum.IsNat.of_raw",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Mathlib.Tactic.Ring.instCommSemiringNat",
            "Monoid.toNatPow",
            "Mathlib.Tactic.Ring.neg_mul",
            "Mathlib.Tactic.Ring.sub_pf",
            "Mathlib.Tactic.Ring.neg_add",
            "Distrib.toAdd",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int.ofNat",
            "Real.instRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Tactic.Ring.sub_congr",
            "Mathlib.Meta.NormNum.isInt_mul",
            "Mathlib.Tactic.Ring.of_eq",
            "Mathlib.Tactic.Ring.add_pf_zero_add",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instAdd",
            "instHAdd",
            "Mathlib.Tactic.Ring.add_pf_add_zero",
            "instHSub",
            "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
            "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Mathlib.Meta.NormNum.IsInt.to_isNat",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Mathlib.Tactic.Ring.add_pf_add_lt",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Mathlib.Meta.NormNum.isInt_add",
            "Eq.refl",
            "Mathlib.Meta.NormNum.IsInt.of_raw",
            "instHPow",
            "Mathlib.Tactic.Ring.atom_pf",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Mathlib.Tactic.Ring.neg_one_mul",
            "MonoidWithZero.toMonoid",
            "Int.negOfNat",
            "MulZeroClass.toZero",
            "Mathlib.Tactic.Ring.add_congr",
            "Real.instCommSemiring",
            "Mathlib.Meta.NormNum.IsNat.to_isInt",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "ring",
          "proofState": 536,
          "pos": {
            "line": 856,
            "column": 48
          },
          "goals": "a b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\n\u22a2 d = a + b + c + d - (a + b + c)",
          "endPos": {
            "line": 856,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "id",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "rw [this, le_sub_comm, invs]",
          "proofState": 537,
          "pos": {
            "line": 857,
            "column": 2
          },
          "goals": "case a.refine_1\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : a = 1 - (b + c + d)\n\u22a2 4\u207b\u00b9 \u2264 a",
          "endPos": {
            "line": 857,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "id",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "rw [this, le_sub_comm, invs]",
          "proofState": 538,
          "pos": {
            "line": 857,
            "column": 2
          },
          "goals": "case a.refine_2\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : b = 1 - (a + c + d)\n\u22a2 4\u207b\u00b9 \u2264 b",
          "endPos": {
            "line": 857,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "id",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "rw [this, le_sub_comm, invs]",
          "proofState": 539,
          "pos": {
            "line": 857,
            "column": 2
          },
          "goals": "case a.refine_3\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : c = 1 - (a + b + d)\n\u22a2 4\u207b\u00b9 \u2264 c",
          "endPos": {
            "line": 857,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Preorder.toLE",
            "id",
            "instOfNatNat",
            "LE.le",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "rw [this, le_sub_comm, invs]",
          "proofState": 540,
          "pos": {
            "line": 857,
            "column": 2
          },
          "goals": "case a.refine_4\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : d = 1 - (a + b + c)\n\u22a2 4\u207b\u00b9 \u2264 d",
          "endPos": {
            "line": 857,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "add_le_add"
          ],
          "tactic": "gcongr",
          "proofState": 541,
          "pos": {
            "line": 858,
            "column": 2
          },
          "goals": "case a.refine_1\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : a = 1 - (b + c + d)\n\u22a2 b + c + d \u2264 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9",
          "endPos": {
            "line": 858,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "add_le_add"
          ],
          "tactic": "gcongr",
          "proofState": 542,
          "pos": {
            "line": 858,
            "column": 2
          },
          "goals": "case a.refine_2\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : b = 1 - (a + c + d)\n\u22a2 a + c + d \u2264 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9",
          "endPos": {
            "line": 858,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "add_le_add"
          ],
          "tactic": "gcongr",
          "proofState": 543,
          "pos": {
            "line": 858,
            "column": 2
          },
          "goals": "case a.refine_3\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : c = 1 - (a + b + d)\n\u22a2 a + b + d \u2264 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9",
          "endPos": {
            "line": 858,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "add_le_add"
          ],
          "tactic": "gcongr",
          "proofState": 544,
          "pos": {
            "line": 858,
            "column": 2
          },
          "goals": "case a.refine_4\na b c d : \u211d\nha : a \u2264 4\u207b\u00b9\nhb : b \u2264 4\u207b\u00b9\nhc : c \u2264 4\u207b\u00b9\nhd : d \u2264 4\u207b\u00b9\nH : a + b + c + d = 1\ninvs : 1 - 4\u207b\u00b9 = 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9\nthis : d = 1 - (a + b + c)\n\u22a2 a + b + c \u2264 4\u207b\u00b9 + 4\u207b\u00b9 + 4\u207b\u00b9",
          "endPos": {
            "line": 858,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "Real.instInv",
            "NormedDivisionRing.toNormedRing",
            "Real.instLT",
            "Exists",
            "Monoid.toNatPow",
            "instOfNatNat",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "Real.instMonoid",
            "Hurwitz.toQuaternion",
            "Inv.inv",
            "Hurwitz",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Nat",
            "NormedRing.toSeminormedRing",
            "LT.lt",
            "Real.instNeg",
            "One.toOfNat1",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "instHPow",
            "SeminormedRing.toPseudoMetricSpace",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Quaternion",
            "Real.instNatCast"
          ],
          "tactic": "have four_inv : (4\u207b\u00b9 : \u211d) = 2\u207b\u00b9 ^ 2 := by norm_num",
          "proofState": 545,
          "pos": {
            "line": 862,
            "column": 2
          },
          "goals": "a : \u210d\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 862,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "Real.instRCLike",
            "Real.instInv",
            "Mathlib.Meta.NormNum.IsNatPowT.run",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.one_natPow",
            "Monoid.toNatPow",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "Mathlib.Meta.NormNum.IsNatPowT.bit0",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "Nat.instAddMonoidWithOne",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Real.instMonoid",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Mathlib.Meta.NormNum.intPow_ofNat",
            "HPow.hPow",
            "Mathlib.Meta.NormNum.isRat_eq_true",
            "Nat",
            "Real.instDivisionRing",
            "Eq.refl",
            "instHPow",
            "Mathlib.Meta.NormNum.isRat_pow",
            "OfNat.ofNat",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "norm_num",
          "proofState": 546,
          "pos": {
            "line": 862,
            "column": 44
          },
          "goals": "a : \u210d\n\u22a2 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2",
          "endPos": {
            "line": 862,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real.instLE",
            "Real",
            "Real.instZero",
            "Real.instInv",
            "Real.instSub",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "Real.instLT",
            "Exists",
            "Monoid.toNatPow",
            "Real.instFloorRing",
            "instOfNatNat",
            "LE.le",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "Real.instMonoid",
            "Hurwitz.toQuaternion",
            "instHSub",
            "Inv.inv",
            "Hurwitz",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Nat",
            "NormedRing.toSeminormedRing",
            "LT.lt",
            "round",
            "Real.instNeg",
            "Real.instIntCast",
            "One.toOfNat1",
            "Real.instLinearOrderedRing",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "instHPow",
            "SeminormedRing.toPseudoMetricSpace",
            "OfNat.ofNat",
            "instOfNatAtLeastTwo",
            "letFun",
            "Quaternion",
            "Real.instNatCast"
          ],
          "tactic": "have (r : \u211d) : (r - round r) ^ 2 \u2264 4\u207b\u00b9 := by\n  rw [four_inv, sq_le_sq]\n  apply (abs_sub_round _).trans_eq\n  rw [abs_of_nonneg]\n  all_goals norm_num",
          "proofState": 547,
          "pos": {
            "line": 863,
            "column": 2
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 867,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real.instLE",
            "Real",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "HSub.hSub",
            "Monoid.toNatPow",
            "id",
            "Real.instFloorRing",
            "instOfNatNat",
            "LE.le",
            "Real.instMonoid",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Nat",
            "round",
            "Real.instIntCast",
            "Real.instLinearOrderedRing",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "rw [four_inv, sq_le_sq]",
          "proofState": 548,
          "pos": {
            "line": 864,
            "column": 4
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nr : \u211d\n\u22a2 (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 864,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "abs_sub_round",
            "LinearOrderedField.toLinearOrderedCommRing",
            "Real",
            "instHDiv",
            "LE.le.trans_eq",
            "AddGroupWithOne.toAddGroup",
            "abs",
            "Real.instInv",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Preorder.toLE",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "DistribLattice.toLattice",
            "HDiv.hDiv",
            "Real.instFloorRing",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "AddGroupWithOne.toIntCast",
            "LinearOrderedRing.toStrictOrderedRing",
            "StrictOrderedRing.toRing",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "LinearOrderedField.toField",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "Nat",
            "round",
            "DivInvMonoid.toDiv",
            "One.toOfNat1",
            "Real.instLinearOrderedRing",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "OfNat.ofNat",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "OrderedAddCommGroup.toPartialOrder",
            "instDistribLatticeOfLinearOrder",
            "LinearOrderedRing.toLinearOrder",
            "Real.instNatCast"
          ],
          "tactic": "apply (abs_sub_round _).trans_eq",
          "proofState": 549,
          "pos": {
            "line": 865,
            "column": 4
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nr : \u211d\n\u22a2 |r - \u2191(round r)| \u2264 |2\u207b\u00b9|",
          "endPos": {
            "line": 865,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Eq.mpr",
            "LinearOrderedField.toLinearOrderedCommRing",
            "Real",
            "instHDiv",
            "abs",
            "congrArg",
            "Real.instInv",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Field.toDivisionRing",
            "DivisionRing.toDivInvMonoid",
            "id",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "instOfNatNat",
            "LinearOrderedRing.toStrictOrderedRing",
            "StrictOrderedRing.toRing",
            "AddMonoidWithOne.toOne",
            "LinearOrderedField.toField",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "DivInvMonoid.toDiv",
            "abs_of_nonneg",
            "One.toOfNat1",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "rw [abs_of_nonneg]",
          "proofState": 550,
          "pos": {
            "line": 866,
            "column": 4
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nr : \u211d\n\u22a2 1 / 2 = |2\u207b\u00b9|",
          "endPos": {
            "line": 866,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "LinearOrderedField.toLinearOrderedCommRing",
            "Real",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Real.instInv",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "DivisionMonoid.toDivInvOneMonoid",
            "Field.toDivisionRing",
            "DivisionRing.toDivisionSemiring",
            "DivisionRing.toDivInvMonoid",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "StrictOrderedRing.toRing",
            "AddMonoidWithOne.toOne",
            "Mathlib.Meta.NormNum.isRat_le_true",
            "Bool.true",
            "LinearOrderedField.toField",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "Mathlib.Meta.NormNum.isRat_eq_true",
            "Nat",
            "Real.instDivisionRing",
            "Mathlib.Meta.NormNum.isRat_div",
            "Int.mul",
            "DivInvMonoid.toDiv",
            "Bool",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Eq.refl",
            "InvOneClass.toInv",
            "Nat.cast_zero",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "all_goals norm_num",
          "proofState": 551,
          "pos": {
            "line": 867,
            "column": 4
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nr : \u211d\n\u22a2 1 / 2 = 2\u207b\u00b9\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nr : \u211d\n\u22a2 0 \u2264 2\u207b\u00b9",
          "endPos": {
            "line": 867,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "LinearOrderedField.toLinearOrderedCommRing",
            "Real",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "Real.instInv",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionSemiring.toGroupWithZero",
            "DivisionMonoid.toDivInvOneMonoid",
            "Field.toDivisionRing",
            "DivisionRing.toDivisionSemiring",
            "DivisionRing.toDivInvMonoid",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "instOfNatNat",
            "Int",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "LinearOrderedRing.toStrictOrderedRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "StrictOrderedRing.toRing",
            "AddMonoidWithOne.toOne",
            "LinearOrderedField.toField",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "Mathlib.Meta.NormNum.isRat_eq_true",
            "Nat",
            "Real.instDivisionRing",
            "Mathlib.Meta.NormNum.isRat_div",
            "Int.mul",
            "DivInvMonoid.toDiv",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "InvOneClass.toInv",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "OfNat.ofNat",
            "Nat.cast_one",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "instHMul",
            "Real.instNatCast"
          ],
          "tactic": "norm_num",
          "proofState": 552,
          "pos": {
            "line": 867,
            "column": 14
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nr : \u211d\n\u22a2 1 / 2 = 2\u207b\u00b9",
          "endPos": {
            "line": 867,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "LinearOrderedField.toLinearOrderedCommRing",
            "Real",
            "Real.instRCLike",
            "AddGroupWithOne.toAddGroup",
            "Real.instInv",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Field.toDivisionRing",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "LinearOrderedRing.toStrictOrderedRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "StrictOrderedRing.toRing",
            "Mathlib.Meta.NormNum.isRat_le_true",
            "Bool.true",
            "LinearOrderedField.toField",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "Real.instDivisionRing",
            "Bool",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "Eq.refl",
            "Nat.cast_zero",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "norm_num",
          "proofState": 553,
          "pos": {
            "line": 867,
            "column": 14
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nr : \u211d\n\u22a2 0 \u2264 2\u207b\u00b9",
          "endPos": {
            "line": 867,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "QuaternionAlgebra.re",
            "Real.instFloorRing",
            "Int",
            "Real.instOne",
            "round",
            "Real.instNeg",
            "One.toOfNat1",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Neg.neg"
          ],
          "tactic": "let x := round a.re",
          "proofState": 554,
          "pos": {
            "line": 868,
            "column": 2
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 868,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Real",
            "QuaternionAlgebra.imI",
            "Real.instZero",
            "Real.instFloorRing",
            "Int",
            "Real.instOne",
            "round",
            "Real.instNeg",
            "One.toOfNat1",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Neg.neg"
          ],
          "tactic": "let y := round a.imI",
          "proofState": 555,
          "pos": {
            "line": 869,
            "column": 2
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 869,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "Real.instFloorRing",
            "Int",
            "Real.instOne",
            "round",
            "Real.instNeg",
            "One.toOfNat1",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Neg.neg",
            "QuaternionAlgebra.imJ"
          ],
          "tactic": "let z := round a.imJ",
          "proofState": 556,
          "pos": {
            "line": 870,
            "column": 2
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 870,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "Real.instFloorRing",
            "Int",
            "Real.instOne",
            "round",
            "Real.instNeg",
            "One.toOfNat1",
            "Real.instLinearOrderedRing",
            "Zero.toOfNat0",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Neg.neg"
          ],
          "tactic": "let w := round a.imK",
          "proofState": 557,
          "pos": {
            "line": 871,
            "column": 2
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 871,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "QuaternionAlgebra.imI",
            "Real.lattice",
            "Real.instZero",
            "abs",
            "Real.instInv",
            "Real.instSub",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "Real.instLT",
            "Exists",
            "Real.instAddGroup",
            "instOfNatNat",
            "dite",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "Hurwitz.toQuaternion",
            "And",
            "instHSub",
            "Inv.inv",
            "Hurwitz",
            "instNatAtLeastTwo",
            "Nat",
            "NormedRing.toSeminormedRing",
            "LT.lt",
            "Real.instNeg",
            "Real.instIntCast",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "instDecidableAnd",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Real.decidableEq",
            "Eq",
            "instOfNatAtLeastTwo",
            "Not",
            "Neg.neg",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Real.instNatCast"
          ],
          "tactic": "by_cases H : |a.re - x| = 2\u207b\u00b9 \u2227 |a.imI - y| = 2\u207b\u00b9 \u2227 |a.imJ - z| = 2\u207b\u00b9 \u2227 |a.imK - w| = 2\u207b\u00b9",
          "proofState": 558,
          "pos": {
            "line": 872,
            "column": 2
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 872,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use fromQuaternion a",
          "proofState": 559,
          "pos": {
            "line": 873,
            "column": 4
          },
          "goals": "case pos\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 873,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "Preorder.toLT",
            "Real.instZero",
            "Real.instRCLike",
            "Real.orderedSemiring",
            "NeZero.charZero_one",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "Real.instLT",
            "OrderedSemiring.zeroLEOneClass",
            "Real.instRing",
            "zero_lt_one'",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "Hurwitz.toQuaternion",
            "NormedRing.toSeminormedRing",
            "LT.lt",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "OfNat.ofNat",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "Quaternion"
          ],
          "tactic": "convert zero_lt_one' \u211d",
          "proofState": 560,
          "pos": {
            "line": 874,
            "column": 4
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 dist a (fromQuaternion a).toQuaternion < 1",
          "endPos": {
            "line": 874,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Eq.mpr",
            "Ring.toSub",
            "Real",
            "NormedRing.toRing",
            "Real.instZero",
            "congrArg",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "id",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "Hurwitz.toQuaternion",
            "instHSub",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "Zero.toOfNat0",
            "MetricSpace.toPseudoMetricSpace",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "NormedRing.toMetricSpace",
            "NormedRing.dist_eq",
            "OfNat.ofNat",
            "Eq",
            "NormedRing.toNorm",
            "Quaternion"
          ],
          "tactic": "rw [NormedRing.dist_eq, \u2190 sq_eq_zero_iff, sq, \u2190 Quaternion.normSq_eq_norm_mul_self, normSq_def']",
          "proofState": 561,
          "pos": {
            "line": 875,
            "column": 4
          },
          "goals": "case h.e'_3\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 dist a (fromQuaternion a).toQuaternion = 0",
          "endPos": {
            "line": 875,
            "column": 100
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Ring.toSub",
            "add_eq_zero_iff_of_nonneg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "Real.instAddMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "id",
            "Distrib.toAdd",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Real.instMonoidWithZero",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "instHAdd",
            "And",
            "CommRing.toCommSemiring",
            "instHSub",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "AddZeroClass.toZero",
            "Real.instNeg",
            "propext",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "instHPow",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [add_eq_zero_iff_of_nonneg (by positivity) (by positivity)]",
          "proofState": 562,
          "pos": {
            "line": 876,
            "column": 4
          },
          "goals": "case h.e'_3\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 (a - (fromQuaternion a).toQuaternion).re ^ 2 + (a - (fromQuaternion a).toQuaternion).imI ^ 2 +\n        (a - (fromQuaternion a).toQuaternion).imJ ^ 2 +\n      (a - (fromQuaternion a).toQuaternion).imK ^ 2 =\n    0",
          "endPos": {
            "line": 876,
            "column": 66
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Ring.toSub",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.partialOrder",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "OrderedAddCommGroup.toAddLeftMono",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "CommSemiring.toSemiring",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "Distrib.toAdd",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "instHAdd",
            "even_two_mul",
            "CommRing.toCommSemiring",
            "instHSub",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "HAdd.hAdd",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Real.orderedAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 563,
          "pos": {
            "line": 876,
            "column": 38
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 0 \u2264\n    (a - (fromQuaternion a).toQuaternion).re ^ 2 + (a - (fromQuaternion a).toQuaternion).imI ^ 2 +\n      (a - (fromQuaternion a).toQuaternion).imJ ^ 2",
          "endPos": {
            "line": 876,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Ring.toSub",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 564,
          "pos": {
            "line": 876,
            "column": 54
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 0 \u2264 (a - (fromQuaternion a).toQuaternion).imK ^ 2",
          "endPos": {
            "line": 876,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Ring.toSub",
            "add_eq_zero_iff_of_nonneg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "Real.instAddMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "id",
            "Distrib.toAdd",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "instHAdd",
            "And",
            "CommRing.toCommSemiring",
            "instHSub",
            "HPow.hPow",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "AddZeroClass.toZero",
            "Real.instNeg",
            "propext",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "instHPow",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [add_eq_zero_iff_of_nonneg (by positivity) (by positivity)]",
          "proofState": 565,
          "pos": {
            "line": 877,
            "column": 4
          },
          "goals": "case h.e'_3\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 (a - (fromQuaternion a).toQuaternion).re ^ 2 + (a - (fromQuaternion a).toQuaternion).imI ^ 2 +\n        (a - (fromQuaternion a).toQuaternion).imJ ^ 2 =\n      0 \u2227\n    (a - (fromQuaternion a).toQuaternion).imK ^ 2 = 0",
          "endPos": {
            "line": 877,
            "column": 66
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Ring.toSub",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real.partialOrder",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "OrderedAddCommGroup.toAddLeftMono",
            "Real.instZero",
            "Real.instAddMonoid",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "CommSemiring.toSemiring",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Monoid.toNatPow",
            "add_nonneg",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "even_two_mul",
            "CommRing.toCommSemiring",
            "instHSub",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Real.orderedAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "instHPow",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Quaternion",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 566,
          "pos": {
            "line": 877,
            "column": 38
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 0 \u2264 (a - (fromQuaternion a).toQuaternion).re ^ 2 + (a - (fromQuaternion a).toQuaternion).imI ^ 2",
          "endPos": {
            "line": 877,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Ring.toSub",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 567,
          "pos": {
            "line": 877,
            "column": 54
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 0 \u2264 (a - (fromQuaternion a).toQuaternion).imJ ^ 2",
          "endPos": {
            "line": 877,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Ring.toSub",
            "add_eq_zero_iff_of_nonneg",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "Real.instAddMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "id",
            "Distrib.toAdd",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "instHAdd",
            "And",
            "CommRing.toCommSemiring",
            "instHSub",
            "HPow.hPow",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "AddZeroClass.toZero",
            "Real.instNeg",
            "propext",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "instHPow",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [add_eq_zero_iff_of_nonneg (by positivity) (by positivity)]",
          "proofState": 568,
          "pos": {
            "line": 878,
            "column": 4
          },
          "goals": "case h.e'_3\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 ((a - (fromQuaternion a).toQuaternion).re ^ 2 + (a - (fromQuaternion a).toQuaternion).imI ^ 2 = 0 \u2227\n      (a - (fromQuaternion a).toQuaternion).imJ ^ 2 = 0) \u2227\n    (a - (fromQuaternion a).toQuaternion).imK ^ 2 = 0",
          "endPos": {
            "line": 878,
            "column": 66
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Ring.toSub",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 569,
          "pos": {
            "line": 878,
            "column": 38
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 0 \u2264 (a - (fromQuaternion a).toQuaternion).re ^ 2",
          "endPos": {
            "line": 878,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NegZeroClass.toNeg",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Ring.toSub",
            "StrictOrderedSemiring.toOrderedSemiring",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "AddGroupWithOne.toAddGroup",
            "Even.pow_nonneg",
            "OrderedAddCommMonoid.toPartialOrder",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "AddMonoidWithOne.toNatCast",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "LinearOrderedRing.toLinearOrderedSemiring",
            "StrictOrderedRing.toRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "even_two_mul",
            "instHSub",
            "instNatAtLeastTwo",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "Nat",
            "AddGroup.existsAddOfLE",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Real.instLinearOrderedRing",
            "Nat.instSemiring",
            "Zero.toOfNat0",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "MulZeroClass.toZero",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "positivity",
          "proofState": 570,
          "pos": {
            "line": 878,
            "column": 54
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 0 \u2264 (a - (fromQuaternion a).toQuaternion).imI ^ 2",
          "endPos": {
            "line": 878,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Ring.toSub",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "Real.instAddMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "id",
            "_auxLemma.34",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "And",
            "CommRing.toCommSemiring",
            "instHSub",
            "HPow.hPow",
            "Ring.toAddCommGroup",
            "Nat",
            "AddZeroClass.toZero",
            "Real.instNeg",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "instHPow",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_rw [and_assoc, sq_eq_zero_iff, sub_re, sub_imI, sub_imJ, sub_imK, sub_eq_zero, \u2190 Quaternion.ext_iff]",
          "proofState": 571,
          "pos": {
            "line": 879,
            "column": 4
          },
          "goals": "case h.e'_3\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 (((a - (fromQuaternion a).toQuaternion).re ^ 2 = 0 \u2227 (a - (fromQuaternion a).toQuaternion).imI ^ 2 = 0) \u2227\n      (a - (fromQuaternion a).toQuaternion).imJ ^ 2 = 0) \u2227\n    (a - (fromQuaternion a).toQuaternion).imK ^ 2 = 0",
          "endPos": {
            "line": 880,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.symm"
          ],
          "tactic": "symm",
          "proofState": 572,
          "pos": {
            "line": 881,
            "column": 4
          },
          "goals": "case h.e'_3\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 a = (fromQuaternion a).toQuaternion",
          "endPos": {
            "line": 881,
            "column": 8
          }
        },
        {
          "usedConstants": [
            "Hurwitz.leftInvOn_toQuaternion_fromQuaternion"
          ],
          "tactic": "apply leftInvOn_toQuaternion_fromQuaternion",
          "proofState": 573,
          "pos": {
            "line": 882,
            "column": 4
          },
          "goals": "case h.e'_3\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 (fromQuaternion a).toQuaternion = a",
          "endPos": {
            "line": 882,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real",
            "_auxLemma.25",
            "Real.instZero",
            "Real.instInv",
            "setOf",
            "QuaternionAlgebra.mk",
            "Membership.mem",
            "Exists",
            "id",
            "instOfNatNat",
            "Int",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "Real.instNeg",
            "Real.instIntCast",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Or",
            "OfNat.ofNat",
            "Eq",
            "Set.instMembership",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Quaternion",
            "Real.instNatCast",
            "Set"
          ],
          "tactic": "simp only [Set.mem_setOf]",
          "proofState": 574,
          "pos": {
            "line": 883,
            "column": 6
          },
          "goals": "case h.e'_3.a\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 a \u2208\n    {q |\n      \u2203 a b c d,\n        q = { re := \u2191a, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n          q = { re := \u2191a + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }}",
          "endPos": {
            "line": 883,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "Real.lattice",
            "Real.instZero",
            "abs",
            "Real.instInv",
            "Real.instSub",
            "HSub.hSub",
            "QuaternionAlgebra.mk",
            "Exists",
            "Real.instAddGroup",
            "instOfNatNat",
            "Int",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "Real.instNeg",
            "Real.instIntCast",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Or",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Neg.neg",
            "Quaternion",
            "Real.instNatCast"
          ],
          "tactic": "have {r : \u211d} {z : \u2124} (h : |r - z| = 2\u207b\u00b9) : \u2203 z' : \u2124, r = z' + 2\u207b\u00b9 := by\n  cases (abs_eq (by positivity)).mp h with (rw [sub_eq_iff_eq_add'] at h)\n  | inl h => use z\n  | inr h => use z - 1; rw [h, Int.cast_sub, Int.cast_one, add_comm_sub]; norm_num",
          "proofState": 575,
          "pos": {
            "line": 884,
            "column": 6
          },
          "goals": "case h.e'_3.a\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\n\u22a2 \u2203 a_1 b c d,\n    a = { re := \u2191a_1, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      a = { re := \u2191a_1 + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 887,
            "column": 88
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Real.partialOrder",
            "Real",
            "LinearOrderedSemifield.toSemifield",
            "Nat.ble",
            "Real.instZero",
            "abs",
            "Real.orderedSemiring",
            "Real.instInv",
            "Real.instSub",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "abs_eq",
            "HSub.hSub",
            "le_of_lt",
            "DivisionSemiring.toGroupWithZero",
            "AddCommGroup.toAddGroup",
            "OrderedSemiring.zeroLEOneClass",
            "LinearOrderedSemiring.toPosMulReflectLT",
            "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
            "LinearOrderedAddCommGroup.toLinearOrder",
            "DistribLattice.toLattice",
            "OrderedAddCommGroup.toAddCommGroup",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "inv_pos_of_pos",
            "instHSub",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "Mathlib.Meta.Positivity.pos_of_isNat",
            "OrderedCommSemiring.toOrderedSemiring",
            "Nat",
            "Real.nontrivial",
            "Real.instIntCast",
            "Iff.mp",
            "Bool",
            "LinearOrderedSemifield.toLinearOrderedCommSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "Or",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Eq",
            "Real.instLinearOrderedAddCommGroup",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "instDistribLatticeOfLinearOrder",
            "Neg.neg",
            "Real.instNatCast"
          ],
          "tactic": "cases (abs_eq (by positivity)).mp h with (rw [sub_eq_iff_eq_add'] at h)\n| inl h => use z\n| inr h => use z - 1; rw [h, Int.cast_sub, Int.cast_one, add_comm_sub]; norm_num",
          "proofState": 576,
          "pos": {
            "line": 885,
            "column": 8
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh : |r - \u2191z| = 2\u207b\u00b9\n\u22a2 \u2203 z', r = \u2191z' + 2\u207b\u00b9",
          "endPos": {
            "line": 887,
            "column": 88
          }
        },
        {
          "usedConstants": [],
          "tactic": "cases (abs_eq (by positivity)).mp h with (rw [sub_eq_iff_eq_add'] at h)\n| inl h => use z\n| inr h => use z - 1; rw [h, Int.cast_sub, Int.cast_one, add_comm_sub]; norm_num",
          "proofState": 577,
          "pos": {
            "line": 885,
            "column": 8
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh : |r - \u2191z| = 2\u207b\u00b9\nx\u271d : r - \u2191z = 2\u207b\u00b9 \u2228 r - \u2191z = -2\u207b\u00b9\n\u22a2 \u2203 z', r = \u2191z' + 2\u207b\u00b9",
          "endPos": {
            "line": 887,
            "column": 88
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Real.partialOrder",
            "Real",
            "LinearOrderedSemifield.toSemifield",
            "Nat.ble",
            "Real.instZero",
            "Real.orderedSemiring",
            "Real.instInv",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "le_of_lt",
            "DivisionSemiring.toGroupWithZero",
            "OrderedSemiring.zeroLEOneClass",
            "LinearOrderedSemiring.toPosMulReflectLT",
            "AddMonoidWithOne.toNatCast",
            "Real.instRing",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "inv_pos_of_pos",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "instNatAtLeastTwo",
            "Mathlib.Meta.Positivity.pos_of_isNat",
            "OrderedCommSemiring.toOrderedSemiring",
            "Nat",
            "Real.nontrivial",
            "Bool",
            "LinearOrderedSemifield.toLinearOrderedCommSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "OfNat.ofNat",
            "LinearOrderedField.toLinearOrderedSemifield",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "positivity",
          "proofState": 578,
          "pos": {
            "line": 885,
            "column": 26
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh : |r - \u2191z| = 2\u207b\u00b9\n\u22a2 0 \u2264 2\u207b\u00b9",
          "endPos": {
            "line": 885,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "congrArg",
            "Real.instInv",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "Eq.mp",
            "instOfNatNat",
            "Real.instAddCommGroup",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Nat",
            "Real.instIntCast",
            "propext",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "instOfNatAtLeastTwo",
            "sub_eq_iff_eq_add'",
            "Real.instNatCast"
          ],
          "tactic": "rw [sub_eq_iff_eq_add'] at h",
          "proofState": 579,
          "pos": {
            "line": 885,
            "column": 50
          },
          "goals": "case inl\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh\u271d : |r - \u2191z| = 2\u207b\u00b9\nh : r - \u2191z = 2\u207b\u00b9\n\u22a2 \u2203 z', r = \u2191z' + 2\u207b\u00b9",
          "endPos": {
            "line": 885,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use z",
          "proofState": 580,
          "pos": {
            "line": 886,
            "column": 19
          },
          "goals": "case inl\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh\u271d : |r - \u2191z| = 2\u207b\u00b9\nh : r = \u2191z + 2\u207b\u00b9\n\u22a2 \u2203 z', r = \u2191z' + 2\u207b\u00b9",
          "endPos": {
            "line": 886,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "NegZeroClass.toNeg",
            "Real",
            "congrArg",
            "Real.instInv",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "Eq.mp",
            "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
            "OrderedAddCommGroup.toAddCommGroup",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "SubNegMonoid.toSub",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "Nat",
            "Real.instIntCast",
            "propext",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Real.instLinearOrderedAddCommGroup",
            "instOfNatAtLeastTwo",
            "sub_eq_iff_eq_add'",
            "Neg.neg",
            "Real.instNatCast"
          ],
          "tactic": "rw [sub_eq_iff_eq_add'] at h",
          "proofState": 581,
          "pos": {
            "line": 885,
            "column": 50
          },
          "goals": "case inr\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh\u271d : |r - \u2191z| = 2\u207b\u00b9\nh : r - \u2191z = -2\u207b\u00b9\n\u22a2 \u2203 z', r = \u2191z' + 2\u207b\u00b9",
          "endPos": {
            "line": 885,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use z - 1",
          "proofState": 582,
          "pos": {
            "line": 887,
            "column": 19
          },
          "goals": "case inr\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh\u271d : |r - \u2191z| = 2\u207b\u00b9\nh : r = \u2191z + -2\u207b\u00b9\n\u22a2 \u2203 z', r = \u2191z' + 2\u207b\u00b9",
          "endPos": {
            "line": 887,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real",
            "congrArg",
            "Real.instInv",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
            "id",
            "OrderedAddCommGroup.toAddCommGroup",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instAdd",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "instOfNat",
            "HAdd.hAdd",
            "Nat",
            "Real.instIntCast",
            "Int.instSub",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "AddZeroClass.toAdd",
            "Eq",
            "Real.instLinearOrderedAddCommGroup",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Real.instNatCast"
          ],
          "tactic": "rw [h, Int.cast_sub, Int.cast_one, add_comm_sub]",
          "proofState": 583,
          "pos": {
            "line": 887,
            "column": 30
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh\u271d : |r - \u2191z| = 2\u207b\u00b9\nh : r = \u2191z + -2\u207b\u00b9\n\u22a2 r = \u2191(z - 1) + 2\u207b\u00b9",
          "endPos": {
            "line": 887,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "NegZeroClass.toNeg",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "Real",
            "instHDiv",
            "GroupWithZero.toDivisionMonoid",
            "HMul.hMul",
            "DivInvOneMonoid.toInvOneClass",
            "Mathlib.Meta.NormNum.isRat_mul",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "congrArg",
            "Real.instInv",
            "AddMonoid.toAddZeroClass",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "DivisionSemiring.toGroupWithZero",
            "AddCommGroup.toAddGroup",
            "DivisionMonoid.toDivInvOneMonoid",
            "DivisionRing.toDivisionSemiring",
            "DivisionRing.toDivInvMonoid",
            "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "OrderedAddCommGroup.toAddCommGroup",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubtractionMonoid.toSubNegMonoid",
            "AddGroupWithOne.toIntCast",
            "SubNegZeroMonoid.toNegZeroClass",
            "Real.instAddCommGroup",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "SubNegMonoid.toSub",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "congr",
            "Real.instDivisionRing",
            "True",
            "Mathlib.Meta.NormNum.isRat_neg",
            "eq_self",
            "Real.instIntCast",
            "Mathlib.Meta.NormNum.isRat_div",
            "Int.mul",
            "DivInvMonoid.toDiv",
            "eq_true",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "InvOneClass.toInv",
            "SubNegMonoid.toAddMonoid",
            "AddCommGroup.toDivisionAddCommMonoid",
            "OfNat.ofNat",
            "Mathlib.Meta.NormNum.isRat_sub",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Nat.cast_one",
            "Real.instLinearOrderedAddCommGroup",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "Int.negOfNat",
            "True.intro",
            "instHMul",
            "Real.instNatCast",
            "Mathlib.Meta.NormNum.IsRat.neg_to_eq"
          ],
          "tactic": "norm_num",
          "proofState": 584,
          "pos": {
            "line": 887,
            "column": 80
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz\u271d : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z\u271d| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nr : \u211d\nz : \u2124\nh\u271d : |r - \u2191z| = 2\u207b\u00b9\nh : r = \u2191z + -2\u207b\u00b9\n\u22a2 \u2191z + -2\u207b\u00b9 = \u2191z + (2\u207b\u00b9 - 1)",
          "endPos": {
            "line": 887,
            "column": 88
          }
        },
        {
          "usedConstants": [
            "And.left"
          ],
          "tactic": "obtain \u27e8x', hx'\u27e9 := this H.1",
          "proofState": 585,
          "pos": {
            "line": 889,
            "column": 6
          },
          "goals": "case h.e'_3.a\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\n\u22a2 \u2203 a_1 b c d,\n    a = { re := \u2191a_1, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      a = { re := \u2191a_1 + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 889,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "And.right",
            "And.left"
          ],
          "tactic": "obtain \u27e8y', hy'\u27e9 := this H.2.1",
          "proofState": 586,
          "pos": {
            "line": 890,
            "column": 6
          },
          "goals": "case h.e'_3.a.intro\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\n\u22a2 \u2203 a_1 b c d,\n    a = { re := \u2191a_1, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      a = { re := \u2191a_1 + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 890,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "And.right",
            "And.left"
          ],
          "tactic": "obtain \u27e8z', hz'\u27e9 := this H.2.2.1",
          "proofState": 587,
          "pos": {
            "line": 891,
            "column": 6
          },
          "goals": "case h.e'_3.a.intro.intro\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\n\u22a2 \u2203 a_1 b c d,\n    a = { re := \u2191a_1, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      a = { re := \u2191a_1 + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 891,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "And.right"
          ],
          "tactic": "obtain \u27e8w', hw'\u27e9 := this H.2.2.2",
          "proofState": 588,
          "pos": {
            "line": 892,
            "column": 6
          },
          "goals": "case h.e'_3.a.intro.intro.intro\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\nz' : \u2124\nhz' : a.imJ = \u2191z' + 2\u207b\u00b9\n\u22a2 \u2203 a_1 b c d,\n    a = { re := \u2191a_1, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      a = { re := \u2191a_1 + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 892,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use x', y', z', w', Or.inr ?_",
          "proofState": 589,
          "pos": {
            "line": 893,
            "column": 6
          },
          "goals": "case h.e'_3.a.intro.intro.intro.intro\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\nz' : \u2124\nhz' : a.imJ = \u2191z' + 2\u207b\u00b9\nw' : \u2124\nhw' : a.imK = \u2191w' + 2\u207b\u00b9\n\u22a2 \u2203 a_1 b c d,\n    a = { re := \u2191a_1, imI := \u2191b, imJ := \u2191c, imK := \u2191d } \u2228\n      a = { re := \u2191a_1 + 2\u207b\u00b9, imI := \u2191b + 2\u207b\u00b9, imJ := \u2191c + 2\u207b\u00b9, imK := \u2191d + 2\u207b\u00b9 }",
          "endPos": {
            "line": 893,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Quaternion.ext"
          ],
          "tactic": "ext",
          "proofState": 590,
          "pos": {
            "line": 894,
            "column": 6
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\nz' : \u2124\nhz' : a.imJ = \u2191z' + 2\u207b\u00b9\nw' : \u2124\nhw' : a.imK = \u2191w' + 2\u207b\u00b9\n\u22a2 a = { re := \u2191x' + 2\u207b\u00b9, imI := \u2191y' + 2\u207b\u00b9, imJ := \u2191z' + 2\u207b\u00b9, imK := \u2191w' + 2\u207b\u00b9 }",
          "endPos": {
            "line": 894,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "QuaternionAlgebra.re",
            "instOfNatNat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "True",
            "Real.instNeg",
            "eq_self",
            "Real.instIntCast",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "Real.instNatCast"
          ],
          "tactic": "simp [*]",
          "proofState": 591,
          "pos": {
            "line": 894,
            "column": 14
          },
          "goals": "case h.a\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\nz' : \u2124\nhz' : a.imJ = \u2191z' + 2\u207b\u00b9\nw' : \u2124\nhw' : a.imK = \u2191w' + 2\u207b\u00b9\n\u22a2 a.re = { re := \u2191x' + 2\u207b\u00b9, imI := \u2191y' + 2\u207b\u00b9, imJ := \u2191z' + 2\u207b\u00b9, imK := \u2191w' + 2\u207b\u00b9 }.re",
          "endPos": {
            "line": 894,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "QuaternionAlgebra.imI",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "instOfNatNat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "True",
            "Real.instNeg",
            "eq_self",
            "Real.instIntCast",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "Real.instNatCast"
          ],
          "tactic": "simp [*]",
          "proofState": 592,
          "pos": {
            "line": 894,
            "column": 14
          },
          "goals": "case h.a\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\nz' : \u2124\nhz' : a.imJ = \u2191z' + 2\u207b\u00b9\nw' : \u2124\nhw' : a.imK = \u2191w' + 2\u207b\u00b9\n\u22a2 a.imI = { re := \u2191x' + 2\u207b\u00b9, imI := \u2191y' + 2\u207b\u00b9, imJ := \u2191z' + 2\u207b\u00b9, imK := \u2191w' + 2\u207b\u00b9 }.imI",
          "endPos": {
            "line": 894,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "instOfNatNat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "True",
            "Real.instNeg",
            "eq_self",
            "Real.instIntCast",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "QuaternionAlgebra.imJ",
            "Real.instNatCast"
          ],
          "tactic": "simp [*]",
          "proofState": 593,
          "pos": {
            "line": 894,
            "column": 14
          },
          "goals": "case h.a\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\nz' : \u2124\nhz' : a.imJ = \u2191z' + 2\u207b\u00b9\nw' : \u2124\nhw' : a.imK = \u2191w' + 2\u207b\u00b9\n\u22a2 a.imJ = { re := \u2191x' + 2\u207b\u00b9, imI := \u2191y' + 2\u207b\u00b9, imJ := \u2191z' + 2\u207b\u00b9, imK := \u2191w' + 2\u207b\u00b9 }.imJ",
          "endPos": {
            "line": 894,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Real",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "instOfNatNat",
            "Real.instAdd",
            "Real.instOne",
            "instHAdd",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HAdd.hAdd",
            "Nat",
            "True",
            "Real.instNeg",
            "eq_self",
            "Real.instIntCast",
            "of_eq_true",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "Eq.trans",
            "Real.instNatCast"
          ],
          "tactic": "simp [*]",
          "proofState": 594,
          "pos": {
            "line": 894,
            "column": 14
          },
          "goals": "case h.a\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9\nthis : \u2200 {r : \u211d} {z : \u2124}, |r - \u2191z| = 2\u207b\u00b9 \u2192 \u2203 z', r = \u2191z' + 2\u207b\u00b9\nx' : \u2124\nhx' : a.re = \u2191x' + 2\u207b\u00b9\ny' : \u2124\nhy' : a.imI = \u2191y' + 2\u207b\u00b9\nz' : \u2124\nhz' : a.imJ = \u2191z' + 2\u207b\u00b9\nw' : \u2124\nhw' : a.imK = \u2191w' + 2\u207b\u00b9\n\u22a2 a.imK = { re := \u2191x' + 2\u207b\u00b9, imI := \u2191y' + 2\u207b\u00b9, imJ := \u2191z' + 2\u207b\u00b9, imK := \u2191w' + 2\u207b\u00b9 }.imK",
          "endPos": {
            "line": 894,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use fromQuaternion \u27e8x, y, z, w\u27e9",
          "proofState": 595,
          "pos": {
            "line": 896,
            "column": 2
          },
          "goals": "case neg\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 \u2203 q, dist a q.toQuaternion < 1",
          "endPos": {
            "line": 896,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real",
            "Real.instZero",
            "congrArg",
            "NormedDivisionRing.toNormedRing",
            "Real.instLT",
            "QuaternionAlgebra.mk",
            "id",
            "_private.0.Hurwitz.aux",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "Hurwitz.toQuaternion",
            "NormedRing.toSeminormedRing",
            "LT.lt",
            "Real.instNeg",
            "Real.instIntCast",
            "Hurwitz.fromQuaternion",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "OfNat.ofNat",
            "Eq",
            "Neg.neg",
            "Quaternion"
          ],
          "tactic": "rw [aux]",
          "proofState": 596,
          "pos": {
            "line": 897,
            "column": 2
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 dist a (fromQuaternion { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w }).toQuaternion < 1",
          "endPos": {
            "line": 897,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Int.cast",
            "Eq.mpr",
            "Ring.toSub",
            "Real",
            "NormedRing.toRing",
            "Real.instZero",
            "congrArg",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "Real.instLT",
            "QuaternionAlgebra.mk",
            "id",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "instHSub",
            "NormedRing.toSeminormedRing",
            "LT.lt",
            "Real.instNeg",
            "Real.instIntCast",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "MetricSpace.toPseudoMetricSpace",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "NormedRing.toMetricSpace",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedRing.dist_eq",
            "OfNat.ofNat",
            "Eq",
            "NormedRing.toNorm",
            "Neg.neg",
            "Quaternion"
          ],
          "tactic": "rw [NormedRing.dist_eq, \u2190 sq_lt_one_iff\u2080 (_root_.norm_nonneg _), sq, \u2190 Quaternion.normSq_eq_norm_mul_self, normSq_def']",
          "proofState": 597,
          "pos": {
            "line": 898,
            "column": 2
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 dist a { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w } < 1",
          "endPos": {
            "line": 899,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Int.cast",
            "NegZeroClass.toNeg",
            "Ring.toSub",
            "Real",
            "Preorder.toLT",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "QuaternionAlgebra.imI",
            "NormedRing.toRing",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "CommSemiring.toSemiring",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "QuaternionAlgebra.mk",
            "Monoid.toNatPow",
            "id",
            "Distrib.toAdd",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Real.instMonoidWithZero",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "MulZeroOneClass.toMulOneClass",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "AddMonoidWithOne.toOne",
            "instHAdd",
            "CommRing.toCommSemiring",
            "instHSub",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Nat",
            "LT.lt",
            "Real.instNeg",
            "MulOneClass.toOne",
            "Real.instIntCast",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "instHPow",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "LinearOrder.toPartialOrder",
            "Ring.toAddGroupWithOne",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Real.linearOrder",
            "MulZeroClass.toZero",
            "Quaternion",
            "QuaternionAlgebra.imJ",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [sub_re, sub_imI, sub_imJ, sub_imK]",
          "proofState": 598,
          "pos": {
            "line": 901,
            "column": 2
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a - { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w }).re ^ 2 +\n          (a - { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w }).imI ^ 2 +\n        (a - { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w }).imJ ^ 2 +\n      (a - { re := \u2191x, imI := \u2191y, imJ := \u2191z, imK := \u2191w }).imK ^ 2 <\n    1",
          "endPos": {
            "line": 901,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "_private.0.Hurwitz.aux2"
          ],
          "tactic": "apply aux2",
          "proofState": 599,
          "pos": {
            "line": 903,
            "column": 2
          },
          "goals": "case h\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.re - \u2191x) ^ 2 + (a.imI - \u2191y) ^ 2 + (a.imJ - \u2191z) ^ 2 + (a.imK - \u2191w) ^ 2 < 1",
          "endPos": {
            "line": 903,
            "column": 12
          }
        },
        {
          "usedConstants": [],
          "tactic": "try apply this",
          "proofState": 600,
          "pos": {
            "line": 903,
            "column": 17
          },
          "goals": "case h.ha\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.re - \u2191x) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "apply this",
          "proofState": 601,
          "pos": {
            "line": 903,
            "column": 21
          },
          "goals": "case h.ha\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.re - \u2191x) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "try apply this",
          "proofState": 602,
          "pos": {
            "line": 903,
            "column": 17
          },
          "goals": "case h.hb\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.imI - \u2191y) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "apply this",
          "proofState": 603,
          "pos": {
            "line": 903,
            "column": 21
          },
          "goals": "case h.hb\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.imI - \u2191y) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "try apply this",
          "proofState": 604,
          "pos": {
            "line": 903,
            "column": 17
          },
          "goals": "case h.hc\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.imJ - \u2191z) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "apply this",
          "proofState": 605,
          "pos": {
            "line": 903,
            "column": 21
          },
          "goals": "case h.hc\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.imJ - \u2191z) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "try apply this",
          "proofState": 606,
          "pos": {
            "line": 903,
            "column": 17
          },
          "goals": "case h.hd\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.imK - \u2191w) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "apply this",
          "proofState": 607,
          "pos": {
            "line": 903,
            "column": 21
          },
          "goals": "case h.hd\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 (a.imK - \u2191w) ^ 2 \u2264 4\u207b\u00b9",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "try apply this",
          "proofState": 608,
          "pos": {
            "line": 903,
            "column": 17
          },
          "goals": "case h.H\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 \u00ac((a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9)",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "apply this",
          "proofState": 609,
          "pos": {
            "line": 903,
            "column": 21
          },
          "goals": "case h.H\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 \u00ac((a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9)",
          "endPos": {
            "line": 903,
            "column": 31
          }
        },
        {
          "usedConstants": [],
          "tactic": "contrapose! H",
          "proofState": 610,
          "pos": {
            "line": 904,
            "column": 2
          },
          "goals": "case h.H\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : \u00ac(|a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9)\n\u22a2 \u00ac((a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9)",
          "endPos": {
            "line": 904,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real",
            "QuaternionAlgebra.imI",
            "Real.lattice",
            "Real.instZero",
            "abs",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "Monoid.toNatPow",
            "id",
            "Real.instAddGroup",
            "instOfNatNat",
            "Real.instOne",
            "Real.instMonoid",
            "And",
            "Iff",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Nat",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "propext",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "instHPow",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "letFun",
            "Neg.neg",
            "QuaternionAlgebra.imJ",
            "Real.instNatCast"
          ],
          "tactic": "suffices \u2200 r : \u211d, |r| = 2\u207b\u00b9 \u2194 r ^ 2 = 4\u207b\u00b9 by simpa [this]",
          "proofState": 611,
          "pos": {
            "line": 905,
            "column": 2
          },
          "goals": "case h.H\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : (a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9\n\u22a2 |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9",
          "endPos": {
            "line": 906,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real",
            "QuaternionAlgebra.imI",
            "Real.lattice",
            "Real.instZero",
            "abs",
            "congrArg",
            "Real.instInv",
            "Real.instSub",
            "HSub.hSub",
            "QuaternionAlgebra.re",
            "Monoid.toNatPow",
            "id",
            "Real.instAddGroup",
            "instOfNatNat",
            "Real.instOne",
            "Real.instMonoid",
            "And",
            "instHSub",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Nat",
            "congr",
            "Real.instNeg",
            "Real.instIntCast",
            "propext",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "instHPow",
            "QuaternionAlgebra.imK",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Neg.neg",
            "QuaternionAlgebra.imJ",
            "Real.instNatCast"
          ],
          "tactic": "simpa [this]",
          "proofState": 612,
          "pos": {
            "line": 906,
            "column": 4
          },
          "goals": "a : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis\u271d : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : (a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9\nthis : \u2200 (r : \u211d), |r| = 2\u207b\u00b9 \u2194 r ^ 2 = 4\u207b\u00b9\n\u22a2 |a.re - \u2191x| = 2\u207b\u00b9 \u2227 |a.imI - \u2191y| = 2\u207b\u00b9 \u2227 |a.imJ - \u2191z| = 2\u207b\u00b9 \u2227 |a.imK - \u2191w| = 2\u207b\u00b9",
          "endPos": {
            "line": 906,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Real"
          ],
          "tactic": "intro r",
          "proofState": 613,
          "pos": {
            "line": 907,
            "column": 2
          },
          "goals": "case h.H\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : (a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9\n\u22a2 \u2200 (r : \u211d), |r| = 2\u207b\u00b9 \u2194 r ^ 2 = 4\u207b\u00b9",
          "endPos": {
            "line": 907,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "Real.lattice",
            "abs",
            "congrArg",
            "Real.instInv",
            "Monoid.toNatPow",
            "id",
            "Real.instAddGroup",
            "instOfNatNat",
            "Real.instMonoid",
            "Iff",
            "Inv.inv",
            "instNatAtLeastTwo",
            "HPow.hPow",
            "Nat",
            "instHPow",
            "OfNat.ofNat",
            "Eq",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "rw [four_inv, sq_eq_sq_iff_abs_eq_abs, abs_of_nonneg (a := (2\u207b\u00b9 : \u211d))]",
          "proofState": 614,
          "pos": {
            "line": 908,
            "column": 2
          },
          "goals": "case h.H\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : (a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9\nr : \u211d\n\u22a2 |r| = 2\u207b\u00b9 \u2194 r ^ 2 = 4\u207b\u00b9",
          "endPos": {
            "line": 908,
            "column": 72
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "AddGroup.toSubtractionMonoid",
            "Mathlib.Meta.NormNum.isRat_inv_pos",
            "LinearOrderedField.toLinearOrderedCommRing",
            "Real",
            "Real.instRCLike",
            "Real.instInv",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Field.toDivisionRing",
            "AddMonoidWithOne.toNatCast",
            "Int.ofNat",
            "Real.instAddGroup",
            "DivisionRing.toRing",
            "Real.instRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "Mathlib.Meta.NormNum.isNat_ofNat",
            "SubNegZeroMonoid.toNegZeroClass",
            "Mathlib.Meta.NormNum.IsNat.to_isRat",
            "Mathlib.Meta.NormNum.isRat_le_true",
            "Bool.true",
            "LinearOrderedField.toField",
            "Inv.inv",
            "instNatAtLeastTwo",
            "Nat",
            "Real.instDivisionRing",
            "Bool",
            "Zero.toOfNat0",
            "Eq.refl",
            "Nat.cast_zero",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "instOfNatAtLeastTwo",
            "Real.instNatCast"
          ],
          "tactic": "norm_num",
          "proofState": 615,
          "pos": {
            "line": 909,
            "column": 2
          },
          "goals": "case h.H\na : \u210d\nfour_inv : 4\u207b\u00b9 = 2\u207b\u00b9 ^ 2\nthis : \u2200 (r : \u211d), (r - \u2191(round r)) ^ 2 \u2264 4\u207b\u00b9\nx : \u2124 := round a.re\ny : \u2124 := round a.imI\nz : \u2124 := round a.imJ\nw : \u2124 := round a.imK\nH : (a.re - \u2191x) ^ 2 = 4\u207b\u00b9 \u2227 (a.imI - \u2191y) ^ 2 = 4\u207b\u00b9 \u2227 (a.imJ - \u2191z) ^ 2 = 4\u207b\u00b9 \u2227 (a.imK - \u2191w) ^ 2 = 4\u207b\u00b9\nr : \u211d\n\u22a2 0 \u2264 2\u207b\u00b9",
          "endPos": {
            "line": 909,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "Real.instOne",
            "Hurwitz.toQuaternion",
            "Real.instNeg",
            "Quaternion"
          ],
          "tactic": "let a' := toQuaternion a",
          "proofState": 616,
          "pos": {
            "line": 913,
            "column": 2
          },
          "goals": "a b : \ud835\udcde\nhb : b \u2260 0\n\u22a2 \u2203 q r, a = q * b + r \u2227 r.norm < b.norm",
          "endPos": {
            "line": 913,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "Real",
            "Real.instZero",
            "Real.instOne",
            "Hurwitz.toQuaternion",
            "Real.instNeg",
            "Quaternion"
          ],
          "tactic": "let b' := toQuaternion b",
          "proofState": 617,
          "pos": {
            "line": 914,
            "column": 2
          },
          "goals": "a b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\n\u22a2 \u2203 q r, a = q * b + r \u2227 r.norm < b.norm",
          "endPos": {
            "line": 914,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "Real",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "Hurwitz.instMul",
            "Hurwitz.instAdd",
            "Hurwitz.instZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Exists",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Hurwitz.toQuaternion_ne_zero_iff",
            "Ne",
            "Int",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instOne",
            "Int.instLTInt",
            "Hurwitz.toQuaternion",
            "instHAdd",
            "And",
            "Hurwitz",
            "HAdd.hAdd",
            "Hurwitz.norm",
            "LT.lt",
            "Real.instNeg",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq",
            "Quaternion.instRing",
            "letFun",
            "MulZeroClass.toZero",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "have hb' : b' \u2260 0 := toQuaternion_ne_zero_iff.mpr hb",
          "proofState": 618,
          "pos": {
            "line": 915,
            "column": 2
          },
          "goals": "a b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\n\u22a2 \u2203 q r, a = q * b + r \u2227 r.norm < b.norm",
          "endPos": {
            "line": 915,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Real",
            "instHDiv",
            "Real.instZero",
            "DivisionRing.toDivInvMonoid",
            "HDiv.hDiv",
            "Quaternion.instDivisionRing",
            "Real.instOne",
            "Real.instNeg",
            "DivInvMonoid.toDiv",
            "Quaternion"
          ],
          "tactic": "let q' := a' / b'",
          "proofState": 619,
          "pos": {
            "line": 916,
            "column": 2
          },
          "goals": "a b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\n\u22a2 \u2203 q r, a = q * b + r \u2227 r.norm < b.norm",
          "endPos": {
            "line": 916,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "Hurwitz.exists_near"
          ],
          "tactic": "obtain \u27e8q : \ud835\udcde, hq : dist q' (toQuaternion q) < 1\u27e9 : \u2203 _, _ := exists_near q'",
          "proofState": 620,
          "pos": {
            "line": 917,
            "column": 2
          },
          "goals": "a b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\n\u22a2 \u2203 q r, a = q * b + r \u2227 r.norm < b.norm",
          "endPos": {
            "line": 917,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ring",
            "HMul.hMul",
            "Hurwitz.instMul",
            "Hurwitz.instAdd",
            "AddMonoid.toAddZeroClass",
            "HSub.hSub",
            "AddCommGroup.toAddGroup",
            "Exists",
            "Int",
            "SubNegMonoid.toSub",
            "Int.instLTInt",
            "instHAdd",
            "And",
            "instHSub",
            "Hurwitz",
            "AddGroup.toSubNegMonoid",
            "add_sub_cancel",
            "HAdd.hAdd",
            "Ring.toAddCommGroup",
            "Hurwitz.norm",
            "And.intro",
            "LT.lt",
            "Exists.intro",
            "Hurwitz.instSub",
            "SubNegMonoid.toAddMonoid",
            "Eq.symm",
            "AddZeroClass.toAdd",
            "Eq",
            "instHMul"
          ],
          "tactic": "refine \u27e8q, a - q * b, (add_sub_cancel _ _).symm, ?_\u27e9",
          "proofState": 621,
          "pos": {
            "line": 918,
            "column": 2
          },
          "goals": "case intro\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 \u2203 q r, a = q * b + r \u2227 r.norm < b.norm",
          "endPos": {
            "line": 918,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Int.cast",
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "Preorder.toLT",
            "HMul.hMul",
            "OrderedAddCommGroup.toAddLeftMono",
            "Ring.toNonAssocRing",
            "Real.instRCLike",
            "Real.orderedSemiring",
            "congrArg",
            "Hurwitz.instMul",
            "NeZero.charZero_one",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "OrderedSemiring.zeroLEOneClass",
            "Int.cast_lt",
            "id",
            "Real.instRing",
            "Int",
            "AddGroupWithOne.toIntCast",
            "Int.instLTInt",
            "NonAssocRing.toAddCommGroupWithOne",
            "instHSub",
            "Hurwitz",
            "Real.orderedAddCommGroup",
            "Hurwitz.norm",
            "LT.lt",
            "propext",
            "Hurwitz.instSub",
            "Eq.symm",
            "Eq",
            "RCLike.charZero_rclike",
            "Ring.toAddGroupWithOne",
            "AddCommGroupWithOne.toAddGroupWithOne",
            "instHMul"
          ],
          "tactic": "rw [\u2190 Int.cast_lt (R := \u211d), \u2190 normSq_toQuaternion, \u2190 normSq_toQuaternion]",
          "proofState": 622,
          "pos": {
            "line": 919,
            "column": 2
          },
          "goals": "case intro\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 (a - q * b).norm < b.norm",
          "endPos": {
            "line": 919,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Norm.norm",
            "Eq.mpr",
            "NegZeroClass.toNeg",
            "Real.partialOrder",
            "Real",
            "Preorder.toLT",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "Real.instZero",
            "congrArg",
            "Hurwitz.instMul",
            "CommSemiring.toSemiring",
            "PartialOrder.toPreorder",
            "AddGroupWithOne.toAddMonoidWithOne",
            "HSub.hSub",
            "Quaternion.normSq",
            "MonoidWithZeroHom.funLike",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Quaternion.instNormedAddCommGroupReal",
            "id",
            "Quaternion.normSq_eq_norm_mul_self",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Real.commRing",
            "SubNegZeroMonoid.toNegZeroClass",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Real.instOne",
            "AddMonoidWithOne.toOne",
            "Hurwitz.toQuaternion",
            "CommRing.toCommSemiring",
            "MonoidWithZeroHom",
            "instHSub",
            "Hurwitz",
            "NormedAddCommGroup.toNorm",
            "Ring.toAddCommGroup",
            "Real.instMul",
            "LT.lt",
            "Real.instNeg",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Hurwitz.instSub",
            "CommRing.toRing",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Quaternion.instRing",
            "MulZeroClass.toZero",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "rw [normSq_eq_norm_mul_self, normSq_eq_norm_mul_self]",
          "proofState": 623,
          "pos": {
            "line": 920,
            "column": 2
          },
          "goals": "case intro\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 normSq (a - q * b).toQuaternion < normSq b.toQuaternion",
          "endPos": {
            "line": 920,
            "column": 55
          }
        },
        {
          "usedConstants": [
            "Real.strictOrderedSemiring",
            "StrictOrderedSemiring.toPosMulStrictMono",
            "Norm.norm",
            "Real.partialOrder",
            "Real",
            "HMul.hMul",
            "Real.instZero",
            "Real.orderedSemiring",
            "Hurwitz.instMul",
            "HSub.hSub",
            "Quaternion.instNormedAddCommGroupReal",
            "Real.instMonoidWithZero",
            "OrderedSemiring.toMulPosMono",
            "Real.instOne",
            "Hurwitz.toQuaternion",
            "instHSub",
            "Hurwitz",
            "NormedAddCommGroup.toNorm",
            "Real.instNeg",
            "mul_self_lt_mul_self",
            "Hurwitz.instSub",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "refine mul_self_lt_mul_self ?_ ?_",
          "proofState": 624,
          "pos": {
            "line": 921,
            "column": 2
          },
          "goals": "case intro\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 \u2016(a - q * b).toQuaternion\u2016 * \u2016(a - q * b).toQuaternion\u2016 < \u2016b.toQuaternion\u2016 * \u2016b.toQuaternion\u2016",
          "endPos": {
            "line": 921,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Real",
            "HMul.hMul",
            "Real.instZero",
            "Hurwitz.instMul",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "NormedRing.toNonUnitalNormedRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Hurwitz.toQuaternion",
            "instHSub",
            "Hurwitz",
            "Real.instNeg",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Hurwitz.instSub",
            "NonUnitalNormedRing.toNonUnitalSeminormedRing",
            "norm_nonneg",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "exact _root_.norm_nonneg (a - q * b).toQuaternion",
          "proofState": 625,
          "pos": {
            "line": 922,
            "column": 4
          },
          "goals": "case intro.refine_1\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 0 \u2264 \u2016(a - q * b).toQuaternion\u2016",
          "endPos": {
            "line": 922,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Eq.mpr",
            "Real.partialOrder",
            "Real",
            "Preorder.toLT",
            "HMul.hMul",
            "Real.instZero",
            "congrArg",
            "Hurwitz.instMul",
            "Hurwitz.toQuaternion_sub",
            "PartialOrder.toPreorder",
            "HSub.hSub",
            "Quaternion.instNormedAddCommGroupReal",
            "id",
            "NormedAddGroup.toAddGroup",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "Hurwitz.toQuaternion",
            "instHSub",
            "Hurwitz",
            "AddGroup.toSubNegMonoid",
            "NormedAddCommGroup.toNorm",
            "NormedAddCommGroup.toNormedAddGroup",
            "LT.lt",
            "Real.instNeg",
            "Hurwitz.instSub",
            "Eq",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "rw [toQuaternion_sub, \u2190 dist_eq_norm]",
          "proofState": 626,
          "pos": {
            "line": 923,
            "column": 2
          },
          "goals": "case intro.refine_2\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 \u2016(a - q * b).toQuaternion\u2016 < \u2016b.toQuaternion\u2016",
          "endPos": {
            "line": 923,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Real",
            "Trans.trans",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "Hurwitz.instMul",
            "NormedDivisionRing.toNorm",
            "NormedDivisionRing.toNormedRing",
            "Real.instLT",
            "Quaternion.instNormedAddCommGroupReal",
            "NormedRing.toNonUnitalNormedRing",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "instTransEq",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Hurwitz.toQuaternion",
            "Hurwitz",
            "Distrib.toMul",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "NormedAddCommGroup.toNorm",
            "Real.instMul",
            "NormedRing.toSeminormedRing",
            "LT.lt",
            "Real.instNeg",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "NonUnitalNormedRing.toNonUnitalSeminormedRing",
            "Eq",
            "Quaternion.instRing",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "calc\n  _ = dist (q' * b') (q.toQuaternion * b') := ?_\n  _ = dist q' (q.toQuaternion) * \u2016b'\u2016 := ?_\n  _ < _ := ?_",
          "proofState": 627,
          "pos": {
            "line": 924,
            "column": 2
          },
          "goals": "case intro.refine_2\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 dist a.toQuaternion (q * b).toQuaternion < \u2016b.toQuaternion\u2016",
          "endPos": {
            "line": 927,
            "column": 15
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  _ = dist (q' * b') (q.toQuaternion * b') := ?_\n  _ = dist q' (q.toQuaternion) * \u2016b'\u2016 := ?_\n  _ < _ := ?_",
          "proofState": 628,
          "pos": {
            "line": 925,
            "column": 4
          },
          "goals": "no goals",
          "endPos": {
            "line": 927,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Real",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "congrArg",
            "Hurwitz.instMul",
            "NormedDivisionRing.toNormedRing",
            "NormedRing.toNonUnitalNormedRing",
            "id",
            "Hurwitz.toQuaternion_mul",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Hurwitz.toQuaternion",
            "Hurwitz",
            "Distrib.toMul",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "NormedRing.toSeminormedRing",
            "Real.instNeg",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "NonUnitalNormedRing.toNonUnitalSeminormedRing",
            "Eq",
            "Quaternion.instRing",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "rw [toQuaternion_mul]",
          "proofState": 629,
          "pos": {
            "line": 928,
            "column": 4
          },
          "goals": "case intro.refine_2.calc_1\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 dist a.toQuaternion (q * b).toQuaternion = dist (q' * b') (q.toQuaternion * b')",
          "endPos": {
            "line": 928,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "Real",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "NormedDivisionRing.toNormedRing",
            "NormedRing.toNonUnitalNormedRing",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Hurwitz.toQuaternion",
            "Distrib.toMul",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "NormedRing.toSeminormedRing",
            "Real.instNeg",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "NonUnitalNormedRing.toNonUnitalSeminormedRing",
            "Eq",
            "Quaternion.instRing",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "dsimp only [b', q']",
          "proofState": 630,
          "pos": {
            "line": 929,
            "column": 4
          },
          "goals": "case intro.refine_2.calc_1\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 dist a.toQuaternion (q.toQuaternion * b.toQuaternion) = dist (q' * b') (q.toQuaternion * b')",
          "endPos": {
            "line": 929,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Real.instLinearOrderedField",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "div_mul_cancel\u2080",
            "Real",
            "instHDiv",
            "HMul.hMul",
            "GroupWithZero.toDivInvMonoid",
            "Ring.toNonAssocRing",
            "MulZeroClass.toMul",
            "Real.instZero",
            "congrArg",
            "Quaternion.instGroupWithZero",
            "NormedDivisionRing.toNormedRing",
            "NormedRing.toNonUnitalNormedRing",
            "DivisionRing.toDivInvMonoid",
            "id",
            "HDiv.hDiv",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Quaternion.instDivisionRing",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Hurwitz.toQuaternion",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "NormedRing.toSeminormedRing",
            "Real.instNeg",
            "DivInvMonoid.toDiv",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "MulZeroOneClass.toMulZeroClass",
            "NonUnitalNormedRing.toNonUnitalSeminormedRing",
            "Eq",
            "Quaternion.instRing",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "rw [div_mul_cancel\u2080 a' hb']",
          "proofState": 631,
          "pos": {
            "line": 930,
            "column": 4
          },
          "goals": "case intro.refine_2.calc_1\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 dist a.toQuaternion (q.toQuaternion * b.toQuaternion) =\n    dist (a' / b.toQuaternion * b.toQuaternion) (q.toQuaternion * b.toQuaternion)",
          "endPos": {
            "line": 930,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "Eq.mpr",
            "Real",
            "SeminormedAddGroup.toAddGroup",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "Real.instZero",
            "congrArg",
            "NormedDivisionRing.toNorm",
            "NormedDivisionRing.toNormedRing",
            "HSub.hSub",
            "NormedRing.toNonUnitalNormedRing",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Real.commRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Real.instOne",
            "SubNegMonoid.toSub",
            "Quaternion.instNormedDivisionRingReal",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Hurwitz.toQuaternion",
            "dist_eq_norm_sub'",
            "instHSub",
            "AddGroup.toSubNegMonoid",
            "Distrib.toMul",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "Real.instMul",
            "NormedRing.toSeminormedRing",
            "Real.instNeg",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "NonUnitalNormedRing.toNonUnitalSeminormedRing",
            "Eq",
            "Quaternion.instRing",
            "Quaternion",
            "instHMul"
          ],
          "tactic": "rw [dist_eq_norm_sub', \u2190 sub_mul, _root_.norm_mul, \u2190 dist_eq_norm_sub']",
          "proofState": 632,
          "pos": {
            "line": 932,
            "column": 4
          },
          "goals": "case intro.refine_2.calc_2\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 dist (q' * b') (q.toQuaternion * b') = dist q' q.toQuaternion * \u2016b'\u2016",
          "endPos": {
            "line": 932,
            "column": 75
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [\u2190 norm_pos_iff] at hb'",
          "proofState": 633,
          "pos": {
            "line": 933,
            "column": 4
          },
          "goals": "case intro.refine_2.calc_3\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : b' \u2260 0\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 dist q' q.toQuaternion * \u2016b'\u2016 < \u2016b.toQuaternion\u2016",
          "endPos": {
            "line": 933,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "Real.strictOrderedSemiring",
            "Norm.norm",
            "Real",
            "Real.instZero",
            "NormedDivisionRing.toNorm",
            "NormedDivisionRing.toNormedRing",
            "Real.semiring",
            "NonAssocSemiring.toMulZeroOneClass",
            "MulZeroOneClass.toMulOneClass",
            "StrictOrderedSemiring.toMulPosStrictMono",
            "Real.instOne",
            "Quaternion.instNormedDivisionRingReal",
            "Hurwitz.toQuaternion",
            "NormedRing.toSeminormedRing",
            "Real.instNeg",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "Semiring.toNonAssocSemiring",
            "Real.instPreorder",
            "mul_lt_of_lt_one_left",
            "Quaternion"
          ],
          "tactic": "exact mul_lt_of_lt_one_left hb' hq",
          "proofState": 634,
          "pos": {
            "line": 934,
            "column": 4
          },
          "goals": "case intro.refine_2.calc_3\na b : \ud835\udcde\nhb : b \u2260 0\na' : \u210d := a.toQuaternion\nb' : \u210d := b.toQuaternion\nhb' : 0 < \u2016b'\u2016\nq' : \u210d := a' / b'\nq : \ud835\udcde\nhq : dist q' q.toQuaternion < 1\n\u22a2 dist q' q.toQuaternion * \u2016b'\u2016 < \u2016b.toQuaternion\u2016",
          "endPos": {
            "line": 934,
            "column": 38
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Classical.propDecidable",
            "Exists",
            "Set.instSingletonSet",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Bot.bot",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "dite",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "Hurwitz",
            "Submodule.span",
            "Singleton.singleton",
            "Ring.toSemiring",
            "Eq",
            "Not",
            "Set"
          ],
          "tactic": "by_cases h_bot : I = \u22a5",
          "proofState": 635,
          "pos": {
            "line": 937,
            "column": 2
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\n\u22a2 \u2203 a, I = Submodule.span \ud835\udcde {a}",
          "endPos": {
            "line": 937,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use 0",
          "proofState": 636,
          "pos": {
            "line": 938,
            "column": 4
          },
          "goals": "case pos\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : I = \u22a5\n\u22a2 \u2203 a, I = Submodule.span \ud835\udcde {a}",
          "endPos": {
            "line": 938,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.instZero",
            "Set.instSingletonSet",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Hurwitz",
            "propext",
            "Submodule.span",
            "Eq.comm",
            "Zero.toOfNat0",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Ring.toSemiring",
            "Eq",
            "Set"
          ],
          "tactic": "rw [Eq.comm]",
          "proofState": 637,
          "pos": {
            "line": 939,
            "column": 4
          },
          "goals": "case h\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : I = \u22a5\n\u22a2 I = Submodule.span \ud835\udcde {0}",
          "endPos": {
            "line": 939,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "Set.instSingletonSet",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Bot.bot",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "Hurwitz",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "Submodule.span",
            "of_eq_true",
            "Zero.toOfNat0",
            "AddCommMonoid.toAddMonoid",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Ring.toSemiring",
            "Eq",
            "_auxLemma.38",
            "Eq.trans",
            "Set"
          ],
          "tactic": "simp only [h_bot, Submodule.span_singleton_eq_bot]",
          "proofState": 638,
          "pos": {
            "line": 940,
            "column": 4
          },
          "goals": "case h\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : I = \u22a5\n\u22a2 Submodule.span \ud835\udcde {0} = I",
          "endPos": {
            "line": 940,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Hurwitz.instZero",
            "Membership.mem",
            "Subtype",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Ring.toSemiring",
            "SetLike.instMembership"
          ],
          "tactic": "let S := { a : \ud835\udcde // a \u2208 I \u2227 a \u2260 0 }",
          "proofState": 639,
          "pos": {
            "line": 941,
            "column": 2
          },
          "goals": "case neg\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\n\u22a2 \u2203 a, I = Submodule.span \ud835\udcde {a}",
          "endPos": {
            "line": 941,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Exists",
            "Set.instSingletonSet",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Hurwitz",
            "Submodule.span",
            "Nonempty",
            "Singleton.singleton",
            "Ring.toSemiring",
            "Eq",
            "letFun",
            "Set"
          ],
          "tactic": "have : Nonempty S := by\n  simp [S, ne_eq, norm_eq_zero]\n  exact Submodule.exists_mem_ne_zero_of_ne_bot h_bot",
          "proofState": 640,
          "pos": {
            "line": 942,
            "column": 2
          },
          "goals": "case neg\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\n\u22a2 \u2203 a, I = Submodule.span \ud835\udcde {a}",
          "endPos": {
            "line": 944,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Hurwitz.instZero",
            "Membership.mem",
            "Exists",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "Submodule.setLike",
            "Nonempty",
            "Zero.toOfNat0",
            "Mathlib.Logic.Nonempty._auxLemma.4",
            "OfNat.ofNat",
            "Ring.toSemiring",
            "Eq",
            "Not",
            "SetLike.instMembership"
          ],
          "tactic": "simp [S, ne_eq, norm_eq_zero]",
          "proofState": 641,
          "pos": {
            "line": 943,
            "column": 4
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\n\u22a2 Nonempty S",
          "endPos": {
            "line": 943,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Submodule.exists_mem_ne_zero_of_ne_bot",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Hurwitz",
            "Ring.toSemiring"
          ],
          "tactic": "exact Submodule.exists_mem_ne_zero_of_ne_bot h_bot",
          "proofState": 642,
          "pos": {
            "line": 944,
            "column": 4
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\n\u22a2 \u2203 a \u2208 I, \u00aca = 0",
          "endPos": {
            "line": 944,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Hurwitz.instZero",
            "Membership.mem",
            "Exists",
            "Set.instSingletonSet",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "Int",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "Hurwitz.norm",
            "Submodule.setLike",
            "BddBelow",
            "Submodule.span",
            "Zero.toOfNat0",
            "Set.range",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "letFun",
            "Int.instLEInt",
            "Set"
          ],
          "tactic": "have hbdd : BddBelow <| Set.range (fun i : S \u21a6 norm i) :=\n  by\n  use 0\n  simp only [ne_eq, mem_lowerBounds, Set.mem_range]\n  rintro _ \u27e8_, rfl\u27e9\n  exact norm_nonneg _",
          "proofState": 643,
          "pos": {
            "line": 945,
            "column": 2
          },
          "goals": "case neg\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\n\u22a2 \u2203 a, I = Submodule.span \ud835\udcde {a}",
          "endPos": {
            "line": 949,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use 0",
          "proofState": 644,
          "pos": {
            "line": 946,
            "column": 4
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\n\u22a2 BddBelow (Set.range fun i => (\u2191i).norm)",
          "endPos": {
            "line": 946,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "_auxLemma.41",
            "Eq.mpr",
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "lowerBounds",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Hurwitz.instZero",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "Membership.mem",
            "Exists",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Int",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "instOfNat",
            "implies_congr",
            "Hurwitz.norm",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "Eq.refl",
            "Set.range",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "Set.instMembership",
            "OrderedAddCommGroup.toPartialOrder",
            "Not",
            "_auxLemma.40",
            "SetLike.instMembership",
            "Eq.trans",
            "forall_congr",
            "Set"
          ],
          "tactic": "simp only [ne_eq, mem_lowerBounds, Set.mem_range]",
          "proofState": 645,
          "pos": {
            "line": 947,
            "column": 4
          },
          "goals": "case h\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\n\u22a2 0 \u2208 lowerBounds (Set.range fun i => (\u2191i).norm)",
          "endPos": {
            "line": 947,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Int"
          ],
          "tactic": "rintro _ \u27e8_, rfl\u27e9",
          "proofState": 646,
          "pos": {
            "line": 948,
            "column": 4
          },
          "goals": "case h\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\n\u22a2 \u2200 (x : \u2124), (\u2203 y, (\u2191y).norm = x) \u2192 0 \u2264 x",
          "endPos": {
            "line": 948,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Hurwitz.instZero",
            "Membership.mem",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Subtype.val",
            "Hurwitz.norm_nonneg",
            "Ring.toSemiring",
            "Eq",
            "Not",
            "SetLike.instMembership"
          ],
          "tactic": "exact norm_nonneg _",
          "proofState": 647,
          "pos": {
            "line": 949,
            "column": 4
          },
          "goals": "case h.intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nw\u271d : S\n\u22a2 0 \u2264 (\u2191w\u271d).norm",
          "endPos": {
            "line": 949,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Order.not_isPredPrelimit",
            "exists_eq_ciInf_of_not_isPredPrelimit"
          ],
          "tactic": "obtain \u27e8a, ha\u27e9 : \u2203 a : S, norm a = \u2a05 i : S, norm i :=\n  exists_eq_ciInf_of_not_isPredPrelimit hbdd (Order.not_isPredPrelimit)",
          "proofState": 648,
          "pos": {
            "line": 950,
            "column": 2
          },
          "goals": "case neg\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\n\u22a2 \u2203 a, I = Submodule.span \ud835\udcde {a}",
          "endPos": {
            "line": 951,
            "column": 73
          }
        },
        {
          "usedConstants": [
            "Exists.intro"
          ],
          "tactic": "use a",
          "proofState": 649,
          "pos": {
            "line": 952,
            "column": 2
          },
          "goals": "case neg.intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\n\u22a2 \u2203 a, I = Submodule.span \ud835\udcde {a}",
          "endPos": {
            "line": 952,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "le_antisymm"
          ],
          "tactic": "apply le_antisymm",
          "proofState": 650,
          "pos": {
            "line": 953,
            "column": 2
          },
          "goals": "case h\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\n\u22a2 I = Submodule.span \ud835\udcde {\u2191a}",
          "endPos": {
            "line": 953,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "Hurwitz"
          ],
          "tactic": "intro i hi",
          "proofState": 651,
          "pos": {
            "line": 954,
            "column": 4
          },
          "goals": "case h.a\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\n\u22a2 I \u2264 Submodule.span \ud835\udcde {\u2191a}",
          "endPos": {
            "line": 954,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "congrArg",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "Submodule.mem_span_singleton",
            "Exists",
            "Set.instSingletonSet",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "MonoidWithZero.toMulZeroOneClass",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "propext",
            "Submodule.span",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Singleton.singleton",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero",
            "Set"
          ],
          "tactic": "rw [Submodule.mem_span_singleton]",
          "proofState": 652,
          "pos": {
            "line": 955,
            "column": 4
          },
          "goals": "case h.a\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\n\u22a2 i \u2208 Submodule.span \ud835\udcde {\u2191a}",
          "endPos": {
            "line": 955,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "Exists",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "MonoidWithZero.toMulZeroOneClass",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp only [ne_eq]",
          "proofState": 653,
          "pos": {
            "line": 956,
            "column": 4
          },
          "goals": "case h.a\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\n\u22a2 \u2203 a_1, a_1 \u2022 \u2191a = i",
          "endPos": {
            "line": 956,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Hurwitz.instZero",
            "Membership.mem",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "And.right",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "SetLike.instMembership",
            "Subtype.property",
            "Hurwitz.quot_rem"
          ],
          "tactic": "obtain \u27e8q, r, hqr\u27e9 := quot_rem i a a.2.2",
          "proofState": 654,
          "pos": {
            "line": 957,
            "column": 4
          },
          "goals": "case h.a\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\n\u22a2 \u2203 a_1, a_1 \u2022 \u2191a = i",
          "endPos": {
            "line": 957,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "ConditionallyCompleteLattice.toInfSet",
            "Submodule",
            "Hurwitz.ring",
            "iInf",
            "Semiring.toModule",
            "HMul.hMul",
            "instConditionallyCompleteLinearOrder",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.instMul",
            "Hurwitz.instAdd",
            "Hurwitz.instZero",
            "Membership.mem",
            "Eq.mp",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "Int",
            "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Int.instLTInt",
            "instHAdd",
            "And",
            "Hurwitz",
            "HAdd.hAdd",
            "Hurwitz.norm",
            "Submodule.setLike",
            "LT.lt",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "instHMul"
          ],
          "tactic": "rw [ha] at hqr",
          "proofState": 655,
          "pos": {
            "line": 958,
            "column": 4
          },
          "goals": "case h.a.intro.intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < (\u2191a).norm\n\u22a2 \u2203 a_1, a_1 \u2022 \u2191a = i",
          "endPos": {
            "line": 958,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "Exists",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "MonoidWithZero.toMulZeroOneClass",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "Not",
            "SetLike.instMembership",
            "letFun",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have hrI : r \u2208 I :=\n  by\n  rw [show r = i - q \u2022 a by apply eq_sub_of_add_eq; rw [add_comm]; exact hqr.1.symm]\n  apply I.sub_mem hi (I.smul_mem _ a.2.1)",
          "proofState": 656,
          "pos": {
            "line": 959,
            "column": 4
          },
          "goals": "case h.a.intro.intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\n\u22a2 \u2203 a_1, a_1 \u2022 \u2191a = i",
          "endPos": {
            "line": 961,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "congrArg",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "HSub.hSub",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Membership.mem",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "instHSub",
            "Hurwitz",
            "MulZeroClass.toSMulWithZero",
            "Submodule.setLike",
            "Hurwitz.instSub",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "letFun",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [show r = i - q \u2022 a by apply eq_sub_of_add_eq; rw [add_comm]; exact hqr.1.symm]",
          "proofState": 657,
          "pos": {
            "line": 960,
            "column": 6
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\n\u22a2 r \u2208 I",
          "endPos": {
            "line": 960,
            "column": 89
          }
        },
        {
          "usedConstants": [
            "eq_sub_of_add_eq"
          ],
          "tactic": "apply eq_sub_of_add_eq",
          "proofState": 658,
          "pos": {
            "line": 960,
            "column": 32
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\n\u22a2 r = i - q \u2022 \u2191a",
          "endPos": {
            "line": 960,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "congrArg",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Membership.mem",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "add_comm",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "And",
            "Hurwitz",
            "AddGroup.toSubNegMonoid",
            "HAdd.hAdd",
            "MulZeroClass.toSMulWithZero",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommSemigroup.toAddCommMagma",
            "SubNegMonoid.toAddMonoid",
            "OfNat.ofNat",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "AddZeroClass.toAdd",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd"
          ],
          "tactic": "rw [add_comm]",
          "proofState": 659,
          "pos": {
            "line": 960,
            "column": 56
          },
          "goals": "case h\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\n\u22a2 r + q \u2022 \u2191a = i",
          "endPos": {
            "line": 960,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "ConditionallyCompleteLattice.toInfSet",
            "Submodule",
            "Hurwitz.ring",
            "iInf",
            "Semiring.toModule",
            "HMul.hMul",
            "instConditionallyCompleteLinearOrder",
            "Ring.toNonAssocRing",
            "Hurwitz.instMul",
            "Hurwitz.instAdd",
            "Hurwitz.instZero",
            "Membership.mem",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "Int",
            "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Int.instLTInt",
            "instHAdd",
            "And",
            "Hurwitz",
            "And.left",
            "HAdd.hAdd",
            "Hurwitz.norm",
            "Submodule.setLike",
            "LT.lt",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq.symm",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "instHMul"
          ],
          "tactic": "exact hqr.1.symm",
          "proofState": 660,
          "pos": {
            "line": 960,
            "column": 71
          },
          "goals": "case h\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\n\u22a2 q \u2022 \u2191a + r = i",
          "endPos": {
            "line": 960,
            "column": 87
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "MonoidWithZero.toMulZeroOneClass",
            "And.left",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "Ring.toSemiring",
            "SetLike.instMembership",
            "Submodule.sub_mem",
            "Submodule.smul_mem",
            "MulZeroClass.toZero",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "apply I.sub_mem hi (I.smul_mem _ a.2.1)",
          "proofState": 661,
          "pos": {
            "line": 961,
            "column": 6
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\n\u22a2 i - q \u2022 \u2191a \u2208 I",
          "endPos": {
            "line": 961,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "Exists",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "MonoidWithZero.toMulZeroOneClass",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "Not",
            "SetLike.instMembership",
            "letFun",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have hr : r = 0 := by\n  by_contra hr\n  lift r to S using \u27e8hrI, hr\u27e9\n  apply (ciInf_le hbdd r).not_lt hqr.2",
          "proofState": 662,
          "pos": {
            "line": 962,
            "column": 4
          },
          "goals": "case h.a.intro.intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\nhrI : r \u2208 I\n\u22a2 \u2203 a_1, a_1 \u2022 \u2191a = i",
          "endPos": {
            "line": 965,
            "column": 42
          }
        },
        {
          "usedConstants": [
            "Hurwitz.instZero",
            "Classical.byContradiction",
            "Hurwitz",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Eq",
            "Not"
          ],
          "tactic": "by_contra hr",
          "proofState": 663,
          "pos": {
            "line": 963,
            "column": 6
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\nhrI : r \u2208 I\n\u22a2 r = 0",
          "endPos": {
            "line": 963,
            "column": 18
          }
        },
        {
          "usedConstants": [],
          "tactic": "lift r to S using \u27e8hrI, hr\u27e9",
          "proofState": 664,
          "pos": {
            "line": 964,
            "column": 6
          },
          "goals": "I : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\nhrI : r \u2208 I\nhr : \u00acr = 0\n\u22a2 False",
          "endPos": {
            "line": 964,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "ConditionallyCompleteLattice.toInfSet",
            "Submodule",
            "Hurwitz.ring",
            "iInf",
            "Semiring.toModule",
            "HMul.hMul",
            "instConditionallyCompleteLinearOrder",
            "Ring.toNonAssocRing",
            "Hurwitz.instMul",
            "Hurwitz.instAdd",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Hurwitz.instZero",
            "PartialOrder.toPreorder",
            "Membership.mem",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "Int",
            "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
            "LinearOrderedRing.toStrictOrderedRing",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Int.instLTInt",
            "instHAdd",
            "And",
            "Hurwitz",
            "And.right",
            "HAdd.hAdd",
            "ciInf_le",
            "Hurwitz.norm",
            "Submodule.setLike",
            "LT.lt",
            "Zero.toOfNat0",
            "LE.le.not_lt",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "OrderedAddCommGroup.toPartialOrder",
            "SetLike.instMembership",
            "instHMul"
          ],
          "tactic": "apply (ciInf_le hbdd r).not_lt hqr.2",
          "proofState": 665,
          "pos": {
            "line": 965,
            "column": 6
          },
          "goals": "case intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq : \ud835\udcde\nr : { x // x \u2208 I \u2227 x \u2260 0 }\nhqr : i = q * \u2191a + \u2191r \u2227 (\u2191r).norm < \u2a05 i, (\u2191i).norm\nhrI : \u2191r \u2208 I\nhr : \u00ac\u2191r = 0\n\u22a2 False",
          "endPos": {
            "line": 965,
            "column": 42
          }
        },
        {
          "usedConstants": [],
          "tactic": "rw [hr, add_zero] at hqr",
          "proofState": 666,
          "pos": {
            "line": 966,
            "column": 4
          },
          "goals": "case h.a.intro.intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a + r \u2227 r.norm < \u2a05 i, (\u2191i).norm\nhrI : r \u2208 I\nhr : r = 0\n\u22a2 \u2203 a_1, a_1 \u2022 \u2191a = i",
          "endPos": {
            "line": 966,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "ConditionallyCompleteLattice.toInfSet",
            "Submodule",
            "instHSMul",
            "Hurwitz.ring",
            "iInf",
            "Semiring.toModule",
            "HMul.hMul",
            "instConditionallyCompleteLinearOrder",
            "Ring.toNonAssocRing",
            "Hurwitz.instMul",
            "SMulWithZero.toSMulZeroClass",
            "Hurwitz.instZero",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Membership.mem",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "Int",
            "ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Int.instLTInt",
            "And",
            "Hurwitz",
            "MonoidWithZero.toMulZeroOneClass",
            "And.left",
            "Hurwitz.norm",
            "AddZeroClass.toZero",
            "Submodule.setLike",
            "LT.lt",
            "Exists.intro",
            "Zero.toOfNat0",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Eq.symm",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "Not",
            "SetLike.instMembership",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "refine \u27e8q, hqr.1.symm\u27e9",
          "proofState": 667,
          "pos": {
            "line": 967,
            "column": 4
          },
          "goals": "case h.a.intro.intro\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\ni : \ud835\udcde\nhi : i \u2208 I\nq r : \ud835\udcde\nhqr : i = q * \u2191a \u2227 norm 0 < \u2a05 i, (\u2191i).norm\nhrI : r \u2208 I\nhr : r = 0\n\u22a2 \u2203 a_1, a_1 \u2022 \u2191a = i",
          "endPos": {
            "line": 967,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "congrArg",
            "Hurwitz.instZero",
            "Submodule.completeLattice",
            "PartialOrder.toPreorder",
            "Preorder.toLE",
            "Membership.mem",
            "Set.instSingletonSet",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "LE.le",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CompleteLattice.toCompleteSemilatticeInf",
            "CompleteSemilatticeInf.toPartialOrder",
            "And",
            "Hurwitz",
            "Submodule.setLike",
            "propext",
            "Submodule.span",
            "Zero.toOfNat0",
            "Submodule.span_singleton_le_iff_mem",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "Eq",
            "SetLike.instMembership",
            "Set"
          ],
          "tactic": "rw [Submodule.span_singleton_le_iff_mem]",
          "proofState": 668,
          "pos": {
            "line": 968,
            "column": 4
          },
          "goals": "case h.a\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\n\u22a2 Submodule.span \ud835\udcde {\u2191a} \u2264 I",
          "endPos": {
            "line": 968,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Submodule",
            "Hurwitz.ring",
            "Semiring.toModule",
            "Ring.toNonAssocRing",
            "Hurwitz.instZero",
            "Membership.mem",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Ne",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "And",
            "Hurwitz",
            "And.left",
            "Submodule.setLike",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "Subtype.val",
            "Ring.toSemiring",
            "SetLike.instMembership",
            "Subtype.property"
          ],
          "tactic": "exact a.2.1",
          "proofState": 669,
          "pos": {
            "line": 969,
            "column": 4
          },
          "goals": "case h.a\nI : Submodule \ud835\udcde \ud835\udcde\nh_bot : \u00acI = \u22a5\nS : Type := { a // a \u2208 I \u2227 a \u2260 0 }\nthis : Nonempty S\nhbdd : BddBelow (Set.range fun i => (\u2191i).norm)\na : S\nha : (\u2191a).norm = \u2a05 i, (\u2191i).norm\n\u22a2 \u2191a \u2208 I",
          "endPos": {
            "line": 969,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Rat.addCommMonoid",
            "PNat.val",
            "Hurwitz.ring",
            "Hurwitz.instRingHurwitzHat",
            "HMul.hMul",
            "Ring.toNonAssocRing",
            "AlgHom",
            "AlgHom.funLike",
            "Rat",
            "Exists",
            "sorryAx",
            "Hurwitz.j\u2082",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "Hurwitz.HurwitzHat",
            "instOfNatNat",
            "Int",
            "Lean.Name.num",
            "Nat.cast",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Lean.Name.str",
            "Hurwitz.instRingHurwitzRatHat",
            "Lean.Name.anonymous",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Inv.inv",
            "Hurwitz",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "Nat",
            "Rat.instInv",
            "Ring.toIntAlgebra",
            "Hurwitz.HurwitzRat",
            "Hurwitz.instRingHurwitzRat",
            "AddCommGroup.toIntModule",
            "One.toOfNat1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Lean.Name",
            "TensorProduct.tmul",
            "Hurwitz.j\u2081",
            "Int.instCommSemiring",
            "OfNat.ofNat",
            "Bool.false",
            "Ring.toSemiring",
            "Eq",
            "Hurwitz.HurwitzRatHat",
            "DFunLike.coe",
            "Hurwitz.instOne",
            "Rat.addCommGroup",
            "Rat.instNatCast",
            "instHMul",
            "PNat"
          ],
          "tactic": "sorry",
          "proofState": 670,
          "pos": {
            "line": 1005,
            "column": 2
          },
          "goals": "z : D^\n\u22a2 \u2203 N z', z = j\u2081 ((\u2191\u2191N)\u207b\u00b9 \u2297\u209c[\u2124] 1) * j\u2082 z'",
          "endPos": {
            "line": 1005,
            "column": 7
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 307,
            "column": 28
          },
          "goal": "x : QHat\n\u22a2 (\u2203 N z, IsCoprime N z \u2227 x = (1 / \u2191\u2191N) \u2297\u209c[\u2124] z) \u2227\n    \u2200 (N\u2081 N\u2082 : \u2115+) (z\u2081 z\u2082 : ZHat),\n      IsCoprime N\u2081 z\u2081 \u2227 IsCoprime N\u2082 z\u2082 \u2227 (1 / \u2191\u2191N\u2081) \u2297\u209c[\u2124] z\u2081 = (1 / \u2191\u2191N\u2082) \u2297\u209c[\u2124] z\u2082 \u2192 N\u2081 = N\u2082 \u2227 z\u2081 = z\u2082",
          "endPos": {
            "line": 307,
            "column": 33
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 411,
            "column": 74
          },
          "goal": "\u22a2 unitsratsub \u2293 unitszHatsub = unitszsub",
          "endPos": {
            "line": 411,
            "column": 79
          }
        },
        {
          "proofState": 2,
          "pos": {
            "line": 414,
            "column": 66
          },
          "goal": "\u22a2 unitsratsub \u2294 unitszHatsub = \u22a4",
          "endPos": {
            "line": 414,
            "column": 71
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 994,
            "column": 29
          },
          "goal": "\u22a2 Function.Injective \u21d1j\u2081",
          "endPos": {
            "line": 994,
            "column": 34
          }
        },
        {
          "proofState": 4,
          "pos": {
            "line": 1001,
            "column": 29
          },
          "goal": "\u22a2 Function.Injective \u21d1j\u2082",
          "endPos": {
            "line": 1001,
            "column": 34
          }
        },
        {
          "proofState": 5,
          "pos": {
            "line": 1005,
            "column": 2
          },
          "goal": "z : D^\n\u22a2 \u2203 N z', z = j\u2081 ((\u2191\u2191N)\u207b\u00b9 \u2297\u209c[\u2124] 1) * j\u2082 z'",
          "endPos": {
            "line": 1005,
            "column": 7
          }
        },
        {
          "proofState": 6,
          "pos": {
            "line": 1007,
            "column": 82
          },
          "goal": "z : D^\u02e3\n\u22a2 \u2203 u v, \u2191z = j\u2081 \u2191u * j\u2082 \u2191v",
          "endPos": {
            "line": 1007,
            "column": 87
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 304,
            "column": 6
          },
          "endPos": {
            "line": 304,
            "column": 17
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 411,
            "column": 6
          },
          "endPos": {
            "line": 411,
            "column": 29
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 414,
            "column": 6
          },
          "endPos": {
            "line": 414,
            "column": 29
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 993,
            "column": 6
          },
          "endPos": {
            "line": 993,
            "column": 20
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 1000,
            "column": 6
          },
          "endPos": {
            "line": 1000,
            "column": 20
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 1004,
            "column": 6
          },
          "endPos": {
            "line": 1004,
            "column": 19
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 1007,
            "column": 6
          },
          "endPos": {
            "line": 1007,
            "column": 21
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/Mathlib/Topology/Algebra/Module/ModuleTopology.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Prod",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "letFun",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "classical\n  -- far too long proof that a bilinear map bil : R^n x B -> C\n    -- equals the function sending (f,b) to \u2211 i, f(i)*bil(e\u1d62,b)\nhave foo :\n  (fun fb \u21a6 bil fb.1 fb.2 : ((\u03b9 \u2192 R) \u00d7 B \u2192 C)) = (fun fb \u21a6 \u2211\u1da0 i, ((fb.1 i) \u2022 (bil (Pi.single i 1) fb.2) : C)) :=\n  by\n  ext \u27e8f, b\u27e9\n  simp_rw [\u2190 LinearMap.smul_apply]\n  rw [\u2190 LinearMap.finsum_apply]\n  congr\n  simp_rw [LinearMap.smul_apply, \u2190 LinearMap.map_smul]\n  convert AddMonoidHom.map_finsum bil.toAddMonoidHom _\n  \u00b7 ext j\n    simp_rw [\u2190 Pi.single_smul, smul_eq_mul, mul_one]\n    symm\n      -- Is there a missing delaborator? No \u2211\u1da0 notation\n    change (\u2211\u1da0 (i : \u03b9), Pi.single i (f i)) j = f j\n    rw [finsum_apply (Set.toFinite _)]\n    convert finsum_eq_single (fun i \u21a6 Pi.single i (f i) j) j (by simp (config := { contextual := true })) using 1\n    simp\n  \u00b7\n    apply\n      Set.toFinite\n        _\n          --(Function.support fun x \u21a6 f x \u2022 Pi.single x 1)\nrw [foo]\nhaveI : ContinuousAdd C := toContinuousAdd R C\nexact continuous_finsum (fun i \u21a6 by fun_prop) (locallyFinite_of_finite _)",
          "proofState": 2,
          "pos": {
            "line": 26,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 50,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Prod",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "letFun",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have foo :\n  (fun fb \u21a6 bil fb.1 fb.2 : ((\u03b9 \u2192 R) \u00d7 B \u2192 C)) = (fun fb \u21a6 \u2211\u1da0 i, ((fb.1 i) \u2022 (bil (Pi.single i 1) fb.2) : C)) :=\n  by\n  ext \u27e8f, b\u27e9\n  simp_rw [\u2190 LinearMap.smul_apply]\n  rw [\u2190 LinearMap.finsum_apply]\n  congr\n  simp_rw [LinearMap.smul_apply, \u2190 LinearMap.map_smul]\n  convert AddMonoidHom.map_finsum bil.toAddMonoidHom _\n  \u00b7 ext j\n    simp_rw [\u2190 Pi.single_smul, smul_eq_mul, mul_one]\n    symm\n      -- Is there a missing delaborator? No \u2211\u1da0 notation\n    change (\u2211\u1da0 (i : \u03b9), Pi.single i (f i)) j = f j\n    rw [finsum_apply (Set.toFinite _)]\n    convert finsum_eq_single (fun i \u21a6 Pi.single i (f i) j) j (by simp (config := { contextual := true })) using 1\n    simp\n  \u00b7\n    apply\n      Set.toFinite\n        _\n          --(Function.support fun x \u21a6 f x \u2022 Pi.single x 1)",
          "proofState": 3,
          "pos": {
            "line": 29,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 47,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext \u27e8f, b\u27e9",
          "proofState": 4,
          "pos": {
            "line": 31,
            "column": 4
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\n\u22a2 (fun fb => (bil fb.1) fb.2) = fun fb => \u2211\u1da0 (i : \u03b9), fb.1 i \u2022 (bil (Pi.single i 1)) fb.2",
          "endPos": {
            "line": 31,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "Prod.mk",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_rw [\u2190 LinearMap.smul_apply]",
          "proofState": 5,
          "pos": {
            "line": 32,
            "column": 4
          },
          "goals": "case h.mk\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\n\u22a2 (bil (f, b).1) (f, b).2 = \u2211\u1da0 (i : \u03b9), (f, b).1 i \u2022 (bil (Pi.single i 1)) (f, b).2",
          "endPos": {
            "line": 32,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "LinearMap.finsum_apply",
            "instHSMul",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "LinearMap.instSMulCommClass",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "LinearMap.instDistribMulAction",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "LinearMap.instSMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "AddCommMonoid.toAddMonoid",
            "OfNat.ofNat",
            "Eq.symm",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [\u2190 LinearMap.finsum_apply]",
          "proofState": 6,
          "pos": {
            "line": 33,
            "column": 4
          },
          "goals": "case h.mk\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\n\u22a2 (bil f) b = \u2211\u1da0 (i : \u03b9), ((f i \u2022 bil) (Pi.single i 1)) b",
          "endPos": {
            "line": 33,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "Eq.rec",
            "DFunLike",
            "Eq.refl",
            "Eq",
            "DFunLike.coe"
          ],
          "tactic": "congr",
          "proofState": 7,
          "pos": {
            "line": 34,
            "column": 4
          },
          "goals": "case h.mk\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\n\u22a2 (bil f) b = (\u2211\u1da0 (i : \u03b9), (f i \u2022 bil) (Pi.single i 1)) b",
          "endPos": {
            "line": 34,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "id",
            "Eq"
          ],
          "tactic": "simp_rw [LinearMap.smul_apply, \u2190 LinearMap.map_smul]",
          "proofState": 8,
          "pos": {
            "line": 35,
            "column": 4
          },
          "goals": "case h.mk.e_a\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\n\u22a2 bil f = \u2211\u1da0 (i : \u03b9), (f i \u2022 bil) (Pi.single i 1)",
          "endPos": {
            "line": 35,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "LinearMap.toAddMonoidHom",
            "Eq.mpr",
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "AddMonoidHom.map_finsum",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "AddMonoidHom",
            "AddMonoidHom.instFunLike",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "convert AddMonoidHom.map_finsum bil.toAddMonoidHom _",
          "proofState": 9,
          "pos": {
            "line": 36,
            "column": 4
          },
          "goals": "case h.mk.e_a\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\n\u22a2 bil f = \u2211\u1da0 (i : \u03b9), bil (f i \u2022 Pi.single i 1)",
          "endPos": {
            "line": 36,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext j",
          "proofState": 10,
          "pos": {
            "line": 37,
            "column": 6
          },
          "goals": "case h.e'_2.h.e'_1\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\n\u22a2 f = \u2211\u1da0 (i : \u03b9), f i \u2022 Pi.single i 1",
          "endPos": {
            "line": 37,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "DistribMulAction.toDistribSMul",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "Classical.propDecidable",
            "id",
            "DistribSMul.toSMulZeroClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "funext",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "Pi.instSMul",
            "One.toOfNat1",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "SMulZeroClass.toSMul",
            "AddMonoidWithOne.toAddMonoid",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MonoidWithZero.toMonoid",
            "_auxLemma.3",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_rw [\u2190 Pi.single_smul, smul_eq_mul, mul_one]",
          "proofState": 11,
          "pos": {
            "line": 38,
            "column": 6
          },
          "goals": "case h.e'_2.h.e'_1.h\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\nj : \u03b9\n\u22a2 f j = (\u2211\u1da0 (i : \u03b9), f i \u2022 Pi.single i 1) j",
          "endPos": {
            "line": 38,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Eq.symm"
          ],
          "tactic": "symm\n  -- Is there a missing delaborator? No \u2211\u1da0 notation",
          "proofState": 12,
          "pos": {
            "line": 39,
            "column": 6
          },
          "goals": "case h.e'_2.h.e'_1.h\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\nj : \u03b9\n\u22a2 f j = (\u2211\u1da0 (i : \u03b9), Pi.single i (f i)) j",
          "endPos": {
            "line": 39,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "id",
            "Eq"
          ],
          "tactic": "change (\u2211\u1da0 (i : \u03b9), Pi.single i (f i)) j = f j",
          "proofState": 13,
          "pos": {
            "line": 41,
            "column": 6
          },
          "goals": "case h.e'_2.h.e'_1.h\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\nj : \u03b9\n\u22a2 (\u2211\u1da0 (i : \u03b9), Pi.single i (f i)) j = f j",
          "endPos": {
            "line": 41,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.addCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "finsum_apply",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "Pi.instZero",
            "Pi.single",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Set.toFinite",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Function.support",
            "AddZeroClass.toZero",
            "AddCommMonoid.toAddMonoid",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MulZeroClass.toZero"
          ],
          "tactic": "rw [finsum_apply (Set.toFinite _)]",
          "proofState": 14,
          "pos": {
            "line": 43,
            "column": 6
          },
          "goals": "case h.e'_2.h.e'_1.h\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\nj : \u03b9\n\u22a2 (\u2211\u1da0 (i : \u03b9), Pi.single i (f i)) j = f j",
          "endPos": {
            "line": 43,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "False",
            "eq_false",
            "congrArg",
            "CommSemiring.toSemiring",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Pi.single",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Zero.toOfNat0",
            "Eq.refl",
            "AddCommMonoid.toAddMonoid",
            "implies_true",
            "Pi.single_eq_of_ne'",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "finsum_eq_single",
            "implies_congr_ctx",
            "Not",
            "Eq.trans",
            "MulZeroClass.toZero",
            "forall_congr"
          ],
          "tactic": "convert finsum_eq_single (fun i \u21a6 Pi.single i (f i) j) j (by simp (config := { contextual := true })) using 1",
          "proofState": 15,
          "pos": {
            "line": 44,
            "column": 6
          },
          "goals": "case h.e'_2.h.e'_1.h\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\nj : \u03b9\n\u22a2 \u2211\u1da0 (i : \u03b9), Pi.single i (f i) j = f j",
          "endPos": {
            "line": 45,
            "column": 58
          }
        },
        {
          "usedConstants": [
            "False",
            "eq_false",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Pi.single",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "True",
            "eq_self",
            "of_eq_true",
            "Zero.toOfNat0",
            "Eq.refl",
            "AddCommMonoid.toAddMonoid",
            "implies_true",
            "Pi.single_eq_of_ne'",
            "OfNat.ofNat",
            "not_false_eq_true",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "implies_congr_ctx",
            "Not",
            "Eq.trans",
            "MulZeroClass.toZero",
            "forall_congr"
          ],
          "tactic": "simp (config := { contextual := true })",
          "proofState": 16,
          "pos": {
            "line": 45,
            "column": 12
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\nj : \u03b9\n\u22a2 \u2200 (x : \u03b9), x \u2260 j \u2192 (fun i => Pi.single i (f i) j) x = 0",
          "endPos": {
            "line": 45,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "congrArg",
            "CommSemiring.toSemiring",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Pi.single",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "True",
            "eq_self",
            "of_eq_true",
            "Pi.single_eq_same",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Eq.trans",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp",
          "proofState": 17,
          "pos": {
            "line": 46,
            "column": 6
          },
          "goals": "case h.e'_3\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\nj : \u03b9\n\u22a2 f j = Pi.single j (f j) j",
          "endPos": {
            "line": 46,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "Set.toFinite",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Function.support",
            "AddZeroClass.toZero",
            "One.toOfNat1",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "apply\n  Set.toFinite\n    _\n      --(Function.support fun x \u21a6 f x \u2022 Pi.single x 1)",
          "proofState": 18,
          "pos": {
            "line": 47,
            "column": 6
          },
          "goals": "case h.mk.e_a.convert_3\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nf : \u03b9 \u2192 R\nb : B\n\u22a2 (Function.support fun x => f x \u2022 Pi.single x 1).Finite",
          "endPos": {
            "line": 47,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "finsum",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "id",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Prod",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [foo]",
          "proofState": 19,
          "pos": {
            "line": 48,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nfoo : (fun fb => (bil fb.1) fb.2) = fun fb => \u2211\u1da0 (i : \u03b9), fb.1 i \u2022 (bil (Pi.single i 1)) fb.2\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 48,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "IsModuleTopology.toContinuousAdd",
            "MonoidWithZero.toMulZeroOneClass",
            "AddZeroClass.toZero",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "haveI : ContinuousAdd C := toContinuousAdd R C",
          "proofState": 20,
          "pos": {
            "line": 49,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nfoo : (fun fb => (bil fb.1) fb.2) = fun fb => \u2211\u1da0 (i : \u03b9), fb.1 i \u2022 (bil (Pi.single i 1)) fb.2\n\u22a2 Continuous fun fb => \u2211\u1da0 (i : \u03b9), fb.1 i \u2022 (bil (Pi.single i 1)) fb.2",
          "endPos": {
            "line": 49,
            "column": 48
          }
        },
        {
          "usedConstants": [
            "Continuous.comp'",
            "IsModuleTopology.toContinuousSMul",
            "continuous_finsum",
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "Continuous.snd",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "continuous_id'",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "locallyFinite_of_finite",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "IsModuleTopology.continuous_of_linearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "Continuous.smul",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Function.support",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "continuous_apply",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "Continuous.fst",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "Prod",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "exact continuous_finsum (fun i \u21a6 by fun_prop) (locallyFinite_of_finite _)",
          "proofState": 21,
          "pos": {
            "line": 50,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nfoo : (fun fb => (bil fb.1) fb.2) = fun fb => \u2211\u1da0 (i : \u03b9), fb.1 i \u2022 (bil (Pi.single i 1)) fb.2\nthis : ContinuousAdd C\n\u22a2 Continuous fun fb => \u2211\u1da0 (i : \u03b9), fb.1 i \u2022 (bil (Pi.single i 1)) fb.2",
          "endPos": {
            "line": 50,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "Continuous.comp'",
            "IsModuleTopology.toContinuousSMul",
            "Pi.Function.module",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "Continuous.snd",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "continuous_id'",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Pi.single",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "IsModuleTopology.continuous_of_linearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "Continuous.smul",
            "MonoidWithZero.toMulZeroOneClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "continuous_apply",
            "One.toOfNat1",
            "MulActionWithZero.toMulAction",
            "Continuous.fst",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "Prod",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "fun_prop",
          "proofState": 22,
          "pos": {
            "line": 50,
            "column": 38
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u2077 : CommSemiring R\nB : Type u_3\ninst\u271d\u2076 : AddCommMonoid B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommMonoid C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\n\u03b9 : Type u_5\ninst\u271d : Finite \u03b9\nbil : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C\nfoo : (fun fb => (bil fb.1) fb.2) = fun fb => \u2211\u1da0 (i : \u03b9), fb.1 i \u2022 (bil (Pi.single i 1)) fb.2\nthis : ContinuousAdd C\ni : \u03b9\n\u22a2 Continuous fun fb => fb.1 i \u2022 (bil (Pi.single i 1)) fb.2",
          "endPos": {
            "line": 50,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "Module.Free.ChooseBasisIndex"
          ],
          "tactic": "let \u03b9 := Module.Free.ChooseBasisIndex R A",
          "proofState": 23,
          "pos": {
            "line": 55,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 55,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "Module.Free.ChooseBasisIndex.fintype",
            "Fintype"
          ],
          "tactic": "let h\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A",
          "proofState": 24,
          "pos": {
            "line": 56,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 56,
            "column": 64
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "Basis",
            "Module.Free.chooseBasis"
          ],
          "tactic": "let b : Basis \u03b9 R A := Module.Free.chooseBasis R A",
          "proofState": 25,
          "pos": {
            "line": 57,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 57,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "Basis.equivFun",
            "Finite.of_fintype",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "LinearEquiv",
            "RingHom.id",
            "Semiring.toNonAssocSemiring"
          ],
          "tactic": "let elinear : A \u2243\u2097[R] (\u03b9 \u2192 R) := b.equivFun",
          "proofState": 26,
          "pos": {
            "line": 58,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 58,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "LinearEquiv.symm",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "LinearMap.comp",
            "LinearEquiv.toLinearMap",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "RingHom.id",
            "RingHomCompTriple.ids",
            "Semiring.toNonAssocSemiring",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "let bil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil.comp elinear.symm.toLinearMap",
          "proofState": 27,
          "pos": {
            "line": 59,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 59,
            "column": 73
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "IsModuleTopology.Module.continuous_bilinear_of_pi_finite",
            "Finite.of_fintype",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "Prod",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "letFun",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have := Module.continuous_bilinear_of_pi_finite \u03b9 bil'",
          "proofState": 28,
          "pos": {
            "line": 60,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 60,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Function.comp",
            "Prod.mk",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "LinearEquiv",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "DFinsupp.instEquivLikeLinearEquiv",
            "Prod",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "letFun",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have foo :\n  (fun ab \u21a6 (bil ab.1) ab.2 : A \u00d7 B \u2192 C) =\n    (fun fb \u21a6 bil' fb.1 fb.2) \u2218 (fun ab \u21a6 (elinear ab.1, ab.2) : A \u00d7 B \u2192 (\u03b9 \u2192 R) \u00d7 B) :=\n  by\n  ext \u27e8a, b\u27e9\n  simp [bil']",
          "proofState": 29,
          "pos": {
            "line": 61,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 64,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext \u27e8a, b\u27e9",
          "proofState": 30,
          "pos": {
            "line": 63,
            "column": 4
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\n\u22a2 (fun ab => (bil ab.1) ab.2) = (fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2)",
          "endPos": {
            "line": 63,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "LinearEquiv.symm",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LinearEquiv.symm_apply_apply",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "True",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "LinearEquiv",
            "eq_self",
            "of_eq_true",
            "LinearEquiv.instEquivLike",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Eq.trans",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [bil']",
          "proofState": 31,
          "pos": {
            "line": 64,
            "column": 4
          },
          "goals": "case h.mk\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb\u271d : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b\u271d.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\na : A\nb : B\n\u22a2 (bil (a, b).1) (a, b).2 = ((fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2)) (a, b)",
          "endPos": {
            "line": 64,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Function.comp",
            "id",
            "Prod.mk",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "LinearEquiv",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "DFinsupp.instEquivLikeLinearEquiv",
            "Prod",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [foo]",
          "proofState": 32,
          "pos": {
            "line": 65,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\nfoo : (fun ab => (bil ab.1) ab.2) = (fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2)\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 65,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "Continuous.comp",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Prod.mk",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "LinearEquiv",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "DFinsupp.instEquivLikeLinearEquiv",
            "Prod",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "EquivLike.toFunLike",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "apply Continuous.comp this",
          "proofState": 33,
          "pos": {
            "line": 66,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\nfoo : (fun ab => (bil ab.1) ab.2) = (fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2)\n\u22a2 Continuous ((fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2))",
          "endPos": {
            "line": 66,
            "column": 28
          }
        },
        {
          "usedConstants": [
            "Continuous.prod_mk"
          ],
          "tactic": "apply Continuous.prod_mk",
          "proofState": 34,
          "pos": {
            "line": 67,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\nfoo : (fun ab => (bil ab.1) ab.2) = (fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2)\n\u22a2 Continuous fun ab => (elinear ab.1, ab.2)",
          "endPos": {
            "line": 67,
            "column": 26
          }
        },
        {
          "usedConstants": [
            "IsModuleTopology.toContinuousSMul",
            "LinearMap.fst",
            "Pi.Function.module",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "instTopologicalSpaceProd",
            "Algebra.toSMul",
            "IsModuleTopology.instProd",
            "Algebra.id",
            "Distrib.toAdd",
            "instContinuousAddForallOfTopologicalSemiring",
            "instContinuousSMulForall",
            "IsModuleTopology.continuous_of_linearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "LinearMap.comp",
            "LinearEquiv.toLinearMap",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "RingHomInvPair.ids",
            "TopologicalSemiring.toIsModuleTopology",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Prod",
            "Prod.instModule",
            "RingHom.id",
            "RingHomCompTriple.ids",
            "Semiring.toNonAssocSemiring",
            "Prod.instAddCommMonoid"
          ],
          "tactic": "exact continuous_of_linearMap (elinear.toLinearMap \u2218\u2097 (LinearMap.fst R A B))",
          "proofState": 35,
          "pos": {
            "line": 68,
            "column": 4
          },
          "goals": "case hf\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\nfoo : (fun ab => (bil ab.1) ab.2) = (fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2)\n\u22a2 Continuous fun x => elinear x.1",
          "endPos": {
            "line": 68,
            "column": 80
          }
        },
        {
          "usedConstants": [
            "Continuous.snd",
            "continuous_id'",
            "instTopologicalSpaceProd",
            "Prod"
          ],
          "tactic": "fun_prop",
          "proofState": 36,
          "pos": {
            "line": 69,
            "column": 4
          },
          "goals": "case hg\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b2 : CommSemiring R\nA : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommMonoid A\ninst\u271d\u00b9\u2070 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2079 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2078 : AddCommMonoid B\ninst\u271d\u2077 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2076 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u2075 : AddCommMonoid C\ninst\u271d\u2074 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b3 : IsModuleTopology R C\ninst\u271d\u00b2 : TopologicalSemiring R\ninst\u271d\u00b9 : Module.Finite R A\ninst\u271d : Module.Free R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u03b9 : Type u_2 := Module.Free.ChooseBasisIndex R A\nh\u03b9 : Fintype \u03b9 := Module.Free.ChooseBasisIndex.fintype R A\nb : Basis \u03b9 R A := Module.Free.chooseBasis R A\nelinear : A \u2243\u2097[R] \u03b9 \u2192 R := b.equivFun\nbil' : (\u03b9 \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 \u2191elinear.symm\nthis : Continuous fun ab => (bil' ab.1) ab.2\nfoo : (fun ab => (bil ab.1) ab.2) = (fun fb => (bil' fb.1) fb.2) \u2218 fun ab => (elinear ab.1, ab.2)\n\u22a2 Continuous Prod.snd",
          "endPos": {
            "line": 69,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Module.Finite.exists_fin'"
          ],
          "tactic": "obtain \u27e8m, f, hf\u27e9 := Module.Finite.exists_fin' R A",
          "proofState": 37,
          "pos": {
            "line": 84,
            "column": 2
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 84,
            "column": 52
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Pi.Function.module",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "LinearMap.comp",
            "CommRing.toCommSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toCommMonoid",
            "Fin",
            "RingHom.id",
            "RingHomCompTriple.ids",
            "Semiring.toNonAssocSemiring",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "let bil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil.comp f",
          "proofState": 38,
          "pos": {
            "line": 85,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 85,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "IsModuleTopology.Module.continuous_bilinear_of_pi_finite",
            "Finite.of_fintype",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "Fin.fintype",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "CommSemiring.toCommMonoid",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toCommMonoid",
            "Prod",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "letFun",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have := Module.continuous_bilinear_of_pi_finite (Fin m) bil'",
          "proofState": 39,
          "pos": {
            "line": 86,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 86,
            "column": 62
          }
        },
        {
          "usedConstants": [
            "LinearMap.id",
            "Pi.Function.module",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "LinearMap",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "LinearMap.prodMap",
            "Prod.instAddCommMonoid"
          ],
          "tactic": "let \u03c6 := f.prodMap (LinearMap.id : B \u2192\u2097[R] B)",
          "proofState": 40,
          "pos": {
            "line": 87,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis : Continuous fun ab => (bil' ab.1) ab.2\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 87,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "LinearMap.id",
            "Continuous",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "CommRing.toCommSemiring",
            "congrFun",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "Function.RightInverse.surjective",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toCommMonoid",
            "Prod",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "Function.Surjective",
            "letFun",
            "rfl",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have foo : Function.Surjective (LinearMap.id : B \u2192\u2097[R] B) := Function.RightInverse.surjective (congrFun rfl)",
          "proofState": 41,
          "pos": {
            "line": 88,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 89,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "LinearMap.id",
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Function.Surjective.prodMap",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "Function.Surjective",
            "letFun",
            "Semiring.toMonoidWithZero",
            "Prod.instAddCommMonoid"
          ],
          "tactic": "have h\u03c6 : Function.Surjective \u03c6 := Function.Surjective.prodMap hf foo",
          "proofState": 42,
          "pos": {
            "line": 90,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 90,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Pi.Function.module",
            "Continuous",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommRing.toNonUnitalCommRing",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "IsModuleTopology.instProd",
            "Topology.IsQuotientMap.eq_coinduced",
            "Finite.of_fintype",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "TopologicalSpace.coinduced",
            "smulCommClass_self",
            "Fin.fintype",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "IsModuleTopology.isQuotientMap_of_surjective",
            "TopologicalSpace",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "Pi.addCommGroup",
            "LinearMap.addCommMonoid",
            "TopologicalSemiring.toIsModuleTopology",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "TopologicalRing.toTopologicalSemiring",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "IsModuleTopology.instPi",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "letFun",
            "Prod.instAddCommGroup",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have := (isQuotientMap_of_surjective h\u03c6).2",
          "proofState": 43,
          "pos": {
            "line": 91,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 91,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "id",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "TopologicalSpace.coinduced",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "TopologicalSpace",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Pi.addCommGroup",
            "LinearMap.addCommMonoid",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "Prod.instAddCommGroup",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [this, continuous_def]",
          "proofState": 44,
          "pos": {
            "line": 92,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\n\u22a2 Continuous fun ab => (bil ab.1) ab.2",
          "endPos": {
            "line": 92,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Set"
          ],
          "tactic": "intro U hU",
          "proofState": 45,
          "pos": {
            "line": 93,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\n\u22a2 \u2200 (s : Set C), IsOpen s \u2192 IsOpen ((fun ab => (bil ab.1) ab.2) \u207b\u00b9' s)",
          "endPos": {
            "line": 93,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.Function.module",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "id",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "TopologicalSpace.coinduced",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Set.preimage",
            "isOpen_coinduced",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Pi.addCommGroup",
            "LinearMap.addCommMonoid",
            "propext",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "Prod.instAddCommGroup",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [isOpen_coinduced, \u2190 Set.preimage_comp]",
          "proofState": 46,
          "pos": {
            "line": 94,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\n\u22a2 IsOpen ((fun ab => (bil ab.1) ab.2) \u207b\u00b9' U)",
          "endPos": {
            "line": 94,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Function.comp",
            "Eq.mp",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Set.preimage",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Pi.addCommGroup",
            "LinearMap.addCommMonoid",
            "propext",
            "MulActionWithZero.toMulAction",
            "Eq.refl",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "continuous_def",
            "letFun",
            "Prod.instAddCommGroup",
            "Semiring.toMonoidWithZero",
            "Prod.instAddCommMonoid",
            "Set"
          ],
          "tactic": "suffices Continuous ((fun ab \u21a6 (bil ab.1) ab.2) \u2218 \u03c6 : (Fin m \u2192 R) \u00d7 B \u2192 C)\n  by\n  rw [continuous_def] at this\n  convert this _ hU",
          "proofState": 47,
          "pos": {
            "line": 95,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\n\u22a2 IsOpen ((fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6 \u207b\u00b9' U)",
          "endPos": {
            "line": 97,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "Continuous",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Function.comp",
            "Eq.mp",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Set.preimage",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "propext",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "continuous_def",
            "Semiring.toMonoidWithZero",
            "Prod.instAddCommMonoid",
            "Set"
          ],
          "tactic": "rw [continuous_def] at this",
          "proofState": 48,
          "pos": {
            "line": 96,
            "column": 4
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d\u00b9 : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis\u271d : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\nthis : Continuous ((fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6)\n\u22a2 IsOpen ((fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6 \u207b\u00b9' U)",
          "endPos": {
            "line": 96,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Pi.Function.module",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "Pi.topologicalSpace",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Function.comp",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Set.preimage",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "Pi.addCommGroup",
            "LinearMap.addCommMonoid",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "IsOpen",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "Prod.instAddCommGroup",
            "Semiring.toMonoidWithZero",
            "Prod.instAddCommMonoid"
          ],
          "tactic": "convert this _ hU",
          "proofState": 49,
          "pos": {
            "line": 97,
            "column": 4
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d\u00b9 : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis\u271d : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\nthis : \u2200 (s : Set C), IsOpen s \u2192 IsOpen ((fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6 \u207b\u00b9' s)\n\u22a2 IsOpen ((fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6 \u207b\u00b9' U)",
          "endPos": {
            "line": 97,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Pi.Function.module",
            "Continuous",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommRing.toNonUnitalCommRing",
            "Pi.topologicalSpace",
            "congrArg",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Function.comp",
            "id",
            "LinearMap.module",
            "LinearMap",
            "Prod.fst",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toCommMonoid",
            "Prod",
            "Prod.instModule",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Prod.snd",
            "DFunLike.coe",
            "letFun",
            "Semiring.toMonoidWithZero",
            "Prod.instAddCommMonoid"
          ],
          "tactic": "rw [show (fun ab \u21a6 (bil ab.1) ab.2 : A \u00d7 B \u2192 C) \u2218 \u03c6 = (fun fb \u21a6 bil' fb.1 fb.2)\n    by\n    ext \u27e8a, b\u27e9\n    simp [bil', \u03c6]]",
          "proofState": 50,
          "pos": {
            "line": 98,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\n\u22a2 Continuous ((fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6)",
          "endPos": {
            "line": 100,
            "column": 19
          }
        },
        {
          "usedConstants": [
            "funext"
          ],
          "tactic": "ext \u27e8a, b\u27e9",
          "proofState": 51,
          "pos": {
            "line": 99,
            "column": 4
          },
          "goals": "R : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\n\u22a2 (fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6 = fun fb => (bil' fb.1) fb.2",
          "endPos": {
            "line": 99,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "Pi.Function.module",
            "Semiring.toModule",
            "Pi.addCommMonoid",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "LinearMap.module",
            "LinearMap",
            "smulCommClass_self",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "eq_self",
            "of_eq_true",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "CommRing.toCommMonoid",
            "Fin",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [bil', \u03c6]",
          "proofState": 52,
          "pos": {
            "line": 100,
            "column": 4
          },
          "goals": "case h.mk\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\na : Fin m \u2192 R\nb : B\n\u22a2 ((fun ab => (bil ab.1) ab.2) \u2218 \u21d1\u03c6) (a, b) = (bil' (a, b).1) (a, b).2",
          "endPos": {
            "line": 100,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "IsModuleTopology.Module.continuous_bilinear_of_finite_free"
          ],
          "tactic": "apply Module.continuous_bilinear_of_finite_free",
          "proofState": 53,
          "pos": {
            "line": 101,
            "column": 2
          },
          "goals": "case intro.intro\nR : Type u_1\n\u03c4R : TopologicalSpace R\ninst\u271d\u00b9\u00b9 : CommRing R\ninst\u271d\u00b9\u2070 : TopologicalRing R\nA : Type u_2\ninst\u271d\u2079 : AddCommGroup A\ninst\u271d\u2078 : Module R A\naA : TopologicalSpace A\ninst\u271d\u2077 : IsModuleTopology R A\nB : Type u_3\ninst\u271d\u2076 : AddCommGroup B\ninst\u271d\u2075 : Module R B\naB : TopologicalSpace B\ninst\u271d\u2074 : IsModuleTopology R B\nC : Type u_4\ninst\u271d\u00b3 : AddCommGroup C\ninst\u271d\u00b2 : Module R C\naC : TopologicalSpace C\ninst\u271d\u00b9 : IsModuleTopology R C\ninst\u271d : Module.Finite R A\nbil : A \u2192\u2097[R] B \u2192\u2097[R] C\nm : \u2115\nf : (Fin m \u2192 R) \u2192\u2097[R] A\nhf : Function.Surjective \u21d1f\nbil' : (Fin m \u2192 R) \u2192\u2097[R] B \u2192\u2097[R] C := bil \u2218\u2097 f\nthis\u271d : Continuous fun ab => (bil' ab.1) ab.2\n\u03c6 : (Fin m \u2192 R) \u00d7 B \u2192\u2097[R] A \u00d7 B := f.prodMap LinearMap.id\nfoo : Function.Surjective \u21d1LinearMap.id\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : instTopologicalSpaceProd = TopologicalSpace.coinduced (\u21d1\u03c6) instTopologicalSpaceProd\nU : Set C\nhU : IsOpen U\n\u22a2 Continuous fun fb => (bil' fb.1) fb.2",
          "endPos": {
            "line": 101,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "TensorProduct.add",
            "Ring.toNonAssocRing",
            "TensorProduct.instSMul",
            "Algebra.toModule",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "moduleTopology",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "TensorProduct",
            "Ring.toSemiring"
          ],
          "tactic": "letI : TopologicalSpace (D \u2297[R] D) := moduleTopology R _",
          "proofState": 54,
          "pos": {
            "line": 142,
            "column": 2
          },
          "goals": "R : Type ?u.69793\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : TopologicalRing R\nD : Type u_1\ninst\u271d\u2074 : Ring D\ninst\u271d\u00b3 : Algebra R D\ninst\u271d\u00b2 : Module.Finite R D\ninst\u271d\u00b9 : TopologicalSpace D\ninst\u271d : IsModuleTopology R D\n\u22a2 Continuous fun ab => ab.1 * ab.2",
          "endPos": {
            "line": 142,
            "column": 58
          }
        },
        {
          "usedConstants": [
            "TensorProduct.add",
            "Ring.toNonAssocRing",
            "TensorProduct.instSMul",
            "IsModuleTopology.mk",
            "Algebra.toModule",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "TopologicalSpace",
            "CommRing.toCommSemiring",
            "TensorProduct",
            "Ring.toSemiring",
            "rfl"
          ],
          "tactic": "haveI : IsModuleTopology R (D \u2297[R] D) := { eq_moduleTopology' := rfl }",
          "proofState": 55,
          "pos": {
            "line": 143,
            "column": 2
          },
          "goals": "R : Type ?u.69793\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : TopologicalRing R\nD : Type u_1\ninst\u271d\u2074 : Ring D\ninst\u271d\u00b3 : Algebra R D\ninst\u271d\u00b2 : Module.Finite R D\ninst\u271d\u00b9 : TopologicalSpace D\ninst\u271d : IsModuleTopology R D\nthis : TopologicalSpace (D \u2297[R] D) := moduleTopology R (D \u2297[R] D)\n\u22a2 Continuous fun ab => ab.1 * ab.2",
          "endPos": {
            "line": 143,
            "column": 72
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Algebra.to_smulCommClass",
            "Continuous",
            "HMul.hMul",
            "IsScalarTower.right",
            "Ring.toNonAssocRing",
            "CommSemiring.toSemiring",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "LinearMap.instFunLike",
            "Module.toMulActionWithZero",
            "instTopologicalSpaceProd",
            "Algebra.toModule",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "LinearMap.module",
            "IsModuleTopology.Module.continuous_bilinear_of_finite",
            "LinearMap",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "Prod.fst",
            "smulCommClass_self",
            "CommRing.toCommSemiring",
            "Distrib.toMul",
            "Ring.toAddCommGroup",
            "AddZeroClass.toZero",
            "LinearMap.addCommMonoid",
            "NonUnitalNonAssocSemiring.toDistrib",
            "MulActionWithZero.toMulAction",
            "AddCommMonoid.toAddMonoid",
            "LinearMap.mul",
            "CommRing.toCommMonoid",
            "Prod",
            "RingHom.id",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Prod.snd",
            "DFunLike.coe",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "convert Module.continuous_bilinear_of_finite <| (LinearMap.mul R D : D \u2192\u2097[R] D \u2192\u2097[R] D)",
          "proofState": 56,
          "pos": {
            "line": 144,
            "column": 2
          },
          "goals": "R : Type ?u.69793\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : TopologicalSpace R\ninst\u271d\u2075 : TopologicalRing R\nD : Type u_1\ninst\u271d\u2074 : Ring D\ninst\u271d\u00b3 : Algebra R D\ninst\u271d\u00b2 : Module.Finite R D\ninst\u271d\u00b9 : TopologicalSpace D\ninst\u271d : IsModuleTopology R D\nthis\u271d : TopologicalSpace (D \u2297[R] D) := moduleTopology R (D \u2297[R] D)\nthis : IsModuleTopology R (D \u2297[R] D)\n\u22a2 Continuous fun ab => ab.1 * ab.2",
          "endPos": {
            "line": 144,
            "column": 89
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AddCommGroup.toAddCommMonoid",
            "AddMonoid.toAddZeroClass",
            "Module.toMulActionWithZero",
            "sorryAx",
            "instOfNatNat",
            "Lean.Name.num",
            "moduleTopology",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "TopologicalSpace",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Nat",
            "AddZeroClass.toZero",
            "Lean.Name",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "AddCommSemigroup.toAddCommMagma",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Bool.false",
            "Eq",
            "MulZeroClass.toZero",
            "AddCommMagma.toAdd",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "sorry\n  /-\n  \n  Proof: First, it suffices to show that if M has the R-module topology\n  \u03c4RM then it's a topological S-module, and that if M has the S-module\n  topology \u03c4SM then it's a topological R-module. This is because the former\n  claim shows \u03c4SM \u2264 \u03c4RM and the latter shows \u03c4RM \u2264 \u03c4SM.\n  \n  If M has the S-module topology then it's clearly a topological R-module,\n  because it's a topological S-module so (+ : M \u00d7 M \u2192 M) is continuous\n  and (\u2022 : S \u00d7 M \u2192 M) are continuous, and the map R \u2192 S is continuous\n  because it's R-linear and S has the R-module topology, so\n  R \u00d7 M \u2192 S \u00d7 M is continuous and thus (\u2022 : R \u00d7 M \u2192 M) is continuous.\n  \n  The converse is more subtle and it's here where we need some finiteness\n  assumptions. If M has the R-module topology then certainly (+ : M \u00d7 M \u2192 M)\n  is continuous, so it all rests on showing that (\u2022 : S \u00d7 M \u2192 M) is\n  continuous. But everything here is an R-module and \u2022 is R-bilinear,\n  and thus if either S or M are module-finite over R the result is\n  automatic.\n  -/\n  \n  -- maybe",
          "proofState": 57,
          "pos": {
            "line": 167,
            "column": 2
          },
          "goals": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : TopologicalSpace R\ninst\u271d\u00b9\u2070 : TopologicalRing R\ninst\u271d\u2079 : CommRing S\ninst\u271d\u2078 : TopologicalSpace S\ninst\u271d\u2077 : TopologicalRing S\ninst\u271d\u2076 : Algebra R S\ninst\u271d\u2075 : Module.Finite R S\ninst\u271d\u2074 : IsModuleTopology R S\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower R S M\n\u22a2 moduleTopology R M = moduleTopology S M",
          "endPos": {
            "line": 167,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "Algebra.toSMul",
            "sorryAx",
            "Distrib.toAdd",
            "instOfNatNat",
            "Lean.Name.num",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "CommRing.toCommSemiring",
            "IsModuleTopology",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Lean.Name",
            "OfNat.ofNat",
            "Bool.false"
          ],
          "tactic": "sorry\n  /-\n  Proof.\n  \n  First note that `S` is a topological ring so addition and multiplication\n  on `S` are continuous. Futhermore the hypothesis `Contiuous (algebraMap R S)`\n  shows that \u2022 : R \u00d7 S \u2192 S is continuous, so S is a topological R-module.\n  In particular the identity map (S,R-module top) -> (S, given top) is continuous.\n  \n  The algebra map from R to (S,R-module top) is R-linear\n  and hence also continuous. Furthermore, the composite is open\n  and I claim that the two topologies on S thus \"look the same near 0\".\n  More precisely, the image of R is open in S with the given topology\n  and hence also with the module topology (by continuity of the identity map above),\n  and if U \u2286 S is a subset of the image of R then we claim that it's open for\n  the given topology iff it's open for the module topology. Firstly,\n  continuity of the identity\n  map shows that if U is open for the given topology it's open for the module\n  topology. Secondly, if U is open for the module topology then its preimage\n  in R is open for R's topology, and then the image of this in S is open for\n  the given topology, and this is U again as U is a subset of the image of R.\n  \n  -/",
          "proofState": 58,
          "pos": {
            "line": 202,
            "column": 2
          },
          "goals": "R : Type u_1\nS : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : TopologicalSpace R\ninst\u271d\u2074 : TopologicalRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : TopologicalSpace S\ninst\u271d\u00b9 : TopologicalRing S\ninst\u271d : Algebra R S\nhcont : Continuous \u21d1(algebraMap R S)\nhopen : IsOpenMap \u21d1(algebraMap R S)\n\u22a2 IsModuleTopology R S",
          "endPos": {
            "line": 202,
            "column": 7
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 167,
            "column": 2
          },
          "goal": "R : Type u_1\nS : Type u_2\nM : Type u_3\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : TopologicalSpace R\ninst\u271d\u00b9\u2070 : TopologicalRing R\ninst\u271d\u2079 : CommRing S\ninst\u271d\u2078 : TopologicalSpace S\ninst\u271d\u2077 : TopologicalRing S\ninst\u271d\u2076 : Algebra R S\ninst\u271d\u2075 : Module.Finite R S\ninst\u271d\u2074 : IsModuleTopology R S\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module S M\ninst\u271d : IsScalarTower R S M\n\u22a2 moduleTopology R M = moduleTopology S M",
          "endPos": {
            "line": 167,
            "column": 7
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 202,
            "column": 2
          },
          "goal": "R : Type u_1\nS : Type u_2\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : TopologicalSpace R\ninst\u271d\u2074 : TopologicalRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : TopologicalSpace S\ninst\u271d\u00b9 : TopologicalRing S\ninst\u271d : Algebra R S\nhcont : Continuous \u21d1(algebraMap R S)\nhopen : IsOpenMap \u21d1(algebraMap R S)\n\u22a2 IsModuleTopology R S",
          "endPos": {
            "line": 202,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 166,
            "column": 0
          },
          "endPos": {
            "line": 166,
            "column": 7
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 200,
            "column": 0
          },
          "endPos": {
            "line": 200,
            "column": 7
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/Mathlib/NumberTheory/Padics/PadicIntegers.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "mul_nonneg",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "PadicInt",
            "MulZeroClass.toMul",
            "Real.instZero",
            "Real.orderedSemiring",
            "congrArg",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "OrderedSemiring.toPosMulMono",
            "Eq.rec",
            "Subtype",
            "LE.le",
            "PadicInt.instNormedCommRing",
            "Subtype.mk",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "PadicInt.norm_mul",
            "Real.normedCommRing",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "Real.instMul",
            "True",
            "eq_self",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "Eq.ndrec",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Eq.refl",
            "PadicInt.instNorm",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "norm_nonneg",
            "Real.instPreorder",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "PadicInt.instMul"
          ],
          "tactic": "simp [nnnorm, NNReal]",
          "proofState": 1,
          "pos": {
            "line": 31,
            "column": 72
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nx y : \u2124_[p]\n\u22a2 \u2016x * y\u2016\u208a = \u2016x\u2016\u208a * \u2016y\u2016\u208a",
          "endPos": {
            "line": 31,
            "column": 93
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "PadicInt",
            "Real.instZero",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "Preorder.toLE",
            "OrderedSemiring.zeroLEOneClass",
            "Monoid.toNatPow",
            "OrderedSemiring.toPosMulMono",
            "Eq.rec",
            "Subtype",
            "PadicInt.instCommRing",
            "Real.instMonoidWithZero",
            "LE.le",
            "PadicInt.instNormedCommRing",
            "Subtype.mk",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Real.instMonoid",
            "Nonneg.pow_nonneg",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "Nat",
            "True",
            "eq_self",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "Eq.ndrec",
            "PadicInt.norm_pow",
            "Zero.toOfNat0",
            "Eq.refl",
            "instHPow",
            "MulZeroOneClass.toMulZeroClass",
            "PadicInt.instNorm",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Eq",
            "norm_nonneg",
            "Real.instPreorder",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [nnnorm, NNReal]",
          "proofState": 2,
          "pos": {
            "line": 34,
            "column": 75
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nx : \u2124_[p]\nn : \u2115\n\u22a2 \u2016x ^ n\u2016\u208a = \u2016x\u2016\u208a ^ n",
          "endPos": {
            "line": 34,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real.instLE",
            "Real",
            "NormedRing.toRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "PadicInt",
            "Real.instZero",
            "congrArg",
            "Real.instInv",
            "SeminormedAddGroup.toNNNorm",
            "NNNorm.nnnorm",
            "AddGroupWithOne.toAddMonoidWithOne",
            "DivisionMonoid.toDivInvOneMonoid",
            "Eq.rec",
            "id",
            "Subtype",
            "AddMonoidWithOne.toNatCast",
            "NNReal",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LE.le",
            "Nat.cast",
            "PadicInt.instNormedCommRing",
            "Subtype.mk",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Inv.inv",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "Semifield.toCommGroupWithZero",
            "PadicInt.norm_p",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Eq.ndrec",
            "Zero.toOfNat0",
            "Eq.refl",
            "CommGroupWithZero.toDivisionCommMonoid",
            "NNReal.instLinearOrderedSemifield",
            "InvOneClass.toInv",
            "instNNRealSemiring",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ring.toAddGroupWithOne",
            "norm_nonneg",
            "Real.instNatCast"
          ],
          "tactic": "simp [nnnorm]",
          "proofState": 3,
          "pos": {
            "line": 36,
            "column": 60
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 \u2016\u2191p\u2016\u208a = (\u2191p)\u207b\u00b9",
          "endPos": {
            "line": 36,
            "column": 73
          }
        },
        {
          "usedConstants": [
            "NormedCommRing.toNormedRing",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "NormedRing.toRing",
            "PadicInt",
            "Real.instZero",
            "Real.instInv",
            "AddGroupWithOne.toAddMonoidWithOne",
            "AddMonoidWithOne.toNatCast",
            "NNReal",
            "LE.le",
            "Nat.cast",
            "PadicInt.instNormedCommRing",
            "Subtype.mk",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Inv.inv",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "PadicInt.norm_p",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Eq.ndrec",
            "Zero.toOfNat0",
            "Eq.refl",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Ring.toAddGroupWithOne",
            "norm_nonneg",
            "Real.instNatCast"
          ],
          "tactic": "rfl",
          "proofState": 4,
          "pos": {
            "line": 36,
            "column": 75
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 \u27e8(\u2191p)\u207b\u00b9, \u22ef\u27e9 = (\u2191p)\u207b\u00b9",
          "endPos": {
            "line": 36,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Units.val",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "PadicInt",
            "PadicInt.norm_units",
            "Real.instZero",
            "Real.orderedSemiring",
            "congrArg",
            "CommSemiring.toSemiring",
            "OrderedSemiring.zeroLEOneClass",
            "Eq.rec",
            "Subtype",
            "NNReal",
            "PadicInt.instCommRing",
            "LE.le",
            "PadicInt.instNormedCommRing",
            "Subtype.mk",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "CommRing.toCommSemiring",
            "instNNRealOne",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "True",
            "eq_self",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "of_eq_true",
            "Eq.ndrec",
            "One.toOfNat1",
            "Zero.toOfNat0",
            "Eq.refl",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Nonneg.one",
            "Eq",
            "norm_nonneg",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [nnnorm, NNReal]",
          "proofState": 5,
          "pos": {
            "line": 38,
            "column": 77
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nu : \u2124_[p]\u02e3\n\u22a2 \u2016\u2191u\u2016\u208a = 1",
          "endPos": {
            "line": 38,
            "column": 98
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "NormedCommRing.toSeminormedCommRing",
            "IsOpen.isOpenEmbedding_subtypeVal",
            "Real.instLE",
            "Real",
            "setOf",
            "PseudoMetricSpace.toUniformSpace",
            "LE.le",
            "Real.instOne",
            "Padic.normedField",
            "SeminormedCommRing.toSeminormedRing",
            "Padic",
            "One.toOfNat1",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "UniformSpace.toTopologicalSpace"
          ],
          "tactic": "refine (?_ : IsOpen {y : \u211a_[p] | \u2016y\u2016 \u2264 1}).isOpenEmbedding_subtypeVal",
          "proofState": 6,
          "pos": {
            "line": 44,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 IsOpenEmbedding Subtype.val",
          "endPos": {
            "line": 44,
            "column": 71
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa only [Metric.closedBall, dist_eq_norm_sub, sub_zero] using\n  IsUltrametricDist.isOpen_closedBall (0 : \u211a_[p]) one_ne_zero",
          "proofState": 7,
          "pos": {
            "line": 45,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 IsOpen {y | \u2016y\u2016 \u2264 1}",
          "endPos": {
            "line": 46,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Real.instLinearOrderedField",
            "NormedCommRing.toNormedRing",
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Real",
            "instHSMul",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "GroupWithZero.toDivisionMonoid",
            "NormedRing.toRing",
            "DivisionCommMonoid.toDivisionMonoid",
            "LinearOrderedSemifield.toSemifield",
            "DivInvOneMonoid.toInvOneClass",
            "PadicInt",
            "Nonneg.linearOrderedSemifield.proof_5",
            "congrArg",
            "CommSemiring.toSemiring",
            "Nonneg.pow",
            "OrderedAddCommMonoid.toPartialOrder",
            "Mathlib.Algebra.GroupWithZero.Basic._auxLemma.15",
            "SeminormedAddGroup.toNNNorm",
            "NNNorm.nnnorm",
            "Mathlib.Analysis.Normed.Group.Basic._auxLemma.34",
            "AddMonoid.toAddZeroClass",
            "Padic.instAddCommGroup",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "StrictOrderedSemiring.toSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "AddCommGroup.toAddGroup",
            "DivisionMonoid.toDivInvOneMonoid",
            "Algebra.toModule",
            "Nonneg.zpow",
            "id",
            "Subtype",
            "AddMonoidWithOne.toNatCast",
            "NNReal",
            "Ne",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "instOfNatNat",
            "PadicInt.instCommRing",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "MulAction.toSMul",
            "LE.le",
            "NormedAddGroup.toAddGroup",
            "SubNegZeroMonoid.toNegZeroClass",
            "NormedCommRing.toNonUnitalNormedCommRing",
            "Nat.cast",
            "Field.toSemifield",
            "Function.Injective.groupWithZero",
            "PadicInt.instNormedCommRing",
            "AddSubgroup.relindex",
            "Nonneg.inv",
            "Nonneg.coe_inv",
            "PadicInt.algebra",
            "AddSubgroup",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Nonneg.linearOrderedSemifield.proof_9",
            "NonUnitalNormedRing.toNormedAddCommGroup",
            "AddMonoidWithOne.toOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "Nonneg.zero",
            "CommRing.toCommSemiring",
            "Inv.inv",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Nonneg.linearOrderedSemifield.proof_11",
            "Nonneg.linearOrderedSemifield.proof_2",
            "StrictOrderedSemiring.toCharZero",
            "Padic.normedField",
            "OrderedCommSemiring.toOrderedSemiring",
            "Submodule.toAddSubgroup",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "Nat",
            "NormedAddCommGroup.toNormedAddGroup",
            "AddZeroClass.toZero",
            "Semifield.toCommGroupWithZero",
            "propext",
            "NonUnitalNormedCommRing.toNonUnitalNormedRing",
            "Nonneg.linearOrderedSemifield.proof_7",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "LinearOrderedSemifield.toLinearOrderedCommSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Padic.field",
            "Zero.toOfNat0",
            "CommGroupWithZero.toDivisionCommMonoid",
            "HSMul.hSMul",
            "Module.toDistribMulAction",
            "Nonneg.coe_div",
            "NNReal.instLinearOrderedSemifield",
            "InvOneClass.toInv",
            "Nonneg.mul",
            "instNNRealSemiring",
            "AddMonoidWithOne.toAddMonoid",
            "NormedField.toNormedCommRing",
            "MulZeroOneClass.toMulZeroClass",
            "Nonneg.linearOrderedSemifield.proof_6",
            "LinearOrderedSemiring.toStrictOrderedSemiring",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "CommGroupWithZero.toGroupWithZero",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "PadicInt.smul_submodule_relindex",
            "Nonneg.coe_zpow",
            "instNNRealStrictOrderedSemiring",
            "OfNat.ofNat",
            "Eq.symm",
            "LinearOrderedField.toLinearOrderedSemifield",
            "Subtype.val",
            "Nonneg.one",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "Not",
            "AddSubgroup.pointwiseMulAction",
            "MonoidWithZero.toMonoid",
            "Nonneg.linearOrderedSemifield.proof_4",
            "Nat.cast_ne_zero",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Nonneg.div",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simpa [\u2190 Nat.cast_ne_zero (R := \u211d\u22650), smul_submodule_relindex]\n  -- Ya\u00ebl: Do we really want this as a coercion?",
          "proofState": 8,
          "pos": {
            "line": 70,
            "column": 25
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nx : \u2124_[p]\nhx : x \u2260 0\ns : Submodule \u2124_[p] \u211a_[p]\n\u22a2 (x \u2022 s.toAddSubgroup).relindex s.toAddSubgroup \u2260 0",
          "endPos": {
            "line": 70,
            "column": 87
          }
        },
        {
          "usedConstants": [],
          "tactic": "set H := Subgroup.closure (Set.range ((\u2191) : \u2124_[p]\u2070 \u2192 \u211a_[p]\u02e3))",
          "proofState": 9,
          "pos": {
            "line": 79,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef) = \u22a4",
          "endPos": {
            "line": 79,
            "column": 63
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "congrArg",
            "DivisionSemiring.toGroupWithZero",
            "Membership.mem",
            "Units",
            "id",
            "Subgroup",
            "Units.instGroup",
            "Field.toSemifield",
            "Subgroup.eq_top_iff'",
            "Semifield.toDivisionSemiring",
            "propext",
            "Padic",
            "Padic.field",
            "Subgroup.instTop",
            "Top.top",
            "Eq",
            "SetLike.instMembership",
            "Subgroup.instSetLike",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "rw [eq_top_iff']",
          "proofState": 10,
          "pos": {
            "line": 80,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\n\u22a2 H = \u22a4",
          "endPos": {
            "line": 80,
            "column": 18
          }
        },
        {
          "usedConstants": [
            "GroupWithZero.toMonoidWithZero",
            "DivisionSemiring.toGroupWithZero",
            "Units",
            "Field.toSemifield",
            "Semifield.toDivisionSemiring",
            "Padic",
            "Padic.field",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "intro x",
          "proofState": 11,
          "pos": {
            "line": 81,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\n\u22a2 \u2200 (x : \u211a_[p]\u02e3), x \u2208 H",
          "endPos": {
            "line": 81,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "PadicInt",
            "IsFractionRing.div_surjective"
          ],
          "tactic": "obtain \u27e8y, z, hz, hyzx\u27e9 := IsFractionRing.div_surjective (A := \u2124_[p]) x.val",
          "proofState": 12,
          "pos": {
            "line": 82,
            "column": 2
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\n\u22a2 x \u2208 H",
          "endPos": {
            "line": 82,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "GroupWithZero.toMonoidWithZero",
            "PadicInt",
            "CommSemiring.toSemiring",
            "DivisionSemiring.toGroupWithZero",
            "Membership.mem",
            "nonZeroDivisors",
            "Units",
            "Subgroup",
            "PadicInt.instCommRing",
            "Units.instGroup",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Padic",
            "Padic.field",
            "Submonoid.instSetLike",
            "SetLike.instMembership",
            "letFun",
            "Submonoid",
            "Subgroup.instSetLike",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have hy : y \u2208 \u2124_[p]\u2070 := by simp; rintro rfl; simp [eq_comm] at hyzx",
          "proofState": 13,
          "pos": {
            "line": 83,
            "column": 2
          },
          "goals": "case intro.intro.intro\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\ny z : \u2124_[p]\nhz : z \u2208 \u2124_[p]\u2070\nhyzx : (algebraMap \u2124_[p] \u211a_[p]) y / (algebraMap \u2124_[p] \u211a_[p]) z = \u2191x\n\u22a2 x \u2208 H",
          "endPos": {
            "line": 83,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "IsDomain.to_noZeroDivisors",
            "PadicInt",
            "CommSemiring.toSemiring",
            "Mathlib.Algebra.GroupWithZero.NonZeroDivisors._auxLemma.10",
            "PadicInt.instIsLocalRing",
            "PadicInt.instIsDomain",
            "Membership.mem",
            "nonZeroDivisors",
            "id",
            "PadicInt.instCommRing",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "IsLocalRing.toNontrivial",
            "Zero.toOfNat0",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Eq",
            "Not",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp",
          "proofState": 14,
          "pos": {
            "line": 83,
            "column": 29
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\ny z : \u2124_[p]\nhz : z \u2208 \u2124_[p]\u2070\nhyzx : (algebraMap \u2124_[p] \u211a_[p]) y / (algebraMap \u2124_[p] \u211a_[p]) z = \u2191x\n\u22a2 y \u2208 \u2124_[p]\u2070",
          "endPos": {
            "line": 83,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "PadicInt",
            "CommSemiring.toSemiring",
            "PadicInt.instCommRing",
            "CommRing.toCommSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Zero.toOfNat0",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Eq",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rintro rfl",
          "proofState": 15,
          "pos": {
            "line": 83,
            "column": 35
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\ny z : \u2124_[p]\nhz : z \u2208 \u2124_[p]\u2070\nhyzx : (algebraMap \u2124_[p] \u211a_[p]) y / (algebraMap \u2124_[p] \u211a_[p]) z = \u2191x\n\u22a2 \u00acy = 0",
          "endPos": {
            "line": 83,
            "column": 45
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Units.val",
            "GroupWithZero.toMonoidWithZero",
            "False",
            "Real.instLE",
            "Real",
            "instHDiv",
            "GroupWithZero.toDivInvMonoid",
            "Mathlib.Algebra.GroupWithZero.Units.Basic._auxLemma.1",
            "congrArg",
            "False.elim",
            "zero_div",
            "DivisionSemiring.toGroupWithZero",
            "Eq.mp",
            "HDiv.hDiv",
            "LE.le",
            "Field.toSemifield",
            "Real.instOne",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "DivInvMonoid.toDiv",
            "DivisionSemiring.toSemiring",
            "Padic",
            "One.toOfNat1",
            "Padic.field",
            "Zero.toOfNat0",
            "EuclideanDomain.toNontrivial",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "Padic.instNorm",
            "Subtype.val",
            "Eq",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "_auxLemma.3",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [eq_comm] at hyzx",
          "proofState": 16,
          "pos": {
            "line": 83,
            "column": 47
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\nz : \u2124_[p]\nhz : z \u2208 \u2124_[p]\u2070\nhyzx : (algebraMap \u2124_[p] \u211a_[p]) 0 / (algebraMap \u2124_[p] \u211a_[p]) z = \u2191x\n\u22a2 False",
          "endPos": {
            "line": 83,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "Set.mem_range_self",
            "Norm.norm",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real.instLE",
            "Real",
            "Subgroup.instSubgroupClass",
            "instHDiv",
            "PadicInt",
            "div_mem",
            "CommSemiring.toSemiring",
            "DivisionSemiring.toGroupWithZero",
            "Membership.mem",
            "nonZeroDivisors",
            "Units",
            "Subtype",
            "HDiv.hDiv",
            "Subgroup",
            "PadicInt.instCommRing",
            "Units.instGroup",
            "LE.le",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "Units.mk0",
            "Group.toDivInvMonoid",
            "Real.instOne",
            "Subgroup.subset_closure",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "DivInvMonoid.toDiv",
            "Padic",
            "One.toOfNat1",
            "Padic.field",
            "PadicInt.instCoeSubtypeMemSubmonoidNonZeroDivisorsUnitsPadic.proof_1",
            "Submonoid.instSetLike",
            "Set.range",
            "OfNat.ofNat",
            "Padic.instNorm",
            "Subtype.val",
            "SetLike.instMembership",
            "Submonoid",
            "Subgroup.instSetLike",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "convert\n  div_mem (H := H) (subset_closure <| Set.mem_range_self \u27e8y, hy\u27e9) (subset_closure <| Set.mem_range_self \u27e8z, hz\u27e9) using 1",
          "proofState": 17,
          "pos": {
            "line": 84,
            "column": 2
          },
          "goals": "case intro.intro.intro\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\ny z : \u2124_[p]\nhz : z \u2208 \u2124_[p]\u2070\nhyzx : (algebraMap \u2124_[p] \u211a_[p]) y / (algebraMap \u2124_[p] \u211a_[p]) z = \u2191x\nhy : y \u2208 \u2124_[p]\u2070\n\u22a2 x \u2208 H",
          "endPos": {
            "line": 85,
            "column": 58
          }
        },
        {
          "usedConstants": [
            "Units.ext"
          ],
          "tactic": "ext",
          "proofState": 18,
          "pos": {
            "line": 86,
            "column": 2
          },
          "goals": "case h.e'_5\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\ny z : \u2124_[p]\nhz : z \u2208 \u2124_[p]\u2070\nhyzx : (algebraMap \u2124_[p] \u211a_[p]) y / (algebraMap \u2124_[p] \u211a_[p]) z = \u2191x\nhy : y \u2208 \u2124_[p]\u2070\n\u22a2 x = Units.mk0 \u2191\u2191\u27e8y, hy\u27e9 \u22ef / Units.mk0 \u2191\u2191\u27e8z, hz\u27e9 \u22ef",
          "endPos": {
            "line": 86,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Units.val",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "Real.instLE",
            "Real",
            "instHDiv",
            "DivisionCommMonoid.toDivisionMonoid",
            "PadicInt",
            "congrArg",
            "CommSemiring.toSemiring",
            "Units.instDiv",
            "DivisionSemiring.toGroupWithZero",
            "Membership.mem",
            "nonZeroDivisors",
            "Units",
            "id",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "PadicInt.instCommRing",
            "LE.le",
            "Units.val_div_eq_div_val",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "Units.mk0",
            "Real.instOne",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Semifield.toCommGroupWithZero",
            "DivInvMonoid.toDiv",
            "Padic",
            "One.toOfNat1",
            "Padic.field",
            "CommGroupWithZero.toDivisionCommMonoid",
            "PadicInt.instCoeSubtypeMemSubmonoidNonZeroDivisorsUnitsPadic.proof_1",
            "Submonoid.instSetLike",
            "OfNat.ofNat",
            "Padic.instNorm",
            "Subtype.val",
            "Eq",
            "SetLike.instMembership",
            "Submonoid",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simpa using hyzx.symm",
          "proofState": 19,
          "pos": {
            "line": 87,
            "column": 2
          },
          "goals": "case h.e'_5.a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nH : Subgroup \u211a_[p]\u02e3 := Subgroup.closure (Set.range fun x => Units.mk0 \u2191\u2191x \u22ef)\nx : \u211a_[p]\u02e3\ny z : \u2124_[p]\nhz : z \u2208 \u2124_[p]\u2070\nhyzx : (algebraMap \u2124_[p] \u211a_[p]) y / (algebraMap \u2124_[p] \u211a_[p]) z = \u2191x\nhy : y \u2208 \u2124_[p]\u2070\n\u22a2 \u2191x = \u2191(Units.mk0 \u2191\u2191\u27e8y, hy\u27e9 \u22ef / Units.mk0 \u2191\u2191\u27e8z, hz\u27e9 \u22ef)",
          "endPos": {
            "line": 87,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Set.ext"
          ],
          "tactic": "ext x",
          "proofState": 20,
          "pos": {
            "line": 94,
            "column": 72
          },
          "goals": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 \u21911 = Metric.closedBall 0 1",
          "endPos": {
            "line": 94,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Norm.norm",
            "SeminormedAddGroup.toNorm",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Submodule",
            "Real.instLE",
            "Real",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "SeminormedAddGroup.toAddGroup",
            "PadicInt",
            "congrArg",
            "CommSemiring.toSemiring",
            "RingHom",
            "Membership.mem",
            "Exists",
            "algebraMap",
            "Algebra.toModule",
            "id",
            "Mathlib.Topology.MetricSpace.Pseudo.Defs._auxLemma.10",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "PadicInt.instCommRing",
            "LE.le",
            "SubNegZeroMonoid.toNegZeroClass",
            "Field.toSemifield",
            "Submodule.one",
            "PadicInt.algebra",
            "Real.instOne",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "CommRing.toCommSemiring",
            "Iff",
            "Padic.instZero",
            "Mathlib.Algebra.Algebra.Operations._auxLemma.2",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "SetLike.coe",
            "SeminormedAddGroup.toPseudoMetricSpace",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "congr",
            "Submodule.setLike",
            "SeminormedCommRing.toSeminormedRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Padic.field",
            "Zero.toOfNat0",
            "Dist.dist",
            "PseudoMetricSpace.toDist",
            "SeminormedRing.toPseudoMetricSpace",
            "NormedField.toNormedCommRing",
            "Metric.closedBall",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "Subtype.val",
            "dist_zero_right",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "Mathlib.Data.SetLike.Basic._auxLemma.3",
            "DFunLike.coe",
            "SetLike.instMembership",
            "Eq.trans",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Set"
          ],
          "tactic": "simp",
          "proofState": 21,
          "pos": {
            "line": 94,
            "column": 79
          },
          "goals": "case h\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nx : \u211a_[p]\n\u22a2 x \u2208 \u21911 \u2194 x \u2208 Metric.closedBall 0 1",
          "endPos": {
            "line": 94,
            "column": 83
          }
        },
        {
          "usedConstants": [
            "Norm.norm",
            "Init.Data.Subtype._auxLemma.2",
            "SeminormedAddGroup.toNorm",
            "NormedCommRing.toSeminormedCommRing",
            "Real.instLE",
            "Real",
            "Iff.of_eq",
            "congrArg",
            "Init.PropLemmas._auxLemma.45",
            "Exists",
            "Subtype",
            "LE.le",
            "Subtype.mk",
            "iff_self",
            "Real.instOne",
            "SeminormedAddCommGroup.toSeminormedAddGroup",
            "funext",
            "And",
            "Iff",
            "Padic.normedField",
            "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
            "exists_prop_congr",
            "True",
            "propext",
            "NonUnitalSeminormedRing.toSeminormedAddCommGroup",
            "Padic",
            "of_eq_true",
            "One.toOfNat1",
            "Eq.refl",
            "NormedField.toNormedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Padic.instNorm",
            "Subtype.val",
            "Eq",
            "Init.PropLemmas._auxLemma.26",
            "Eq.trans"
          ],
          "tactic": "simp [PadicInt]",
          "proofState": 22,
          "pos": {
            "line": 94,
            "column": 85
          },
          "goals": "case h\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nx : \u211a_[p]\n\u22a2 (\u2203 y, \u2191y = x) \u2194 \u2016x\u2016 \u2264 1",
          "endPos": {
            "line": 94,
            "column": 100
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 62,
            "column": 2
          },
          "goal": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nx : \u2124_[p]\ns : Submodule \u2124_[p] \u211a_[p]\n\u22a2 \u2191((x \u2022 s.toAddSubgroup).relindex s.toAddSubgroup) = \u2016x\u2016\u208a\u207b\u00b9",
          "endPos": {
            "line": 62,
            "column": 7
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 58,
            "column": 6
          },
          "endPos": {
            "line": 58,
            "column": 29
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/Mathlib/MeasureTheory/Group/Action.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [],
          "tactic": "measurability",
          "proofState": 4,
          "pos": {
            "line": 23,
            "column": 74
          },
          "goals": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nH K : Subgroup G\ninst\u271d : MeasurableMul\u2082 G\n\u22a2 Measurable fun p => p.1 * p.2",
          "endPos": {
            "line": 23,
            "column": 87
          }
        },
        {
          "usedConstants": [],
          "tactic": "measurability",
          "proofState": 5,
          "pos": {
            "line": 32,
            "column": 31
          },
          "goals": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nH K : Subgroup G\ninst\u271d : MeasurableMul G\nc : \u21a5H\n\u22a2 Measurable fun x => x * c",
          "endPos": {
            "line": 32,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "Subgroup.exists_isComplement_left",
            "OfNat.ofNat"
          ],
          "tactic": "obtain \u27e8s, hs, -\u27e9 := H.exists_isComplement_left 1",
          "proofState": 6,
          "pos": {
            "line": 48,
            "column": 2
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\n\u22a2 \u2191H.index * \u03bc \u2191H = \u03bc univ",
          "endPos": {
            "line": 48,
            "column": 51
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "MeasureTheory.Measure",
            "HMul.hMul",
            "Subgroup.FiniteIndex",
            "Set.univ",
            "Finite",
            "inferInstance",
            "Set.Elem",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "SetLike.coe",
            "Distrib.toMul",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instENNRealAddCommMonoidWithOne",
            "Subgroup.IsComplement.finite_left_iff",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "letFun",
            "Subgroup.instSetLike",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "have hs' : Finite s := hs.finite_left_iff.mpr inferInstance",
          "proofState": 7,
          "pos": {
            "line": 49,
            "column": 2
          },
          "goals": "case intro.intro\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\n\u22a2 \u2191H.index * \u03bc \u2191H = \u03bc univ",
          "endPos": {
            "line": 49,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Eq.mpr",
            "Set.encard",
            "instHSMul",
            "Trans.trans",
            "MeasureTheory.Measure",
            "HMul.hMul",
            "ENat.instNatCast",
            "Iff.of_eq",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Subtype.val_injective",
            "Set.univ",
            "Set.smul",
            "Set.iUnion_coe_set",
            "Function.Injective.ne",
            "Membership.mem",
            "Set.Elem",
            "id",
            "Subtype",
            "Nat.card",
            "ENat.toENNReal",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "Ne",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "MulAction.toSMul",
            "Nat.cast",
            "MeasureTheory.measure_iUnion",
            "Subgroup.IsComplement.pairwiseDisjoint_smul",
            "Set.iUnion_smul_set",
            "Subtype.mk",
            "Group.toDivInvMonoid",
            "instTransEq",
            "funext",
            "measurableSMul_of_mul",
            "SetLike.coe",
            "Distrib.toMul",
            "tsum",
            "Subgroup.IsComplement.card_left",
            "MeasureTheory.measure_smul",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "ENat",
            "True",
            "Subgroup.index",
            "eq_self",
            "ENNReal",
            "of_eq_true",
            "ENNReal.instOrderedCommSemiring",
            "Monoid.toMulAction",
            "OrderedAddCommMonoid.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instENNRealAddCommMonoidWithOne",
            "Eq.refl",
            "HSMul.hSMul",
            "Subgroup.IsComplement.mul_eq",
            "Set.Nat.card_coe_set_eq",
            "ENNReal.instTopologicalSpace",
            "Finite.to_countable",
            "MeasurableSet.const_smul",
            "Set.iUnion_congr_Prop",
            "Set.ncard",
            "Eq.symm",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Set.Finite.cast_ncard_eq",
            "Eq",
            "Set.instMembership",
            "Set.smulSet",
            "DFunLike.coe",
            "ENNReal.tsum_set_const_eq",
            "Set.iUnion",
            "Subgroup.instSetLike",
            "Eq.trans",
            "Subtype.property",
            "MeasureTheory.Measure.IsMulLeftInvariant.smulInvariantMeasure",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "calc\n  H.index * \u03bc H = \u2211' a : s, \u03bc (a.val \u2022 H) := by\n    simp [measure_smul]\n    rw [\u2190 Set.Finite.cast_ncard_eq hs', \u2190 Nat.card_coe_set_eq, hs.card_left]\n    norm_cast\n  _ = \u03bc univ := by\n    rw [\u2190 measure_iUnion _ fun _ \u21a6 hH.const_smul _]\n    \u00b7 simp [hs.mul_eq]\n    \u00b7 exact fun a b hab \u21a6 hs.pairwiseDisjoint_smul a.2 b.2 (Subtype.val_injective.ne hab)",
          "proofState": 8,
          "pos": {
            "line": 50,
            "column": 2
          },
          "goals": "case intro.intro\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\nhs' : Finite \u2191s\n\u22a2 \u2191H.index * \u03bc \u2191H = \u03bc univ",
          "endPos": {
            "line": 58,
            "column": 91
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  H.index * \u03bc H = \u2211' a : s, \u03bc (a.val \u2022 H) := by\n    simp [measure_smul]\n    rw [\u2190 Set.Finite.cast_ncard_eq hs', \u2190 Nat.card_coe_set_eq, hs.card_left]\n    norm_cast\n  _ = \u03bc univ := by\n    rw [\u2190 measure_iUnion _ fun _ \u21a6 hH.const_smul _]\n    \u00b7 simp [hs.mul_eq]\n    \u00b7 exact fun a b hab \u21a6 hs.pairwiseDisjoint_smul a.2 b.2 (Subtype.val_injective.ne hab)",
          "proofState": 9,
          "pos": {
            "line": 51,
            "column": 4
          },
          "goals": "no goals",
          "endPos": {
            "line": 58,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Eq.mpr",
            "Set.encard",
            "instHSMul",
            "MeasureTheory.Measure",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "congrArg",
            "Membership.mem",
            "Set.Elem",
            "id",
            "ENat.toENNReal",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "MulAction.toSMul",
            "Nat.cast",
            "Group.toDivInvMonoid",
            "funext",
            "SetLike.coe",
            "Distrib.toMul",
            "tsum",
            "MeasureTheory.measure_smul",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "Monoid.toMulAction",
            "OrderedAddCommMonoid.toAddCommMonoid",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instENNRealAddCommMonoidWithOne",
            "HSMul.hSMul",
            "ENNReal.instTopologicalSpace",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "Set.smulSet",
            "DFunLike.coe",
            "ENNReal.tsum_set_const_eq",
            "Subgroup.instSetLike",
            "Eq.trans",
            "MeasureTheory.Measure.IsMulLeftInvariant.smulInvariantMeasure",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "simp [measure_smul]",
          "proofState": 10,
          "pos": {
            "line": 52,
            "column": 6
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\nhs' : Finite \u2191s\n\u22a2 \u2191H.index * \u03bc \u2191H = \u2211' (a : \u2191s), \u03bc (\u2191a \u2022 \u2191H)",
          "endPos": {
            "line": 52,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Set.encard",
            "MeasureTheory.Measure",
            "HMul.hMul",
            "ENat.instNatCast",
            "congrArg",
            "id",
            "ENat.toENNReal",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "SetLike.coe",
            "Distrib.toMul",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "ENat",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instENNRealAddCommMonoidWithOne",
            "Set.ncard",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Set.Finite.cast_ncard_eq",
            "Eq",
            "DFunLike.coe",
            "Subgroup.instSetLike",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "rw [\u2190 Set.Finite.cast_ncard_eq hs', \u2190 Nat.card_coe_set_eq, hs.card_left]",
          "proofState": 11,
          "pos": {
            "line": 53,
            "column": 6
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\nhs' : Finite \u2191s\n\u22a2 \u2191H.index * \u03bc \u2191H = \u2191s.encard * \u03bc \u2191H",
          "endPos": {
            "line": 53,
            "column": 78
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure",
            "HMul.hMul",
            "ENat.instNatCast",
            "id",
            "ENat.toENNReal",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "SetLike.coe",
            "Distrib.toMul",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "ENat",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instENNRealAddCommMonoidWithOne",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Subgroup.instSetLike",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "norm_cast",
          "proofState": 12,
          "pos": {
            "line": 54,
            "column": 6
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\nhs' : Finite \u2191s\n\u22a2 \u2191H.index * \u03bc \u2191H = \u2191\u2191H.index * \u03bc \u2191H",
          "endPos": {
            "line": 54,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Eq.mpr",
            "instHSMul",
            "MeasureTheory.Measure",
            "congrArg",
            "Set.univ",
            "Membership.mem",
            "Set.Elem",
            "id",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "MulAction.toSMul",
            "MeasureTheory.measure_iUnion",
            "Group.toDivInvMonoid",
            "SetLike.coe",
            "tsum",
            "OrderedCommSemiring.toOrderedSemiring",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "Monoid.toMulAction",
            "OrderedAddCommMonoid.toAddCommMonoid",
            "HSMul.hSMul",
            "ENNReal.instTopologicalSpace",
            "MeasurableSet.const_smul",
            "Eq.symm",
            "Subtype.val",
            "Eq",
            "Set.instMembership",
            "Set.smulSet",
            "DFunLike.coe",
            "Set.iUnion",
            "Subgroup.instSetLike",
            "MeasureTheory.Measure.instFunLike",
            "Set"
          ],
          "tactic": "rw [\u2190 measure_iUnion _ fun _ \u21a6 hH.const_smul _]",
          "proofState": 13,
          "pos": {
            "line": 56,
            "column": 6
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\nhs' : Finite \u2191s\n\u22a2 \u2211' (a : \u2191s), \u03bc (\u2191a \u2022 \u2191H) = \u03bc univ",
          "endPos": {
            "line": 56,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "instHSMul",
            "MeasureTheory.Measure",
            "Iff.of_eq",
            "congrArg",
            "Set.univ",
            "Set.smul",
            "Set.iUnion_coe_set",
            "Membership.mem",
            "Set.Elem",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "MulAction.toSMul",
            "Set.iUnion_smul_set",
            "Subtype.mk",
            "Group.toDivInvMonoid",
            "funext",
            "SetLike.coe",
            "True",
            "eq_self",
            "ENNReal",
            "of_eq_true",
            "Monoid.toMulAction",
            "Eq.refl",
            "HSMul.hSMul",
            "Subgroup.IsComplement.mul_eq",
            "Set.iUnion_congr_Prop",
            "Subtype.val",
            "Eq",
            "Set.instMembership",
            "Set.smulSet",
            "DFunLike.coe",
            "Set.iUnion",
            "Subgroup.instSetLike",
            "Eq.trans",
            "MeasureTheory.Measure.instFunLike",
            "Set"
          ],
          "tactic": "simp [hs.mul_eq]",
          "proofState": 14,
          "pos": {
            "line": 57,
            "column": 8
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\nhs' : Finite \u2191s\n\u22a2 \u03bc (\u22c3 i, \u2191i \u2022 \u2191H) = \u03bc univ",
          "endPos": {
            "line": 57,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "Subtype.val_injective",
            "Function.Injective.ne",
            "Membership.mem",
            "Set.Elem",
            "Subtype",
            "Subgroup",
            "Ne",
            "Subgroup.IsComplement.pairwiseDisjoint_smul",
            "SetLike.coe",
            "Subtype.val",
            "Set.instMembership",
            "Subgroup.instSetLike",
            "Subtype.property",
            "Set"
          ],
          "tactic": "exact fun a b hab \u21a6 hs.pairwiseDisjoint_smul a.2 b.2 (Subtype.val_injective.ne hab)",
          "proofState": 15,
          "pos": {
            "line": 58,
            "column": 8
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteIndex\nhH : MeasurableSet \u2191H\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ns : Set G\nhs : IsComplement s \u2191H\nhs' : Finite \u2191s\n\u22a2 Pairwise (Function.onFun Disjoint fun x => \u2191x \u2022 \u2191H)",
          "endPos": {
            "line": 58,
            "column": 91
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.instIsMulLeftInvariantSubtypeMemSubgroupComapVal",
            "measurable_subtype_coe",
            "MeasureTheory.index_mul_haar_subgroup",
            "MeasureTheory.Measure",
            "Subgroup.subgroupOf",
            "HMul.hMul",
            "Monoid.toMulOneClass",
            "Set.univ",
            "Submonoid.toSubsemigroup",
            "Subgroup.relindex",
            "Membership.mem",
            "Subtype",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Subgroup.FiniteRelIndex.to_finiteIndex_subgroupOf",
            "Nat.cast",
            "Group.toDivInvMonoid",
            "SetLike.coe",
            "Distrib.toMul",
            "MeasureTheory.Measure.comap",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Subtype.instMeasurableSpace",
            "instENNRealAddCommMonoidWithOne",
            "Subgroup.toGroup",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "SetLike.instMembership",
            "letFun",
            "Subgroup.instSetLike",
            "Subgroup.toSubmonoid",
            "MeasureTheory.instMeasurableMulSubtypeMemSubgroup",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "have := index_mul_haar_subgroup (H := H.subgroupOf K) (measurable_subtype_coe hH) (\u03bc.comap Subtype.val)",
          "proofState": 16,
          "pos": {
            "line": 64,
            "column": 2
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\n\u22a2 \u2191(H.relindex K) * \u03bc \u2191H = \u03bc \u2191K",
          "endPos": {
            "line": 65,
            "column": 25
          }
        },
        {
          "usedConstants": [],
          "tactic": "simp at this",
          "proofState": 17,
          "pos": {
            "line": 66,
            "column": 2
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * (Measure.comap Subtype.val \u03bc) \u2191(H.subgroupOf K) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 \u2191(H.relindex K) * \u03bc \u2191H = \u03bc \u2191K",
          "endPos": {
            "line": 66,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure",
            "Subgroup.subgroupOf",
            "HMul.hMul",
            "congrArg",
            "Set.univ",
            "Membership.mem",
            "Eq.mp",
            "Subtype",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "MeasurableEmbedding.comap_apply",
            "SetLike.coe",
            "Distrib.toMul",
            "MeasureTheory.Measure.comap",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Subtype.instMeasurableSpace",
            "instENNRealAddCommMonoidWithOne",
            "Set.image",
            "Subgroup.toGroup",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "SetLike.instMembership",
            "Subgroup.instSetLike",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "rw [MeasurableEmbedding.comap_apply, MeasurableEmbedding.comap_apply] at this",
          "proofState": 18,
          "pos": {
            "line": 67,
            "column": 2
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * (Measure.comap Subtype.val \u03bc) \u2191(H.subgroupOf K) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 \u2191(H.relindex K) * \u03bc \u2191H = \u03bc \u2191K",
          "endPos": {
            "line": 67,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "Set.image_univ",
            "MeasureTheory.Measure",
            "Subgroup.subgroupOf",
            "HMul.hMul",
            "congrArg",
            "Set.univ",
            "setOf",
            "Membership.mem",
            "Eq.mp",
            "Subtype",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Subtype.range_coe_subtype",
            "Nat.cast",
            "SetLike.coe",
            "Distrib.toMul",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instENNRealAddCommMonoidWithOne",
            "Set.image",
            "Set.range",
            "Subgroup.toGroup",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "SetLike.instMembership",
            "Subgroup.instSetLike",
            "Eq.trans",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "simp at this",
          "proofState": 19,
          "pos": {
            "line": 68,
            "column": 2
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * \u03bc (Subtype.val '' \u2191(H.subgroupOf K)) = \u03bc (Subtype.val '' univ)\n\u22a2 \u2191(H.relindex K) * \u03bc \u2191H = \u03bc \u2191K\ncase hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * \u03bc (Subtype.val '' \u2191(H.subgroupOf K)) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val\ncase hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * (Measure.comap Subtype.val \u03bc) \u2191(H.subgroupOf K) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val",
          "endPos": {
            "line": 68,
            "column": 14
          }
        },
        {
          "usedConstants": [],
          "tactic": "unfold subgroupOf at this",
          "proofState": 20,
          "pos": {
            "line": 69,
            "column": 2
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * \u03bc (Subtype.val '' \u2191(H.subgroupOf K)) = \u03bc \u2191K\n\u22a2 \u2191(H.relindex K) * \u03bc \u2191H = \u03bc \u2191K\ncase hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * \u03bc (Subtype.val '' \u2191(H.subgroupOf K)) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val\ncase hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * (Measure.comap Subtype.val \u03bc) \u2191(H.subgroupOf K) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val",
          "endPos": {
            "line": 69,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "MeasureTheory.Measure",
            "MonoidHom.instFunLike",
            "HMul.hMul",
            "MonoidHom",
            "Monoid.toMulOneClass",
            "congrArg",
            "Subgroup.subtype",
            "Membership.mem",
            "Eq.mp",
            "Subtype",
            "DivInvMonoid.toMonoid",
            "Subgroup",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Nat.cast",
            "Group.toDivInvMonoid",
            "SetLike.coe",
            "Set.preimage",
            "Distrib.toMul",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Subgroup.index",
            "ENNReal",
            "ENNReal.instOrderedCommSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instENNRealAddCommMonoidWithOne",
            "Set.image",
            "Subgroup.toGroup",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Subgroup.coe_comap",
            "DFunLike.coe",
            "Subgroup.comap",
            "SetLike.instMembership",
            "Subgroup.instSetLike",
            "MeasureTheory.Measure.instFunLike",
            "instHMul",
            "Set"
          ],
          "tactic": "rwa [coe_comap, coe_subtype, Set.image_preimage_eq_of_subset (by simpa)] at this",
          "proofState": 21,
          "pos": {
            "line": 70,
            "column": 2
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(comap K.subtype H).index * \u03bc (Subtype.val '' \u2191(comap K.subtype H)) = \u03bc \u2191K\n\u22a2 \u2191(H.relindex K) * \u03bc \u2191H = \u03bc \u2191K\ncase hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * \u03bc (Subtype.val '' \u2191(H.subgroupOf K)) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val\ncase hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * (Measure.comap Subtype.val \u03bc) \u2191(H.subgroupOf K) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val",
          "endPos": {
            "line": 70,
            "column": 82
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "congrArg",
            "PartialOrder.toPreorder",
            "setOf",
            "Preorder.toLE",
            "Membership.mem",
            "id",
            "Subtype",
            "Subgroup",
            "HasSubset.Subset",
            "Subtype.range_coe_subtype",
            "LE.le",
            "SetLike.coe",
            "SetLike.instPartialOrder",
            "Mathlib.Data.SetLike.Basic._auxLemma.6",
            "Set.range",
            "Subtype.val",
            "Eq",
            "SetLike.instMembership",
            "Subgroup.instSetLike",
            "Eq.trans",
            "Set.instHasSubset",
            "Set"
          ],
          "tactic": "simpa",
          "proofState": 22,
          "pos": {
            "line": 70,
            "column": 67
          },
          "goals": "G : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(comap K.subtype H).index * \u03bc (Subtype.val '' (Subtype.val \u207b\u00b9' \u2191H)) = \u03bc \u2191K\n\u22a2 \u2191H \u2286 range Subtype.val",
          "endPos": {
            "line": 70,
            "column": 72
          }
        },
        {
          "usedConstants": [
            "Subgroup",
            "SetLike.coe",
            "Subgroup.instSetLike",
            "MeasurableEmbedding.subtype_coe"
          ],
          "tactic": "exact .subtype_coe hK",
          "proofState": 23,
          "pos": {
            "line": 71,
            "column": 2
          },
          "goals": "case hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * \u03bc (Subtype.val '' \u2191(H.subgroupOf K)) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val\ncase hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * (Measure.comap Subtype.val \u03bc) \u2191(H.subgroupOf K) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val",
          "endPos": {
            "line": 71,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "Subgroup",
            "SetLike.coe",
            "Subgroup.instSetLike",
            "MeasurableEmbedding.subtype_coe"
          ],
          "tactic": "exact .subtype_coe hK",
          "proofState": 24,
          "pos": {
            "line": 72,
            "column": 2
          },
          "goals": "case hf\nG : Type u_1\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\nH K : Subgroup G\ninst\u271d\u00b2 : MeasurableMul G\ninst\u271d\u00b9 : H.FiniteRelIndex K\nhHK : H \u2264 K\nhH : MeasurableSet \u2191H\nhK : MeasurableSet \u2191K\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\nthis : \u2191(H.subgroupOf K).index * (Measure.comap Subtype.val \u03bc) \u2191(H.subgroupOf K) = (Measure.comap Subtype.val \u03bc) univ\n\u22a2 MeasurableEmbedding Subtype.val",
          "endPos": {
            "line": 72,
            "column": 23
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 26,
            "column": 69
          },
          "goal": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nH K : Subgroup G\ninst\u271d : MeasurableInv G\n\u22a2 Measurable Inv.inv",
          "endPos": {
            "line": 26,
            "column": 74
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 33,
            "column": 28
          },
          "goal": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nH K : Subgroup G\ninst\u271d : MeasurableMul G\nc : \u21a5H\n\u22a2 Measurable fun x => c * x",
          "endPos": {
            "line": 33,
            "column": 33
          }
        },
        {
          "proofState": 2,
          "pos": {
            "line": 38,
            "column": 28
          },
          "goal": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\ninst\u271d\u00b2 : MeasurableSpace \u03b1\nH K : Subgroup G\ninst\u271d\u00b9 : MeasurableMul G\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulLeftInvariant\ng : \u21a5H\n\u22a2 Measure.map (fun x => g * x) (Measure.comap Subtype.val \u03bc) = Measure.comap Subtype.val \u03bc",
          "endPos": {
            "line": 38,
            "column": 33
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 43,
            "column": 29
          },
          "goal": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MeasurableSpace G\ninst\u271d\u00b2 : MeasurableSpace \u03b1\nH K : Subgroup G\ninst\u271d\u00b9 : MeasurableMul G\n\u03bc : Measure G\ninst\u271d : \u03bc.IsMulRightInvariant\ng : \u21a5H\n\u22a2 Measure.map (fun x => x * g) (Measure.comap Subtype.val \u03bc) = Measure.comap Subtype.val \u03bc",
          "endPos": {
            "line": 43,
            "column": 34
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 26,
            "column": 0
          },
          "endPos": {
            "line": 26,
            "column": 8
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 25,
            "column": 2
          },
          "endPos": {
            "line": 25,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 31,
            "column": 0
          },
          "endPos": {
            "line": 31,
            "column": 8
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 30,
            "column": 2
          },
          "endPos": {
            "line": 30,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 36,
            "column": 0
          },
          "endPos": {
            "line": 36,
            "column": 8
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 35,
            "column": 2
          },
          "endPos": {
            "line": 35,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 41,
            "column": 0
          },
          "endPos": {
            "line": 41,
            "column": 8
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 40,
            "column": 2
          },
          "endPos": {
            "line": 40,
            "column": 13
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/AutomorphicForm/QuaternionAlgebra/FiniteDimensional.lean",
    "output": {
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 24,
            "column": 57
          },
          "goal": "F : Type u_1\ninst\u271d\u00b9\u2070 : Field F\ninst\u271d\u2079 : NumberField F\ninst\u271d\u2078 : NumberField.IsTotallyReal F\nD : Type u_2\ninst\u271d\u2077 : Ring D\ninst\u271d\u2076 : Algebra F D\nR : Type u_3\ninst\u271d\u2075 : Field R\nW : Type u_4\ninst\u271d\u2074 : AddCommGroup W\ninst\u271d\u00b3 : Module R W\ninst\u271d\u00b2 : DistribMulAction D\u02e3 W\ninst\u271d\u00b9 : SMulCommClass R D\u02e3 W\nU : Subgroup (D \u2297[F] FiniteAdeleRing (\ud835\udcde F) F)\u02e3\n\u03c7 : (FiniteAdeleRing (\ud835\udcde F) F)\u02e3 \u2192* R\ninst\u271d : FiniteDimensional R W\n\u22a2 FiniteDimensional R (AutomorphicForm F D R W U \u03c7)",
          "endPos": {
            "line": 24,
            "column": 62
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 23,
            "column": 8
          },
          "endPos": {
            "line": 23,
            "column": 41
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  },
  {
    "file": "FLT/DedekindDomain/FiniteAdeleRing/BaseChange.lean",
    "output": {
      "tactics": [
        {
          "usedConstants": [
            "IsDomain",
            "CommSemiring.toSemiring",
            "RingHom",
            "algebraMap",
            "IsIntegralClosure.algebraMap_injective'",
            "Field.toSemifield",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "DivisionSemiring.toSemiring",
            "Function.Injective",
            "EuclideanDomain.toCommRing",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "letFun",
            "Field.toEuclideanDomain"
          ],
          "tactic": "have foo : Function.Injective (algebraMap B L) := IsIntegralClosure.algebraMap_injective' A",
          "proofState": 13,
          "pos": {
            "line": 40,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2075 : CommRing A\ninst\u271d\u00b9\u2074 : CommRing B\ninst\u271d\u00b9\u00b3 : Algebra A B\ninst\u271d\u00b9\u00b2 : Field K\ninst\u271d\u00b9\u00b9 : Field L\ninst\u271d\u00b9\u2070 : Algebra A K\ninst\u271d\u2079 : IsFractionRing A K\ninst\u271d\u2078 : Algebra B L\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : Algebra.IsSeparable K L\n\u22a2 IsDomain B",
          "endPos": {
            "line": 40,
            "column": 93
          }
        },
        {
          "usedConstants": [
            "IsDomain",
            "Field.isDomain",
            "CommSemiring.toSemiring",
            "inferInstance",
            "Field.toSemifield",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "DivisionSemiring.toSemiring",
            "letFun"
          ],
          "tactic": "have bar : IsDomain L := inferInstance",
          "proofState": 14,
          "pos": {
            "line": 41,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2075 : CommRing A\ninst\u271d\u00b9\u2074 : CommRing B\ninst\u271d\u00b9\u00b3 : Algebra A B\ninst\u271d\u00b9\u00b2 : Field K\ninst\u271d\u00b9\u00b9 : Field L\ninst\u271d\u00b9\u2070 : Algebra A K\ninst\u271d\u2079 : IsFractionRing A K\ninst\u271d\u2078 : Algebra B L\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : Algebra.IsSeparable K L\nfoo : Function.Injective \u21d1(algebraMap B L)\n\u22a2 IsDomain B",
          "endPos": {
            "line": 41,
            "column": 40
          }
        },
        {
          "usedConstants": [
            "RingHom.instRingHomClass",
            "CommSemiring.toSemiring",
            "Function.Injective.isDomain",
            "RingHom",
            "algebraMap",
            "RingHomClass.toMonoidWithZeroHomClass",
            "Field.toSemifield",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "DivisionSemiring.toSemiring",
            "Semiring.toNonAssocSemiring"
          ],
          "tactic": "exact Function.Injective.isDomain _ foo",
          "proofState": 15,
          "pos": {
            "line": 42,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2075 : CommRing A\ninst\u271d\u00b9\u2074 : CommRing B\ninst\u271d\u00b9\u00b3 : Algebra A B\ninst\u271d\u00b9\u00b2 : Field K\ninst\u271d\u00b9\u00b9 : Field L\ninst\u271d\u00b9\u2070 : Algebra A K\ninst\u271d\u2079 : IsFractionRing A K\ninst\u271d\u2078 : Algebra B L\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : Algebra K L\ninst\u271d\u2075 : Algebra A L\ninst\u271d\u2074 : IsScalarTower A B L\ninst\u271d\u00b3 : IsScalarTower A K L\ninst\u271d\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9 : FiniteDimensional K L\ninst\u271d : Algebra.IsSeparable K L\nfoo : Function.Injective \u21d1(algebraMap B L)\nbar : IsDomain L\n\u22a2 IsDomain B",
          "endPos": {
            "line": 42,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "UniqueFactorizationMonoid.induction_on_prime",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "Ideal.uniqueFactorizationMonoid"
          ],
          "tactic": "classical\n  induction I using UniqueFactorizationMonoid.induction_on_prime with\n| h\u2081 =>\n  rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot, Associates.mk_zero]\n  simp [Associates.count, Associates.factors_zero, w.associates_irreducible, associates_irreducible (comap A w),\n    Associates.bcount]\n| h\u2082 I hI =>\n  obtain rfl : I = \u22a4 := by simpa using hI\n  simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n  simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n  rw [Associates.count_zero (associates_irreducible _), Associates.count_zero (associates_irreducible _), mul_zero]\n| h\u2083 I p hI hp IH =>\n  simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n  have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n  have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n  have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n  rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI) (associates_irreducible _),\n    Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot') (Associates.mk_ne_zero.mpr hI_bot)\n      (associates_irreducible _)]\n  simp only [IH, mul_add]\n  congr 1\n  by_cases hw : (w.comap A).asIdeal = p\n  \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n    rw [hw, Associates.factors_self this, Associates.count_some this]\n    simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton, Multiset.mem_singleton,\n      Multiset.count_eq_one_of_mem, mul_one]\n    rw [count_associates_factors_eq hp_bot' w.2 w.3,\n      Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n  \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n      Associates.count_eq_zero_of_ne (associates_irreducible _) (Associates.irreducible_mk.mpr hp.irreducible)\n        (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n    rw [this, mul_zero, eq_comm]\n    by_contra H\n    rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w), Ideal.dvd_iff_le,\n      Ideal.map_le_iff_le_comap] at H\n    apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm",
          "proofState": 16,
          "pos": {
            "line": 80,
            "column": 2
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nI : Ideal A\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors",
          "endPos": {
            "line": 118,
            "column": 100
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "UniqueFactorizationMonoid.induction_on_prime",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "Ideal.uniqueFactorizationMonoid"
          ],
          "tactic": "induction I using UniqueFactorizationMonoid.induction_on_prime with\n| h\u2081 =>\n  rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot, Associates.mk_zero]\n  simp [Associates.count, Associates.factors_zero, w.associates_irreducible, associates_irreducible (comap A w),\n    Associates.bcount]\n| h\u2082 I hI =>\n  obtain rfl : I = \u22a4 := by simpa using hI\n  simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n  simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n  rw [Associates.count_zero (associates_irreducible _), Associates.count_zero (associates_irreducible _), mul_zero]\n| h\u2083 I p hI hp IH =>\n  simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n  have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n  have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n  have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n  rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI) (associates_irreducible _),\n    Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot') (Associates.mk_ne_zero.mpr hI_bot)\n      (associates_irreducible _)]\n  simp only [IH, mul_add]\n  congr 1\n  by_cases hw : (w.comap A).asIdeal = p\n  \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n    rw [hw, Associates.factors_self this, Associates.count_some this]\n    simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton, Multiset.mem_singleton,\n      Multiset.count_eq_one_of_mem, mul_one]\n    rw [count_associates_factors_eq hp_bot' w.2 w.3,\n      Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n  \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n      Associates.count_eq_zero_of_ne (associates_irreducible _) (Associates.irreducible_mk.mpr hp.irreducible)\n        (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n    rw [this, mul_zero, eq_comm]\n    by_contra H\n    rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w), Ideal.dvd_iff_le,\n      Ideal.map_le_iff_le_comap] at H\n    apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm",
          "proofState": 17,
          "pos": {
            "line": 81,
            "column": 2
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nI : Ideal A\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors",
          "endPos": {
            "line": 118,
            "column": 100
          }
        },
        {
          "usedConstants": [],
          "tactic": "induction I using UniqueFactorizationMonoid.induction_on_prime with\n| h\u2081 =>\n  rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot, Associates.mk_zero]\n  simp [Associates.count, Associates.factors_zero, w.associates_irreducible, associates_irreducible (comap A w),\n    Associates.bcount]\n| h\u2082 I hI =>\n  obtain rfl : I = \u22a4 := by simpa using hI\n  simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]\n  simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]\n  rw [Associates.count_zero (associates_irreducible _), Associates.count_zero (associates_irreducible _), mul_zero]\n| h\u2083 I p hI hp IH =>\n  simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]\n  have hp_bot : p \u2260 \u22a5 := hp.ne_zero\n  have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot\n  have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI\n  rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI) (associates_irreducible _),\n    Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot') (Associates.mk_ne_zero.mpr hI_bot)\n      (associates_irreducible _)]\n  simp only [IH, mul_add]\n  congr 1\n  by_cases hw : (w.comap A).asIdeal = p\n  \u00b7 have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible\n    rw [hw, Associates.factors_self this, Associates.count_some this]\n    simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton, Multiset.mem_singleton,\n      Multiset.count_eq_one_of_mem, mul_one]\n    rw [count_associates_factors_eq hp_bot' w.2 w.3,\n      Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]\n  \u00b7 have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n      Associates.count_eq_zero_of_ne (associates_irreducible _) (Associates.irreducible_mk.mpr hp.irreducible)\n        (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])\n    rw [this, mul_zero, eq_comm]\n    by_contra H\n    rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w), Ideal.dvd_iff_le,\n      Ideal.map_le_iff_le_comap] at H\n    apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm",
          "proofState": 18,
          "pos": {
            "line": 81,
            "column": 2
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nI : Ideal A\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors",
          "endPos": {
            "line": 118,
            "column": 100
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "HMul.hMul",
            "Associates.mk_zero",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.instZero",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Associates",
            "IdemSemiring.toSemiring",
            "Nat",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Associates.factors",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw [Associates.mk_zero, Ideal.zero_eq_bot, Ideal.map_bot, \u2190 Ideal.zero_eq_bot, Associates.mk_zero]",
          "proofState": 19,
          "pos": {
            "line": 83,
            "column": 4
          },
          "goals": "case h\u2081\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) 0)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk 0).factors",
          "endPos": {
            "line": 84,
            "column": 25
          }
        },
        {
          "usedConstants": [
            "dite_cond_eq_true",
            "Associates.mk",
            "Nat.instMulZeroClass",
            "Semiring.toModule",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.instZero",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Associates.factors_zero",
            "CommSemiring.toCommMonoidWithZero",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Multiset.count",
            "Multiset",
            "Algebra.id",
            "Subtype",
            "Associates.FactorSet.prod.match_1",
            "Pi.instZero",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "instOfNatNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "dite",
            "MulZeroClass.mul_zero",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Ideal.cancelCommMonoidWithZero",
            "Unit",
            "CommRing.toCommSemiring",
            "WithTop.top",
            "Submodule.idemSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Associates",
            "IdemSemiring.toSemiring",
            "congrFun",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "congr",
            "True",
            "eq_self",
            "eq_true",
            "of_eq_true",
            "IdemCommSemiring.toCommSemiring",
            "Associates.FactorSet",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "Top.top",
            "Associates.factors",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Submodule.pointwiseZero",
            "Subtype.instDecidableEq",
            "Ideal.ramificationIdx",
            "Not",
            "IsDedekindDomain.HeightOneSpectrum.associates_irreducible",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Associates.bcount",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "simp [Associates.count, Associates.factors_zero, w.associates_irreducible, associates_irreducible (comap A w),\n  Associates.bcount]",
          "proofState": 20,
          "pos": {
            "line": 85,
            "column": 4
          },
          "goals": "case h\u2081\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.factors 0) =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.factors 0)",
          "endPos": {
            "line": 86,
            "column": 60
          }
        },
        {
          "usedConstants": [],
          "tactic": "obtain rfl : I = \u22a4 := by simpa using hI",
          "proofState": 21,
          "pos": {
            "line": 88,
            "column": 4
          },
          "goals": "case h\u2082\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI : Ideal A\nhI : IsUnit I\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors",
          "endPos": {
            "line": 88,
            "column": 43
          }
        },
        {
          "usedConstants": [],
          "tactic": "simpa using hI",
          "proofState": 22,
          "pos": {
            "line": 88,
            "column": 29
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI : Ideal A\nhI : IsUnit I\n\u22a2 I = \u22a4",
          "endPos": {
            "line": 88,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "RingHom.instRingHomClass",
            "Semiring.toModule",
            "instSubsingletonDecidable",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "CancelCommMonoidWithZero",
            "Associates.count",
            "Decidable",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Eq.rec",
            "Irreducible",
            "Algebra.id",
            "id",
            "Ideal.map",
            "Pi.instSubsingleton",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "UniqueFactorizationMonoid",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Submodule.instTop",
            "Ideal",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "Associates",
            "IdemSemiring.toSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "Eq.ndrec",
            "Associates.FactorSet",
            "Ideal.uniqueFactorizationMonoid",
            "Eq.refl",
            "Ideal.map_top",
            "Subsingleton.elim",
            "Top.top",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "DecidableEq",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "simp only [Submodule.zero_eq_bot, ne_eq, top_ne_bot, not_false_eq_true, Ideal.map_top]",
          "proofState": 23,
          "pos": {
            "line": 89,
            "column": 4
          },
          "goals": "case h\u2082\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nhI : IsUnit \u22a4\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) \u22a4)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk \u22a4).factors",
          "endPos": {
            "line": 89,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "IsDedekindDomain.toIsDomain",
            "Semiring.toModule",
            "instSubsingletonDecidable",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "CancelCommMonoidWithZero",
            "Associates.count",
            "Decidable",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Eq.rec",
            "Irreducible",
            "Multiset",
            "Algebra.id",
            "id",
            "Subtype",
            "Pi.instSubsingleton",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "UniqueFactorizationMonoid",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Submodule.instTop",
            "Ideal",
            "Submodule.one",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "Submodule.idemSemiring",
            "Associates",
            "IdemSemiring.toSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Ideal.instNontrivial",
            "Nat",
            "congr",
            "Eq.ndrec",
            "One.toOfNat1",
            "Associates.FactorSet",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "Eq.refl",
            "WithTop.zero",
            "Subsingleton.elim",
            "Top.top",
            "Associates.factors",
            "OfNat.ofNat",
            "_auxLemma.2",
            "IsDomain.toNontrivial",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "Associates.instOne",
            "Associates.factors_one",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Multiset.instZero",
            "DecidableEq",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "simp only [\u2190 Ideal.one_eq_top, Associates.mk_one, Associates.factors_one]",
          "proofState": 24,
          "pos": {
            "line": 90,
            "column": 4
          },
          "goals": "case h\u2082\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nhI : IsUnit \u22a4\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk \u22a4).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk \u22a4).factors",
          "endPos": {
            "line": 90,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "Associates.count_zero",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Multiset",
            "Algebra.id",
            "id",
            "Subtype",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "instOfNatNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "Submodule.idemSemiring",
            "Associates",
            "IdemSemiring.toSemiring",
            "Nat",
            "Associates.FactorSet",
            "Zero.toOfNat0",
            "WithTop.zero",
            "OfNat.ofNat",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Multiset.instZero",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "rw [Associates.count_zero (associates_irreducible _), Associates.count_zero (associates_irreducible _), mul_zero]",
          "proofState": 25,
          "pos": {
            "line": 91,
            "column": 4
          },
          "goals": "case h\u2082\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nhI : IsUnit \u22a4\n\u22a2 (Associates.mk w.asIdeal).count 0 =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal * (Associates.mk (comap A w).asIdeal).count 0",
          "endPos": {
            "line": 92,
            "column": 65
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "RingHom.instRingHomClass",
            "MonoidWithZero.toMulActionWithZero",
            "Semiring.toModule",
            "instSubsingletonDecidable",
            "HMul.hMul",
            "IsScalarTower.right",
            "MulZeroClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Ideal.map_mul",
            "CancelCommMonoidWithZero",
            "Associates.count",
            "Decidable",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Eq.rec",
            "Irreducible",
            "Algebra.id",
            "id",
            "Ideal.map",
            "Pi.instSubsingleton",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "UniqueFactorizationMonoid",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "Submodule.mul",
            "IsScalarTower.left",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Associates",
            "CommMonoid.toMonoid",
            "IdemSemiring.toSemiring",
            "Nat",
            "CommSemiring.toCommMonoid",
            "Eq.ndrec",
            "IdemCommSemiring.toCommSemiring",
            "Associates.FactorSet",
            "MulActionWithZero.toMulAction",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.instMul",
            "Eq.refl",
            "MulZeroOneClass.toMulZeroClass",
            "Subsingleton.elim",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "DecidableEq",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "simp only [Ideal.map_mul, \u2190 Associates.mk_mul_mk]",
          "proofState": 26,
          "pos": {
            "line": 94,
            "column": 4
          },
          "goals": "case h\u2083\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) (p * I))).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk (p * I)).factors",
          "endPos": {
            "line": 94,
            "column": 53
          }
        },
        {
          "usedConstants": [
            "Associates.mk",
            "Semiring.toModule",
            "HMul.hMul",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ne",
            "instMulNat",
            "Bot.bot",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Ideal.cancelCommMonoidWithZero",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "Associates",
            "CommMonoid.toMonoid",
            "IdemSemiring.toSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "CommSemiring.toCommMonoid",
            "Prime.ne_zero",
            "IdemCommSemiring.toCommSemiring",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.instMul",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have hp_bot : p \u2260 \u22a5 := hp.ne_zero",
          "proofState": 27,
          "pos": {
            "line": 95,
            "column": 4
          },
          "goals": "case h\u2083\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\n\u22a2 (Associates.mk w.asIdeal).count\n      (Associates.mk (Ideal.map (algebraMap A B) p) * Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p * Associates.mk I).factors",
          "endPos": {
            "line": 95,
            "column": 37
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "Associates.mk",
            "RingHom.instRingHomClass",
            "Semiring.toModule",
            "HMul.hMul",
            "CommSemiring.toSemiring",
            "Associates.count",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "Ideal.map",
            "Iff.not",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ideal.map_eq_bot_iff_of_injective",
            "instMulNat",
            "Bot.bot",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Ideal.cancelCommMonoidWithZero",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "Associates",
            "CommMonoid.toMonoid",
            "IdemSemiring.toSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "CommSemiring.toCommMonoid",
            "IdemCommSemiring.toCommSemiring",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.instMul",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "Not",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have hp_bot' := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hp_bot",
          "proofState": 28,
          "pos": {
            "line": 96,
            "column": 4
          },
          "goals": "case h\u2083\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\n\u22a2 (Associates.mk w.asIdeal).count\n      (Associates.mk (Ideal.map (algebraMap A B) p) * Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p * Associates.mk I).factors",
          "endPos": {
            "line": 96,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "Associates.mk",
            "RingHom.instRingHomClass",
            "Semiring.toModule",
            "HMul.hMul",
            "CommSemiring.toSemiring",
            "Associates.count",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "Ideal.map",
            "Iff.not",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ideal.map_eq_bot_iff_of_injective",
            "instMulNat",
            "Bot.bot",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Ideal.cancelCommMonoidWithZero",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "Associates",
            "CommMonoid.toMonoid",
            "IdemSemiring.toSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "CommSemiring.toCommMonoid",
            "IdemCommSemiring.toCommSemiring",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.instMul",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "Not",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have hI_bot := (Ideal.map_eq_bot_iff_of_injective hAB).not.mpr hI",
          "proofState": 29,
          "pos": {
            "line": 97,
            "column": 4
          },
          "goals": "case h\u2083\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\n\u22a2 (Associates.mk w.asIdeal).count\n      (Associates.mk (Ideal.map (algebraMap A B) p) * Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p * Associates.mk I).factors",
          "endPos": {
            "line": 97,
            "column": 69
          }
        },
        {
          "usedConstants": [
            "CommMonoidWithZero.toCommMonoid",
            "Iff.mpr",
            "Eq.mpr",
            "Associates.mk",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.instZero",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ne",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "Associates",
            "CommMonoid.toMonoid",
            "IdemSemiring.toSemiring",
            "Nat",
            "Associates.count_mul",
            "CommSemiring.toCommMonoid",
            "Associates.mk_ne_zero",
            "IdemCommSemiring.toCommSemiring",
            "instAddNat",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.instMul",
            "MulZeroOneClass.toMulZeroClass",
            "Associates.factors",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "IsDedekindDomain.HeightOneSpectrum.associates_irreducible",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw [Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot) (Associates.mk_ne_zero.mpr hI) (associates_irreducible _),\n  Associates.count_mul (Associates.mk_ne_zero.mpr hp_bot') (Associates.mk_ne_zero.mpr hI_bot)\n    (associates_irreducible _)]",
          "proofState": 30,
          "pos": {
            "line": 98,
            "column": 4
          },
          "goals": "case h\u2083\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\n\u22a2 (Associates.mk w.asIdeal).count\n      (Associates.mk (Ideal.map (algebraMap A B) p) * Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p * Associates.mk I).factors",
          "endPos": {
            "line": 100,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "Distrib.leftDistribClass",
            "Eq.mpr",
            "Associates.mk",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "HAdd.hAdd",
            "IdemSemiring.toSemiring",
            "Nat",
            "congr",
            "Nat.instDistrib",
            "instAddNat",
            "Ideal.uniqueFactorizationMonoid",
            "mul_add",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp only [IH, mul_add]",
          "proofState": 31,
          "pos": {
            "line": 101,
            "column": 4
          },
          "goals": "case h\u2083\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors +\n      (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      ((Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors +\n        (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors)",
          "endPos": {
            "line": 101,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Eq.rec",
            "HAdd",
            "HAdd.hAdd",
            "Eq.refl",
            "Eq"
          ],
          "tactic": "congr 1",
          "proofState": 32,
          "pos": {
            "line": 102,
            "column": 4
          },
          "goals": "case h\u2083\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors +\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n        (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n        (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors +\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n        (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors",
          "endPos": {
            "line": 102,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "Associates.mk",
            "HMul.hMul",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Classical.propDecidable",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "dite",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "IdemSemiring.toSemiring",
            "Nat",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "Not",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "by_cases hw : (w.comap A).asIdeal = p",
          "proofState": 33,
          "pos": {
            "line": 103,
            "column": 4
          },
          "goals": "case h\u2083.e_a\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors",
          "endPos": {
            "line": 103,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "Prime.irreducible",
            "Iff.mpr",
            "Associates.mk",
            "HMul.hMul",
            "Associates.irreducible_mk",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "CommSemiring.toCommMonoidWithZero",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Algebra.id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "Associates",
            "IdemSemiring.toSemiring",
            "Nat",
            "IdemCommSemiring.toCommSemiring",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "have : Irreducible (Associates.mk p) := Associates.irreducible_mk.mpr hp.irreducible",
          "proofState": 34,
          "pos": {
            "line": 104,
            "column": 6
          },
          "goals": "case pos\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : (comap A w).asIdeal = p\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors",
          "endPos": {
            "line": 104,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "IdemSemiring.toSemiring",
            "Nat",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw [hw, Associates.factors_self this, Associates.count_some this]",
          "proofState": 35,
          "pos": {
            "line": 105,
            "column": 6
          },
          "goals": "case pos\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : (comap A w).asIdeal = p\nthis : Irreducible (Associates.mk p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors",
          "endPos": {
            "line": 105,
            "column": 71
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "HMul.hMul",
            "Multiset.Nodup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Nat.instMulOneClass",
            "RingHom",
            "Membership.mem",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Multiset.count",
            "Multiset",
            "Algebra.id",
            "id",
            "Subtype",
            "Ideal.map",
            "instMulNat",
            "instOfNatNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Multiset.instSingleton",
            "Multiset.count_eq_one_of_mem",
            "Subtype.mk",
            "Ideal.cancelCommMonoidWithZero",
            "Multiset.instMembership",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "Associates",
            "IdemSemiring.toSemiring",
            "Nat",
            "_auxLemma.5",
            "True",
            "eq_self",
            "of_eq_true",
            "Ideal.uniqueFactorizationMonoid",
            "_auxLemma.4",
            "mul_one",
            "Associates.factors",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Subtype.instDecidableEq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "simp only [UniqueFactorizationMonoid.factors_eq_normalizedFactors, Multiset.nodup_singleton, Multiset.mem_singleton,\n  Multiset.count_eq_one_of_mem, mul_one]",
          "proofState": 36,
          "pos": {
            "line": 106,
            "column": 6
          },
          "goals": "case pos\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : (comap A w).asIdeal = p\nthis : Irreducible (Associates.mk p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors =\n    Ideal.ramificationIdx (algebraMap A B) p w.asIdeal *\n      Multiset.count \u27e8Associates.mk p, this\u27e9 {\u27e8Associates.mk p, this\u27e9}",
          "endPos": {
            "line": 107,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "UniqueFactorizationMonoid.normalizedFactors",
            "Eq.mpr",
            "Associates.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Classical.propDecidable",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Multiset.count",
            "Algebra.id",
            "id",
            "Ideal.map",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "IdemSemiring.toSemiring",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.ne_bot",
            "Ideal.uniqueFactorizationMonoid",
            "count_associates_factors_eq",
            "IsDedekindDomain.HeightOneSpectrum.isPrime",
            "Associates.factors",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "Ideal.normalizationMonoid"
          ],
          "tactic": "rw [count_associates_factors_eq hp_bot' w.2 w.3,\n  Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count hp_bot' w.2 w.3]",
          "proofState": 37,
          "pos": {
            "line": 108,
            "column": 6
          },
          "goals": "case pos\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : (comap A w).asIdeal = p\nthis : Irreducible (Associates.mk p)\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors =\n    Ideal.ramificationIdx (algebraMap A B) p w.asIdeal",
          "endPos": {
            "line": 109,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "Prime.irreducible",
            "Iff.mpr",
            "Eq.mpr",
            "Associates.mk",
            "Associates.mk_eq_mk_iff_associated",
            "HMul.hMul",
            "Associates.irreducible_mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "CommSemiring.toCommMonoidWithZero",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Units",
            "Irreducible",
            "Algebra.id",
            "id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ne",
            "instMulNat",
            "instOfNatNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal.instIdemCommSemiring",
            "Ideal",
            "ne_eq",
            "associated_iff_eq",
            "Ideal.cancelCommMonoidWithZero",
            "Unique.instSubsingleton",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Associated",
            "Submodule.idemSemiring",
            "Ideal.uniqueUnits",
            "Associates",
            "IdemSemiring.toSemiring",
            "Nat",
            "propext",
            "IdemCommSemiring.toCommSemiring",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.count_eq_zero_of_ne",
            "Associates.factors",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "Not",
            "IsDedekindDomain.HeightOneSpectrum.associates_irreducible",
            "letFun",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Associates.instCommMonoidWithZero"
          ],
          "tactic": "have : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0 :=\n  Associates.count_eq_zero_of_ne (associates_irreducible _) (Associates.irreducible_mk.mpr hp.irreducible)\n    (by rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq])",
          "proofState": 38,
          "pos": {
            "line": 110,
            "column": 6
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : \u00ac(comap A w).asIdeal = p\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors",
          "endPos": {
            "line": 113,
            "column": 81
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "congrArg",
            "CommSemiring.toSemiring",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "id",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ne",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "ne_eq",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "Submodule.idemSemiring",
            "Associates",
            "IdemSemiring.toSemiring",
            "Eq",
            "Not",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rwa [ne_eq, Associates.mk_eq_mk_iff_associated, associated_iff_eq]",
          "proofState": 39,
          "pos": {
            "line": 113,
            "column": 14
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : \u00ac(comap A w).asIdeal = p\n\u22a2 Associates.mk (comap A w).asIdeal \u2260 Associates.mk p",
          "endPos": {
            "line": 113,
            "column": 80
          }
        },
        {
          "usedConstants": [
            "Eq.mpr",
            "Associates.mk",
            "HMul.hMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "id",
            "Ideal.map",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "instMulNat",
            "instOfNatNat",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "IdemSemiring.toSemiring",
            "Nat",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.factors",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Ideal.ramificationIdx",
            "MonoidWithZero.toMonoid",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "rw [this, mul_zero, eq_comm]",
          "proofState": 40,
          "pos": {
            "line": 114,
            "column": 6
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : \u00ac(comap A w).asIdeal = p\nthis : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0\n\u22a2 (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors",
          "endPos": {
            "line": 114,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "Associates.mk",
            "Nat.instMulZeroClass",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Algebra.id",
            "Ideal.map",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "IdemSemiring.toSemiring",
            "Nat",
            "Decidable.byContradiction",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "instDecidableEqNat",
            "Associates.factors",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Not",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "by_contra H",
          "proofState": 41,
          "pos": {
            "line": 115,
            "column": 6
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : \u00ac(comap A w).asIdeal = p\nthis : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0\n\u22a2 0 = (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors",
          "endPos": {
            "line": 115,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "Associates.mk",
            "Nat.instMulZeroClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Eq.mp",
            "Algebra.id",
            "Ideal.map",
            "CommMonoidWithZero.toMonoidWithZero",
            "Ideal",
            "eq_comm",
            "Ideal.cancelCommMonoidWithZero",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "IdemSemiring.toSemiring",
            "Nat",
            "propext",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "Associates.factors",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Not",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "rw [eq_comm, \u2190 ne_eq, Associates.count_ne_zero_iff_dvd hp_bot' (irreducible w), Ideal.dvd_iff_le,\n  Ideal.map_le_iff_le_comap] at H",
          "proofState": 42,
          "pos": {
            "line": 116,
            "column": 6
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : \u00ac(comap A w).asIdeal = p\nthis : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0\nH : \u00ac0 = (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) p)).factors\n\u22a2 False",
          "endPos": {
            "line": 117,
            "column": 57
          }
        },
        {
          "usedConstants": [
            "IsDedekindDomain.toIsDomain",
            "IsDedekindDomain.isDedekindDomainDvr",
            "CommSemiring.toSemiring",
            "Ideal.IsPrime.isMaximal",
            "IsDedekindDomainDvr.ring_dimensionLEOne",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ideal",
            "CommRing.toCommSemiring",
            "Ideal.IsMaximal.eq_of_le",
            "Ideal.isPrime_of_prime",
            "IsDedekindDomain.HeightOneSpectrum.isPrime",
            "Eq.symm",
            "Ideal.IsPrime.ne_top"
          ],
          "tactic": "apply hw (((Ideal.isPrime_of_prime hp).isMaximal hp_bot).eq_of_le (comap A w).2.ne_top H).symm",
          "proofState": 43,
          "pos": {
            "line": 118,
            "column": 6
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u00b9\u2070 : CommRing A\ninst\u271d\u2079 : CommRing B\ninst\u271d\u2078 : Algebra A B\ninst\u271d\u2077 : IsDedekindDomain A\ninst\u271d\u2076 : IsDomain B\ninst\u271d\u2075 : Algebra.IsIntegral A B\ninst\u271d\u2074 : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\ninst\u271d\u00b3 : DecidableEq (Associates (Ideal A))\ninst\u271d\u00b2 : DecidableEq (Associates (Ideal B))\ninst\u271d\u00b9 : (p : Associates (Ideal A)) \u2192 Decidable (Irreducible p)\ninst\u271d : (p : Associates (Ideal B)) \u2192 Decidable (Irreducible p)\nI p : Ideal A\nhI : I \u2260 0\nhp : Prime p\nIH :\n  (Associates.mk w.asIdeal).count (Associates.mk (Ideal.map (algebraMap A B) I)).factors =\n    Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal *\n      (Associates.mk (comap A w).asIdeal).count (Associates.mk I).factors\nhp_bot : p \u2260 \u22a5\nhp_bot' : \u00acIdeal.map (algebraMap A B) p = \u22a5\nhI_bot : \u00acIdeal.map (algebraMap A B) I = \u22a5\nhw : \u00ac(comap A w).asIdeal = p\nthis : (Associates.mk (comap A w).asIdeal).count (Associates.mk p).factors = 0\nH : p \u2264 Ideal.comap (algebraMap A B) w.asIdeal\n\u22a2 False",
          "endPos": {
            "line": 118,
            "column": 100
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "Multiplicative.monoid",
            "WithZero.pow",
            "Multiplicative.linearOrderedCommMonoid",
            "CommSemiring.toSemiring",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Ideal.map",
            "Iff.not",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ideal.map_eq_bot_iff_of_injective",
            "Ne",
            "instOfNatNat",
            "Bot.bot",
            "Int",
            "Int.instAddMonoid",
            "Ideal",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Multiplicative",
            "Int.instNormedCommRing",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "HPow.hPow",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.ne_bot",
            "Ideal.IsDedekindDomain.ramificationIdx_ne_zero",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "CommRing.toRing",
            "Int.instLinearOrderedCommRing",
            "IsDedekindDomain.HeightOneSpectrum.intValuation",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Ideal.map_comap_le",
            "IsDedekindDomain.HeightOneSpectrum.isPrime",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Not",
            "letFun",
            "Valuation",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "classical\nhave h_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0 :=\n  Ideal.IsDedekindDomain.ramificationIdx_ne_zero ((Ideal.map_eq_bot_iff_of_injective hAB).not.mpr (comap A w).3) w.2\n    Ideal.map_comap_le\nby_cases hx : x = 0\n\u00b7 simpa [hx]\nsimp only [intValuation, Valuation.coe_mk, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\nshow (ite _ _ _) ^ _ = ite _ _ _\nby_cases hx : x = 0\n\u00b7 subst hx; simp [h_ne_zero]\nrw [map_eq_zero_iff _ hAB, if_neg hx, if_neg hx, \u2190 Set.image_singleton, \u2190 Ideal.map_span, mk_count_factors_map _ _ hAB,\n  mul_comm]\nsimp\n  -- Need to know how the valuation `w` and its pullback are related on elements of `K`.",
          "proofState": 44,
          "pos": {
            "line": 126,
            "column": 2
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\n\u22a2 (comap A w).intValuation x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.intValuation ((algebraMap A B) x)",
          "endPos": {
            "line": 138,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Semiring.toModule",
            "Multiplicative.monoid",
            "WithZero.pow",
            "Multiplicative.linearOrderedCommMonoid",
            "CommSemiring.toSemiring",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Ideal.map",
            "Iff.not",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ideal.map_eq_bot_iff_of_injective",
            "Ne",
            "instOfNatNat",
            "Bot.bot",
            "Int",
            "Int.instAddMonoid",
            "Ideal",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Multiplicative",
            "Int.instNormedCommRing",
            "Submodule.instBot",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "HPow.hPow",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.ne_bot",
            "Ideal.IsDedekindDomain.ramificationIdx_ne_zero",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "CommRing.toRing",
            "Int.instLinearOrderedCommRing",
            "IsDedekindDomain.HeightOneSpectrum.intValuation",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Ideal.map_comap_le",
            "IsDedekindDomain.HeightOneSpectrum.isPrime",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Not",
            "letFun",
            "Valuation",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "have h_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0 :=\n  Ideal.IsDedekindDomain.ramificationIdx_ne_zero ((Ideal.map_eq_bot_iff_of_injective hAB).not.mpr (comap A w).3) w.2\n    Ideal.map_comap_le",
          "proofState": 45,
          "pos": {
            "line": 127,
            "column": 2
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\n\u22a2 (comap A w).intValuation x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.intValuation ((algebraMap A B) x)",
          "endPos": {
            "line": 129,
            "column": 92
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "CommRing.toNonUnitalCommRing",
            "WithZero.pow",
            "Multiplicative.linearOrderedCommMonoid",
            "CommSemiring.toSemiring",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Int",
            "Int.instAddMonoid",
            "dite",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "Int.instNormedCommRing",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "HPow.hPow",
            "WithZero",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "CommRing.toRing",
            "Int.instLinearOrderedCommRing",
            "IsDedekindDomain.HeightOneSpectrum.intValuation",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Not",
            "Valuation",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "by_cases hx : x = 0",
          "proofState": 46,
          "pos": {
            "line": 130,
            "column": 2
          },
          "goals": "A : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\n\u22a2 (comap A w).intValuation x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.intValuation ((algebraMap A B) x)",
          "endPos": {
            "line": 130,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "Int.instInhabited",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "CommRing.toNonUnitalCommRing",
            "Monoid.toMulOneClass",
            "WithZero.pow",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "map_zero",
            "id",
            "RingHomClass.toMonoidWithZeroHomClass",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ne",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "Int",
            "Int.instAddMonoid",
            "WithZero.zero",
            "Mathlib.Algebra.GroupWithZero.Basic._auxLemma.5",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "Int.instNormedCommRing",
            "And",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "IsDedekindDomain.HeightOneSpectrum.intValuationDef_zero",
            "instNonemptyOfInhabited",
            "WithZero",
            "Nat",
            "congr",
            "WithZero.noZeroDivisors",
            "True",
            "instInhabitedMultiplicative",
            "eq_self",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "MulZeroOneClass.toMulZeroClass",
            "Valuation.instFunLike",
            "MonoidWithZeroHomClass.toZeroHomClass",
            "CommRing.toRing",
            "Int.instLinearOrderedCommRing",
            "IsDedekindDomain.HeightOneSpectrum.intValuation",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "WithZero.monoidWithZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Not",
            "Valuation",
            "true_and",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "WithZero.nontrivial"
          ],
          "tactic": "simpa [hx]",
          "proofState": 47,
          "pos": {
            "line": 131,
            "column": 4
          },
          "goals": "case pos\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx : x = 0\n\u22a2 (comap A w).intValuation x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.intValuation ((algebraMap A B) x)",
          "endPos": {
            "line": 131,
            "column": 14
          }
        },
        {
          "usedConstants": [
            "id"
          ],
          "tactic": "simp only [intValuation, Valuation.coe_mk, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]",
          "proofState": 48,
          "pos": {
            "line": 132,
            "column": 2
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx : \u00acx = 0\n\u22a2 (comap A w).intValuation x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.intValuation ((algebraMap A B) x)",
          "endPos": {
            "line": 132,
            "column": 86
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Associates.mk",
            "NormedCommRing.toSeminormedCommRing",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "CommRing.toNonUnitalCommRing",
            "WithZero.pow",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Algebra.id",
            "Set.instSingletonSet",
            "Equiv",
            "Int.instNegInt",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.instAddMonoid",
            "WithZero.zero",
            "Ideal",
            "Nat.cast",
            "Multiplicative",
            "Ideal.cancelCommMonoidWithZero",
            "Int.instNormedCommRing",
            "Quotient.decidableEq",
            "Associated.setoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "HPow.hPow",
            "Associates",
            "HasEquiv.Equiv",
            "IdemSemiring.toSemiring",
            "WithZero",
            "Nat",
            "WithZero.coe",
            "instHasEquivOfSetoid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "Ideal.span",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Associates.factors",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "letFun",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "Associates.instCommMonoidWithZero",
            "ite",
            "Set"
          ],
          "tactic": "show (ite _ _ _) ^ _ = ite _ _ _",
          "proofState": 49,
          "pos": {
            "line": 133,
            "column": 2
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx : \u00acx = 0\n\u22a2 (comap A w).intValuationDef x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.intValuationDef ((algebraMap A B) x)",
          "endPos": {
            "line": 133,
            "column": 34
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Associates.mk",
            "NormedCommRing.toSeminormedCommRing",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "CommRing.toNonUnitalCommRing",
            "WithZero.pow",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Algebra.id",
            "Set.instSingletonSet",
            "Equiv",
            "Int.instNegInt",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.instAddMonoid",
            "WithZero.zero",
            "Ideal",
            "Nat.cast",
            "dite",
            "Multiplicative",
            "Ideal.cancelCommMonoidWithZero",
            "Int.instNormedCommRing",
            "Quotient.decidableEq",
            "Associated.setoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "HPow.hPow",
            "Associates",
            "HasEquiv.Equiv",
            "IdemSemiring.toSemiring",
            "WithZero",
            "Nat",
            "WithZero.coe",
            "instHasEquivOfSetoid",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "Ideal.span",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Associates.factors",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Not",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "Associates.instCommMonoidWithZero",
            "ite",
            "Set"
          ],
          "tactic": "by_cases hx : x = 0",
          "proofState": 50,
          "pos": {
            "line": 134,
            "column": 2
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx : \u00acx = 0\n\u22a2 (if x = 0 then 0\n      else\n        \u2191(Multiplicative.ofAdd\n            (-\u2191((Associates.mk (comap A w).asIdeal).count (Associates.mk (Ideal.span {x})).factors)))) ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    if (algebraMap A B) x = 0 then 0\n    else\n      \u2191(Multiplicative.ofAdd\n          (-\u2191((Associates.mk w.asIdeal).count (Associates.mk (Ideal.span {(algebraMap A B) x})).factors)))",
          "endPos": {
            "line": 134,
            "column": 21
          }
        },
        {
          "usedConstants": [],
          "tactic": "subst hx",
          "proofState": 51,
          "pos": {
            "line": 135,
            "column": 4
          },
          "goals": "case pos\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx\u271d : \u00acx = 0\nhx : x = 0\n\u22a2 (if x = 0 then 0\n      else\n        \u2191(Multiplicative.ofAdd\n            (-\u2191((Associates.mk (comap A w).asIdeal).count (Associates.mk (Ideal.span {x})).factors)))) ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    if (algebraMap A B) x = 0 then 0\n    else\n      \u2191(Multiplicative.ofAdd\n          (-\u2191((Associates.mk w.asIdeal).count (Associates.mk (Ideal.span {(algebraMap A B) x})).factors)))",
          "endPos": {
            "line": 135,
            "column": 12
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Associates.mk",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "False",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "CommRing.toNonUnitalCommRing",
            "eq_false",
            "WithZero.pow",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "map_zero",
            "Algebra.id",
            "Set.instSingletonSet",
            "Equiv",
            "RingHomClass.toMonoidWithZeroHomClass",
            "Int.instNegInt",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "NonAssocSemiring.toMulZeroOneClass",
            "instOfNatNat",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.instAddMonoid",
            "WithZero.zero",
            "ite_cond_eq_true",
            "Ideal",
            "Nat.cast",
            "Multiplicative",
            "Ideal.cancelCommMonoidWithZero",
            "Int.instNormedCommRing",
            "Quotient.decidableEq",
            "Associated.setoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HPow.hPow",
            "Associates",
            "HasEquiv.Equiv",
            "IdemSemiring.toSemiring",
            "WithZero",
            "Nat",
            "congr",
            "WithZero.coe",
            "True",
            "instHasEquivOfSetoid",
            "eq_self",
            "of_eq_true",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "Ideal.span",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "instHPow",
            "MulZeroOneClass.toMulZeroClass",
            "MonoidWithZeroHomClass.toZeroHomClass",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Associates.factors",
            "Singleton.singleton",
            "OfNat.ofNat",
            "not_false_eq_true",
            "WithZero.monoidWithZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Not",
            "Neg.neg",
            "zero_pow",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "Associates.instCommMonoidWithZero",
            "ite",
            "Set"
          ],
          "tactic": "simp [h_ne_zero]",
          "proofState": 52,
          "pos": {
            "line": 135,
            "column": 14
          },
          "goals": "case pos\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx : \u00ac0 = 0\n\u22a2 (if 0 = 0 then 0\n      else\n        \u2191(Multiplicative.ofAdd\n            (-\u2191((Associates.mk (comap A w).asIdeal).count (Associates.mk (Ideal.span {0})).factors)))) ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    if (algebraMap A B) 0 = 0 then 0\n    else\n      \u2191(Multiplicative.ofAdd\n          (-\u2191((Associates.mk w.asIdeal).count (Associates.mk (Ideal.span {(algebraMap A B) 0})).factors)))",
          "endPos": {
            "line": 135,
            "column": 30
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Associates.mk",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "Equiv.instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "CommRing.toNonUnitalCommRing",
            "WithZero.pow",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Classical.propDecidable",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Algebra.id",
            "Set.instSingletonSet",
            "id",
            "Equiv",
            "RingHomClass.toMonoidWithZeroHomClass",
            "Int.instNegInt",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "CommMonoidWithZero.toMonoidWithZero",
            "Int.instAddMonoid",
            "WithZero.zero",
            "Ideal",
            "Nat.cast",
            "Multiplicative",
            "Ideal.cancelCommMonoidWithZero",
            "Int.instNormedCommRing",
            "Quotient.decidableEq",
            "Associated.setoid",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Submodule.idemSemiring",
            "HPow.hPow",
            "Associates",
            "HasEquiv.Equiv",
            "IdemSemiring.toSemiring",
            "map_eq_zero_iff",
            "WithZero",
            "Nat",
            "WithZero.coe",
            "instHasEquivOfSetoid",
            "propext",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Ideal.uniqueFactorizationMonoid",
            "Ideal.span",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "instHPow",
            "MonoidWithZeroHomClass.toZeroHomClass",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Associates.factors",
            "Singleton.singleton",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero",
            "Associates.instCommMonoidWithZero",
            "ite",
            "Set"
          ],
          "tactic": "rw [map_eq_zero_iff _ hAB, if_neg hx, if_neg hx, \u2190 Set.image_singleton, \u2190 Ideal.map_span, mk_count_factors_map _ _ hAB,\n  mul_comm]",
          "proofState": 53,
          "pos": {
            "line": 136,
            "column": 2
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx\u271d hx : \u00acx = 0\n\u22a2 (if x = 0 then 0\n      else\n        \u2191(Multiplicative.ofAdd\n            (-\u2191((Associates.mk (comap A w).asIdeal).count (Associates.mk (Ideal.span {x})).factors)))) ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    if (algebraMap A B) x = 0 then 0\n    else\n      \u2191(Multiplicative.ofAdd\n          (-\u2191((Associates.mk w.asIdeal).count (Associates.mk (Ideal.span {(algebraMap A B) x})).factors)))",
          "endPos": {
            "line": 137,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "zpow_natCast",
            "Associates.mk",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Equiv.instFunLike",
            "HMul.hMul",
            "DivInvOneMonoid.toInvOneClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "Associates.count",
            "DivInvMonoid.toZPow",
            "CancelCommMonoidWithZero.toCommMonoidWithZero",
            "Classical.propDecidable",
            "Multiplicative.divisionMonoid",
            "CommSemiring.toCommMonoidWithZero",
            "DivisionMonoid.toDivInvOneMonoid",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Irreducible",
            "Algebra.id",
            "Set.instSingletonSet",
            "Equiv",
            "Int.instNegInt",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "AddMonoidWithOne.toNatCast",
            "instMulNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "CommMonoidWithZero.toMonoidWithZero",
            "WithZero.divisionMonoid",
            "Ideal.instIdemCommSemiring",
            "inv_pow",
            "Ideal",
            "SubtractionCommMonoid.toSubtractionMonoid",
            "Nat.cast",
            "DivisionMonoid.toDivInvMonoid",
            "Int.instMul",
            "Multiplicative",
            "Multiplicative.divInvMonoid",
            "Ideal.cancelCommMonoidWithZero",
            "Quotient.decidableEq",
            "Associated.setoid",
            "Int.ofAdd_mul",
            "CommRing.toCommSemiring",
            "Inv.inv",
            "Nat.cast_mul",
            "AddGroup.toSubNegMonoid",
            "Submodule.idemSemiring",
            "HPow.hPow",
            "Distrib.toMul",
            "Associates",
            "HasEquiv.Equiv",
            "IdemSemiring.toSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "WithZero",
            "Nat",
            "congr",
            "WithZero.coe",
            "True",
            "instHasEquivOfSetoid",
            "eq_self",
            "of_eq_true",
            "IdemCommSemiring.toCommSemiring",
            "Int.instAddGroup",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Multiplicative.inv",
            "Ideal.uniqueFactorizationMonoid",
            "Ideal.span",
            "InvOneClass.toInv",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "instHPow",
            "AddCommGroup.toDivisionAddCommMonoid",
            "Associates.factors",
            "Singleton.singleton",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Neg.neg",
            "MonoidWithZero.toMonoid",
            "Eq.trans",
            "Int.instSemiring",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "Associates.instCommMonoidWithZero",
            "Set"
          ],
          "tactic": "simp\n  -- Need to know how the valuation `w` and its pullback are related on elements of `K`.",
          "proofState": 54,
          "pos": {
            "line": 138,
            "column": 2
          },
          "goals": "case neg\nA : Type u_1\nB : Type u_4\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : CommRing B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : IsDedekindDomain A\ninst\u271d\u00b2 : IsDomain B\ninst\u271d\u00b9 : Algebra.IsIntegral A B\ninst\u271d : IsDedekindDomain B\nhAB : Function.Injective \u21d1(algebraMap A B)\nw : HeightOneSpectrum B\nx : A\nh_ne_zero : Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal \u2260 0\nhx\u271d hx : \u00acx = 0\n\u22a2 \u2191(Multiplicative.ofAdd (-\u2191((Associates.mk (comap A w).asIdeal).count (Associates.mk (Ideal.span {x})).factors))) ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    \u2191(Multiplicative.ofAdd\n        (-\u2191((Associates.mk (comap A w).asIdeal).count (Associates.mk (Ideal.span {x})).factors *\n              Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal)))",
          "endPos": {
            "line": 138,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "IsFractionRing.div_surjective"
          ],
          "tactic": "obtain \u27e8x, y, hy, rfl\u27e9 := IsFractionRing.div_surjective (A := A) x",
          "proofState": 55,
          "pos": {
            "line": 147,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nx : K\n\u22a2 (comap A w).valuation x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.valuation ((algebraMap K L) x)",
          "endPos": {
            "line": 147,
            "column": 68
          }
        },
        {
          "usedConstants": [
            "Int.instAddCommGroup",
            "Multiplicative.group",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "RingHom.instRingHomClass",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "WithZero.divisionCommMonoid",
            "GroupWithZero.toDivInvMonoid",
            "DivisionCommMonoid.toDivisionMonoid",
            "ValuationClass.toMonoidWithZeroHomClass",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "WithZero.pow",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "HenselianLocalRing.toIsLocalRing",
            "IsDedekindDomain.HeightOneSpectrum",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "IsDedekindDomain.HeightOneSpectrum.intValuationDef",
            "DivisionSemiring.toGroupWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "WithZero.groupWithZero",
            "nonZeroDivisors",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "HDiv.hDiv",
            "Valuation.extendToLocalization",
            "RingHomClass.toMonoidWithZeroHomClass",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Field.henselian",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "DivisionMonoid.toDivInvMonoid",
            "Field.toSemifield",
            "Field.toCommRing",
            "Valuation.instValuationClass",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "Int.instNormedCommRing",
            "algebraMap_injective_of_field_isFractionRing",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "map_div\u2080",
            "Semifield.toDivisionSemiring",
            "HPow.hPow",
            "IsDedekindDomain.HeightOneSpectrum.valuation.proof_1",
            "WithZero",
            "Nat",
            "IsLocalRing.toNontrivial",
            "div_pow",
            "congr",
            "True",
            "eq_self",
            "DivInvMonoid.toDiv",
            "IsDedekindDomain.HeightOneSpectrum.intValuation_comap",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "Multiplicative.divisionCommMonoid",
            "Valuation.extendToLocalization_apply_map_apply",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "EuclideanDomain.toCommRing",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "CommRing.toRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "IsDedekindDomain.HeightOneSpectrum.intValuation",
            "AddCommGroup.toDivisionAddCommMonoid",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "IsScalarTower.algebraMap_apply",
            "Valuation",
            "Field.toEuclideanDomain",
            "Eq.trans",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp [valuation, \u2190 IsScalarTower.algebraMap_apply A K L, IsScalarTower.algebraMap_apply A B L, \u2190\n  intValuation_comap A B (algebraMap_injective_of_field_isFractionRing A B K L), div_pow]",
          "proofState": 56,
          "pos": {
            "line": 148,
            "column": 2
          },
          "goals": "case intro.intro.intro\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nx y : A\nhy : y \u2208 nonZeroDivisors A\n\u22a2 (comap A w).valuation ((algebraMap A K) x / (algebraMap A K) y) ^\n      Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.valuation ((algebraMap K L) ((algebraMap A K) x / (algebraMap A K) y))",
          "endPos": {
            "line": 149,
            "column": 93
          }
        },
        {
          "usedConstants": [
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Field.toDivisionRing",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "DivisionRing.toRing",
            "Int",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "WithZero",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing"
          ],
          "tactic": "letI : UniformSpace K := v.adicValued.toUniformSpace",
          "proofState": 57,
          "pos": {
            "line": 158,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 Continuous \u21d1(algebraMap K L)",
          "endPos": {
            "line": 158,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Field.toDivisionRing",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "DivisionRing.toRing",
            "Int",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "WithZero",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing"
          ],
          "tactic": "letI : UniformSpace L := w.adicValued.toUniformSpace",
          "proofState": 58,
          "pos": {
            "line": 159,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 Continuous \u21d1(algebraMap K L)",
          "endPos": {
            "line": 159,
            "column": 54
          }
        },
        {
          "usedConstants": [],
          "tactic": "subst hvw",
          "proofState": 59,
          "pos": {
            "line": 160,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis\u271d : UniformSpace K := Valued.toUniformSpace\nthis : UniformSpace L := Valued.toUniformSpace\n\u22a2 Continuous \u21d1(algebraMap K L)",
          "endPos": {
            "line": 160,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "TopologicalSemiring.toContinuousAdd",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "GroupWithZero.toMonoidWithZero",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "RingHom.instRingHomClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "RingHomClass.toAddMonoidHomClass",
            "Valued.topologicalDivisionRing",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "AddGroupWithOne.toAddGroup",
            "CommSemiring.toSemiring",
            "AddMonoid.toAddZeroClass",
            "continuous_of_continuousAt_zero",
            "AddGroupFilterBasis.isTopologicalAddGroup",
            "Valuation.subgroups_basis",
            "RingHom",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Units",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "RingSubgroupsBasis.toRingFilterBasis",
            "Multiplicative",
            "Valued.toUniformSpace",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Valuation.ltAddSubgroup",
            "Semifield.toCommSemiring",
            "TopologicalRing.toTopologicalSemiring",
            "AddMonoidWithOne.toAddMonoid",
            "EuclideanDomain.toCommRing",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "CommGroupWithZero.toGroupWithZero",
            "Valued.mk'.proof_1",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "TopologicalDivisionRing.toTopologicalRing",
            "Ring.toAddGroupWithOne",
            "RingFilterBasis.toAddGroupFilterBasis",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "refine continuous_of_continuousAt_zero (algebraMap K L) ?hf",
          "proofState": 60,
          "pos": {
            "line": 161,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 Continuous \u21d1(algebraMap K L)",
          "endPos": {
            "line": 161,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "ContinuousAt",
            "algebraMap",
            "id",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "SubNegZeroMonoid.toNegZeroClass",
            "Zero.toOfNat0",
            "OfNat.ofNat",
            "NegZeroClass.toZero",
            "DFunLike.coe"
          ],
          "tactic": "delta ContinuousAt",
          "proofState": 61,
          "pos": {
            "line": 162,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 ContinuousAt (\u21d1(algebraMap K L)) 0",
          "endPos": {
            "line": 162,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "RingHom.instRingHomClass",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "nhds",
            "map_zero",
            "id",
            "RingHomClass.toMonoidWithZeroHomClass",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "NonAssocSemiring.toMulZeroOneClass",
            "Int",
            "SubNegZeroMonoid.toNegZeroClass",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Filter.Tendsto",
            "WithZero",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "Semifield.toCommSemiring",
            "EuclideanDomain.toCommRing",
            "MonoidWithZeroHomClass.toZeroHomClass",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "UniformSpace.toTopologicalSpace",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Field.toEuclideanDomain",
            "MulZeroClass.toZero"
          ],
          "tactic": "simp only [map_zero]",
          "proofState": 62,
          "pos": {
            "line": 163,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 Filter.Tendsto (\u21d1(algebraMap K L)) (nhds 0) (nhds ((algebraMap K L) 0))",
          "endPos": {
            "line": 163,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "AddGroup.toSubtractionMonoid",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "Preorder.toLT",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Ring.toNonAssocRing",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "AddGroupWithOne.toAddGroup",
            "congrArg",
            "CommSemiring.toSemiring",
            "Filter.HasBasis.tendsto_iff",
            "Valued.v",
            "PartialOrder.toPreorder",
            "setOf",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Membership.mem",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "nhds",
            "Valued.hasBasis_nhds_zero",
            "Units",
            "id",
            "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "SubtractionMonoid.toSubNegZeroMonoid",
            "Int",
            "SubNegZeroMonoid.toNegZeroClass",
            "Field.toSemifield",
            "NonAssocRing.toNonUnitalNonAssocRing",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "And",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "Filter.Tendsto",
            "WithZero",
            "LT.lt",
            "True",
            "propext",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "Zero.toOfNat0",
            "OrderedCommMonoid.toPartialOrder",
            "Semifield.toCommSemiring",
            "EuclideanDomain.toCommRing",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "CommGroupWithZero.toGroupWithZero",
            "OfNat.ofNat",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "UniformSpace.toTopologicalSpace",
            "NegZeroClass.toZero",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Ring.toAddGroupWithOne",
            "Valuation",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "Set"
          ],
          "tactic": "rw [(@Valued.hasBasis_nhds_zero K _ _ _ (comap A w).adicValued).tendsto_iff\n    (@Valued.hasBasis_nhds_zero L _ _ _ w.adicValued)]",
          "proofState": 63,
          "pos": {
            "line": 164,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 Filter.Tendsto (\u21d1(algebraMap K L)) (nhds 0) (nhds 0)",
          "endPos": {
            "line": 165,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "Units.val",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "Preorder.toLT",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "Valued.v",
            "PartialOrder.toPreorder",
            "setOf",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "RingHom",
            "Membership.mem",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Units",
            "id",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "funext",
            "And",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "implies_congr",
            "WithZero",
            "true_implies",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "True",
            "DivisionSemiring.toSemiring",
            "Eq.refl",
            "OrderedCommMonoid.toPartialOrder",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "CommGroupWithZero.toGroupWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "Valuation",
            "MonoidWithZero.toMonoid",
            "true_and",
            "Eq.trans",
            "forall_congr",
            "Set"
          ],
          "tactic": "simp only [HeightOneSpectrum.adicValued_apply, Set.mem_setOf_eq, true_and, true_implies]",
          "proofState": 64,
          "pos": {
            "line": 166,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 \u2200 (ib : \u2124\u2098\u2080\u02e3), True \u2192 \u2203 ia, True \u2227 \u2200 x \u2208 {x | Valued.v x < \u2191ia}, (algebraMap K L) x \u2208 {x | Valued.v x < \u2191ib}",
          "endPos": {
            "line": 166,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "Multiplicative.group",
            "Units.val",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "Equiv.instFunLike",
            "Preorder.toLT",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Equiv.forall_congr_left",
            "RingHom",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Units",
            "id",
            "Equiv",
            "MulEquiv.toEquiv",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Field.toSemifield",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "WithZero.unitsWithZeroEquiv",
            "propext",
            "DivisionSemiring.toSemiring",
            "Int.instAddGroup",
            "OrderedCommMonoid.toPartialOrder",
            "Units.instMul",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "Equiv.symm",
            "CommGroupWithZero.toGroupWithZero",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Valuation",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "rw [WithZero.unitsWithZeroEquiv.forall_congr_left, Multiplicative.forall]",
          "proofState": 65,
          "pos": {
            "line": 167,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 \u2200 (ib : \u2124\u2098\u2080\u02e3), \u2203 ia, \u2200 (x : K), (comap A w).valuation x < \u2191ia \u2192 w.valuation ((algebraMap K L) x) < \u2191ib",
          "endPos": {
            "line": 167,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "Int"
          ],
          "tactic": "intro a",
          "proofState": 66,
          "pos": {
            "line": 168,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 \u2200 (a : \u2124),\n    \u2203 ia,\n      \u2200 (x : K),\n        (comap A w).valuation x < \u2191ia \u2192\n          w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 168,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "Multiplicative.group",
            "Units.val",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "Equiv.instFunLike",
            "Preorder.toLT",
            "Equiv.exists_congr_left",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "RingHom",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Units",
            "id",
            "Equiv",
            "MulEquiv.toEquiv",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Field.toSemifield",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "WithZero.unitsWithZeroEquiv",
            "propext",
            "DivisionSemiring.toSemiring",
            "Int.instAddGroup",
            "OrderedCommMonoid.toPartialOrder",
            "Units.instMul",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "Multiplicative.ofAdd",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "Equiv.symm",
            "CommGroupWithZero.toGroupWithZero",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Valuation",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "rw [WithZero.unitsWithZeroEquiv.exists_congr_left, Multiplicative.exists]",
          "proofState": 67,
          "pos": {
            "line": 169,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\n\u22a2 \u2203 ia,\n    \u2200 (x : K),\n      (comap A w).valuation x < \u2191ia \u2192\n        w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 169,
            "column": 75
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "CommRing.toCommSemiring",
            "Nat",
            "Ideal.ramificationIdx"
          ],
          "tactic": "let m := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal",
          "proofState": 68,
          "pos": {
            "line": 170,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\n\u22a2 \u2203 a_1,\n    \u2200 (x : K),\n      (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a_1)) \u2192\n        w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 170,
            "column": 79
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Multiplicative.group",
            "OrderedCommMonoid.toCommMonoid",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "Multiplicative.monoid",
            "Units.instLinearOrderedCommGroup",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "Equiv.trans",
            "PartialOrder.toPreorder",
            "OrderMonoidIso.unitsWithZero",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid",
            "Units",
            "Equiv",
            "MulEquiv.toEquiv",
            "Int",
            "Int.instAddMonoid",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "CommMonoid.toMonoid",
            "OrderedCommSemiring.toOrderedSemiring",
            "WithZero",
            "OrderMonoidIso.symm",
            "Multiplicative.orderedCommMonoid",
            "Int.instAddGroup",
            "OrderMonoidIso.toMulEquiv",
            "OrderedCommMonoid.toPartialOrder",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Multiplicative.ofAdd",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Int.instLinearOrderedCommRing",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "let e : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv",
          "proofState": 69,
          "pos": {
            "line": 171,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\n\u22a2 \u2203 a_1,\n    \u2200 (x : K),\n      (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a_1)) \u2192\n        w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 171,
            "column": 90
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Multiplicative.group",
            "Units.val",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "OrderedCommMonoid.toCommMonoid",
            "Equiv.instFunLike",
            "Preorder.toLT",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "Multiplicative.monoid",
            "Units.instLinearOrderedCommGroup",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "CommSemiring.toSemiring",
            "PartialOrder.toPreorder",
            "OrderMonoidIso.unitsWithZero",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid",
            "RingHom",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Units",
            "Equiv",
            "MulEquiv.toEquiv",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "Field.toSemifield",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "CommMonoid.toMonoid",
            "OrderedCommSemiring.toOrderedSemiring",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "OrderMonoidIso.symm",
            "Multiplicative.orderedCommMonoid",
            "WithZero.unitsWithZeroEquiv",
            "DivisionSemiring.toSemiring",
            "OrderMonoidIso",
            "Int.instAddGroup",
            "OrderedCommMonoid.toPartialOrder",
            "Units.instMul",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "Multiplicative.ofAdd",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "OrderMonoidIso.instEquivLike",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "Equiv.symm",
            "CommGroupWithZero.toGroupWithZero",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "letFun",
            "Valuation",
            "MonoidWithZero.toMonoid",
            "rfl",
            "EquivLike.toFunLike"
          ],
          "tactic": "have e_apply (a : \u2124) : e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a) := rfl",
          "proofState": 70,
          "pos": {
            "line": 172,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\n\u22a2 \u2203 a_1,\n    \u2200 (x : K),\n      (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a_1)) \u2192\n        w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 172,
            "column": 96
          }
        },
        {
          "usedConstants": [
            "Multiplicative.group",
            "Units.val",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "Equiv.instFunLike",
            "Preorder.toLT",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "CommSemiring.toSemiring",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "RingHom",
            "Exists",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Units",
            "Equiv",
            "MulEquiv.toEquiv",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ne",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Int",
            "Field.toSemifield",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "WithZero.unitsWithZeroEquiv",
            "DivisionSemiring.toSemiring",
            "Int.instAddGroup",
            "OrderedCommMonoid.toPartialOrder",
            "Units.instMul",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "Multiplicative.ofAdd",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "Equiv.symm",
            "CommGroupWithZero.toGroupWithZero",
            "OfNat.ofNat",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "letFun",
            "Valuation",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "have hm : m \u2260 0 := by\n  refine Ideal.IsDedekindDomain.ramificationIdx_ne_zero ?_ w.2 Ideal.map_comap_le\n  exact (Ideal.map_eq_bot_iff_of_injective (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A w).3",
          "proofState": 71,
          "pos": {
            "line": 173,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\n\u22a2 \u2203 a_1,\n    \u2200 (x : K),\n      (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a_1)) \u2192\n        w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 176,
            "column": 83
          }
        },
        {
          "usedConstants": [
            "RingHom.instRingHomClass",
            "CommSemiring.toSemiring",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Ideal.IsDedekindDomain.ramificationIdx_ne_zero",
            "Ideal.map_comap_le",
            "IsDedekindDomain.HeightOneSpectrum.isPrime",
            "Semiring.toNonAssocSemiring"
          ],
          "tactic": "refine Ideal.IsDedekindDomain.ramificationIdx_ne_zero ?_ w.2 Ideal.map_comap_le",
          "proofState": 72,
          "pos": {
            "line": 174,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\n\u22a2 m \u2260 0",
          "endPos": {
            "line": 174,
            "column": 83
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "RingHom.instRingHomClass",
            "Semiring.toModule",
            "CommSemiring.toSemiring",
            "HenselianLocalRing.toIsLocalRing",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Ideal.map",
            "Iff.not",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ideal.map_eq_bot_iff_of_injective",
            "Field.henselian",
            "Bot.bot",
            "Ideal",
            "Field.toSemifield",
            "Field.toCommRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "algebraMap_injective_of_field_isFractionRing",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "IsLocalRing.toNontrivial",
            "IsDedekindDomain.HeightOneSpectrum.ne_bot",
            "DivisionSemiring.toSemiring",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Not"
          ],
          "tactic": "exact (Ideal.map_eq_bot_iff_of_injective (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A w).3",
          "proofState": 73,
          "pos": {
            "line": 175,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\n\u22a2 Ideal.map (algebraMap A B) (comap A w).asIdeal \u2260 \u22a5",
          "endPos": {
            "line": 176,
            "column": 83
          }
        },
        {
          "usedConstants": [
            "Multiplicative.group",
            "Units.val",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "Int.instDiv",
            "Equiv.instFunLike",
            "Preorder.toLT",
            "instHDiv",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "CommSemiring.toSemiring",
            "PartialOrder.toPreorder",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "RingHom",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Units",
            "Equiv",
            "HDiv.hDiv",
            "MulEquiv.toEquiv",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Nat.cast",
            "Field.toSemifield",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "WithZero.unitsWithZeroEquiv",
            "Exists.intro",
            "DivisionSemiring.toSemiring",
            "Int.instAddGroup",
            "OrderedCommMonoid.toPartialOrder",
            "Units.instMul",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "Equiv.symm",
            "CommGroupWithZero.toGroupWithZero",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "Valuation",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "refine \u27e8a / m, fun x hx \u21a6 ?_\u27e9",
          "proofState": 74,
          "pos": {
            "line": 177,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\n\u22a2 \u2203 a_1,\n    \u2200 (x : K),\n      (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a_1)) \u2192\n        w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 177,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "Multiplicative.group",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "GroupWithZero.toMonoidWithZero",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "IsDomain",
            "CommRing",
            "Equiv.instFunLike",
            "Preorder.toLT",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Monoid.toMulOneClass",
            "WithZero.pow",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "IsFractionRing",
            "IsScalarTower",
            "PartialOrder.toPreorder",
            "IsDedekindDomain.HeightOneSpectrum",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Algebra",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Units",
            "id",
            "Equiv",
            "MulEquiv.toEquiv",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Algebra.IsIntegral",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "Field.toSemifield",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "Int.instNormedCommRing",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "LinearOrderedCommGroupWithZero.toCommGroupWithZero",
            "Semifield.toDivisionSemiring",
            "HPow.hPow",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "WithZero.unitsWithZeroEquiv",
            "DivisionSemiring.toSemiring",
            "IsDedekindDomain",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "OrderedCommMonoid.toPartialOrder",
            "Units.instMul",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.valuation_comap",
            "Multiplicative.ofAdd",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "EuclideanDomain.toCommRing",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "CommRing.toRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "Equiv.symm",
            "CommGroupWithZero.toGroupWithZero",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Eq.symm",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "Field",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Valuation",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp_rw [\u2190 valuation_comap A]",
          "proofState": 75,
          "pos": {
            "line": 178,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 w.valuation ((algebraMap K L) x) < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 178,
            "column": 31
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Multiplicative.group",
            "Iff.mpr",
            "zero_le",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "Nat.instCanonicallyOrderedAdd",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "OrderedCommMonoid.toCommMonoid",
            "Int.instDiv",
            "Nat.instMulZeroClass",
            "Equiv.instFunLike",
            "instHSMul",
            "Trans.trans",
            "Preorder.toLT",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "Nat.cast_pos",
            "Multiplicative.monoid",
            "Units.instLinearOrderedCommGroup",
            "le_rfl",
            "HMul.hMul",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "Monoid.toMulOneClass",
            "WithZero.pow",
            "MulOneClass.toMul",
            "IsLeftCancelMul.mulLeftStrictMono_of_mulLeftMono",
            "Multiplicative.linearOrderedCommMonoid",
            "Int.mul_le_of_le_ediv",
            "congrArg",
            "instLEMultiplicative",
            "OrderedAddCommMonoid.toPartialOrder",
            "OrderMonoidIso.instMulEquivClass",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "AddMonoid.toAddZeroClass",
            "IsCancelAdd.toIsLeftCancelAdd",
            "PartialOrder.toPreorder",
            "OrderMonoidIso.unitsWithZero",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Int.instNontrivial",
            "LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid",
            "AddCancelMonoid.toIsCancelAdd",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Nat.instAddMonoid",
            "Field.toDivisionRing",
            "Monoid.toNatPow",
            "Units",
            "inferInstance",
            "PartialOrder",
            "ne_of_gt",
            "Mathlib.Algebra.Group.Units.Defs._auxLemma.1",
            "id",
            "Multiplicative.mulOneClass",
            "Equiv",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "AddMonoidWithOne.toNatCast",
            "DivisionRing.toRing",
            "Multiplicative.commSemigroup",
            "CommMagma.toMul",
            "OrderedSemiring.toSemiring",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "map_pow",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
            "WithZero.partialOrder",
            "Nat.cast",
            "Multiplicative.isRightCancelMul",
            "WithZero.preorder",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "Int.instNormedCommRing",
            "_auxLemma.7",
            "Multiplicative.partialOrder",
            "HPow.hPow",
            "_auxLemma.6",
            "Distrib.toMul",
            "OrderMonoidIso.instOrderIsoClass",
            "CommMonoid.toMonoid",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "WithZero",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "congr",
            "IsRightCancelMul.mulRightStrictMono_of_mulRightMono",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "LT.lt",
            "OrderMonoidIso.symm",
            "Multiplicative.orderedCommMonoid",
            "Nat.instPartialOrder",
            "mul_comm",
            "OrderMonoidIso",
            "zero_le'",
            "Int.instAddGroup",
            "MulEquivClass.instMonoidHomClass",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "nsmul_eq_mul",
            "NonUnitalNonAssocSemiring.toDistrib",
            "AddMonoid.toNatSMul",
            "Zero.toOfNat0",
            "Eq.refl",
            "HSMul.hSMul",
            "OrderedCommMonoid.toPartialOrder",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Multiplicative.preorder",
            "instNatCastInt",
            "instTransEq_1",
            "Multiplicative.ofAdd",
            "instHPow",
            "AddMonoidWithOne.toAddMonoid",
            "pow_lt_pow_left\u2080",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "instLTNat",
            "OrderMonoidIso.instEquivLike",
            "Valuation.instFunLike",
            "instMulPosStrictMonoWithZeroOfMulRightStrictMono",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Units.instPreorder",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "AddGroup.toAddCancelMonoid",
            "OfNat.ofNat",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "AddZeroClass.toAdd",
            "covariant_swap_mul_of_covariant_mul",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "Units.instMonoid",
            "DFunLike.coe",
            "instPosMulStrictMonoWithZeroOfMulLeftStrictMono",
            "OrderedCommGroup.toMulLeftMono",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "OrderedAddCommGroup.toPartialOrder",
            "IsCancelAdd.toIsRightCancelAdd",
            "Multiplicative.isLeftCancelMul",
            "Valuation",
            "MonoidWithZero.toMonoid",
            "Int.instLEInt",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Units.instMulOneClass",
            "Multiplicative.orderedCommGroup",
            "EquivLike.toFunLike",
            "Int.instSemiring",
            "Int.instAddCommSemigroup",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul",
            "LinearOrderedCommMonoidWithZero.toZeroLeOneClass",
            "Zero",
            "instTransLtLe_mathlib"
          ],
          "tactic": "calc\n  (comap A w).valuation x ^ m < e (a / \u2191m) ^ m := by gcongr; exacts [zero_le', hx]\n  _ = e (m \u2022 (a / \u2191m)) := by\n    dsimp [e]\n    norm_cast\n    rw [map_pow]\n  _ \u2264 e a := by\n    simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]\n    rw [mul_comm]\n    exact Int.mul_le_of_le_ediv (by positivity) le_rfl",
          "proofState": 76,
          "pos": {
            "line": 179,
            "column": 2
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 (comap A w).valuation x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal <\n    \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd a))",
          "endPos": {
            "line": 188,
            "column": 54
          }
        },
        {
          "usedConstants": [],
          "tactic": "\n  (comap A w).valuation x ^ m < e (a / \u2191m) ^ m := by gcongr; exacts [zero_le', hx]\n  _ = e (m \u2022 (a / \u2191m)) := by\n    dsimp [e]\n    norm_cast\n    rw [map_pow]\n  _ \u2264 e a := by\n    simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]\n    rw [mul_comm]\n    exact Int.mul_le_of_le_ediv (by positivity) le_rfl",
          "proofState": 77,
          "pos": {
            "line": 180,
            "column": 4
          },
          "goals": "no goals",
          "endPos": {
            "line": 188,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "pow_lt_pow_left\u2080"
          ],
          "tactic": "gcongr",
          "proofState": 78,
          "pos": {
            "line": 180,
            "column": 55
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 (comap A w).valuation x ^ m < \u2191(e (a / \u2191m)) ^ m",
          "endPos": {
            "line": 180,
            "column": 61
          }
        },
        {
          "usedConstants": [
            "Multiplicative.linearOrderedCommMonoid",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Field.toDivisionRing",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "zero_le'",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "Int.instLinearOrderedCommRing",
            "DFunLike.coe",
            "Valuation"
          ],
          "tactic": "exacts [zero_le', hx]",
          "proofState": 79,
          "pos": {
            "line": 180,
            "column": 63
          },
          "goals": "case ha\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 0 \u2264 (comap A w).valuation x\ncase hab\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 (comap A w).valuation x < \u2191(e (a / \u2191m))",
          "endPos": {
            "line": 180,
            "column": 84
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "NormedCommRing.toSeminormedCommRing",
            "Int.instDiv",
            "Equiv.instFunLike",
            "instHSMul",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "WithZero.pow",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "Units",
            "id",
            "Equiv",
            "HDiv.hDiv",
            "Int",
            "Int.instAddMonoid",
            "Nat.cast",
            "Multiplicative",
            "Int.instNormedCommRing",
            "HPow.hPow",
            "WithZero",
            "Nat",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "AddMonoid.toNatSMul",
            "HSMul.hSMul",
            "instNatCastInt",
            "instHPow",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "WithZero.monoidWithZero",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "dsimp [e]",
          "proofState": 80,
          "pos": {
            "line": 182,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 \u2191(e (a / \u2191m)) ^ m = \u2191(e (m \u2022 (a / \u2191m)))",
          "endPos": {
            "line": 182,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Multiplicative.group",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Units.val",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "OrderedCommMonoid.toCommMonoid",
            "Int.instDiv",
            "Equiv.instFunLike",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "Multiplicative.monoid",
            "Units.instLinearOrderedCommGroup",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "Monoid.toMulOneClass",
            "WithZero.pow",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "PartialOrder.toPreorder",
            "OrderMonoidIso.unitsWithZero",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Monoid.toNatPow",
            "Units",
            "Mathlib.Algebra.Group.Units.Defs._auxLemma.1",
            "id",
            "Equiv",
            "HDiv.hDiv",
            "Int",
            "Int.instAddMonoid",
            "Nat.cast",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "Int.instNormedCommRing",
            "HPow.hPow",
            "CommMonoid.toMonoid",
            "OrderedCommSemiring.toOrderedSemiring",
            "WithZero",
            "Nat",
            "OrderMonoidIso.symm",
            "Multiplicative.orderedCommMonoid",
            "OrderMonoidIso",
            "Int.instAddGroup",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "OrderedCommMonoid.toPartialOrder",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "OrderMonoidIso.instEquivLike",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Eq",
            "instOneMultiplicativeOfZero",
            "Units.instMonoid",
            "DFunLike.coe",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "MonoidWithZero.toMonoid",
            "MulZeroClass.toZero",
            "EquivLike.toFunLike",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "norm_cast",
          "proofState": 81,
          "pos": {
            "line": 183,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 \u2191(OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd (a / \u2191m))) ^ m =\n    \u2191(OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd (a / \u2191m) ^ m))",
          "endPos": {
            "line": 183,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Multiplicative.group",
            "Eq.mpr",
            "OrderedCommMonoid.toCommMonoid",
            "Int.instDiv",
            "Equiv.instFunLike",
            "instHDiv",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "Multiplicative.monoid",
            "Units.instLinearOrderedCommGroup",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "PartialOrder.toPreorder",
            "OrderMonoidIso.unitsWithZero",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid",
            "Monoid.toNatPow",
            "Units",
            "id",
            "Equiv",
            "HDiv.hDiv",
            "Int",
            "Int.instAddMonoid",
            "map_pow",
            "Nat.cast",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "HPow.hPow",
            "CommMonoid.toMonoid",
            "OrderedCommSemiring.toOrderedSemiring",
            "WithZero",
            "Nat",
            "OrderMonoidIso.symm",
            "Multiplicative.orderedCommMonoid",
            "OrderMonoidIso",
            "Int.instAddGroup",
            "OrderedCommMonoid.toPartialOrder",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "OrderMonoidIso.instEquivLike",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Int.instLinearOrderedCommRing",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Eq",
            "Units.instMonoid",
            "DFunLike.coe",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "MonoidWithZero.toMonoid",
            "EquivLike.toFunLike"
          ],
          "tactic": "rw [map_pow]",
          "proofState": 82,
          "pos": {
            "line": 184,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd (a / \u2191m)) ^ m =\n    OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd (a / \u2191m) ^ m)",
          "endPos": {
            "line": 184,
            "column": 16
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Multiplicative.group",
            "Units.val",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "OrderedCommMonoid.toCommMonoid",
            "Int.instDiv",
            "Equiv.instFunLike",
            "instHSMul",
            "instHDiv",
            "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
            "Multiplicative.monoid",
            "Units.instLinearOrderedCommGroup",
            "HMul.hMul",
            "LinearOrderedCommMonoid.toOrderedCommMonoid",
            "Monoid.toMulOneClass",
            "MulOneClass.toMul",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "instLEMultiplicative",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "PartialOrder.toPreorder",
            "OrderMonoidIso.unitsWithZero",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid",
            "Preorder.toLE",
            "Units",
            "id",
            "Equiv",
            "HDiv.hDiv",
            "DivInvMonoid.toMonoid",
            "AddMonoidWithOne.toNatCast",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Int.instAddMonoid",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "Nat.cast",
            "WithZero.preorder",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Group.toDivInvMonoid",
            "Multiplicative",
            "_auxLemma.7",
            "_auxLemma.6",
            "Distrib.toMul",
            "OrderMonoidIso.instOrderIsoClass",
            "CommMonoid.toMonoid",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "WithZero",
            "Nat",
            "congr",
            "OrderMonoidIso.symm",
            "Multiplicative.orderedCommMonoid",
            "OrderMonoidIso",
            "Int.instAddGroup",
            "nsmul_eq_mul",
            "NonUnitalNonAssocSemiring.toDistrib",
            "AddMonoid.toNatSMul",
            "HSMul.hSMul",
            "OrderedCommMonoid.toPartialOrder",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Multiplicative.preorder",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "AddMonoidWithOne.toAddMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "OrderMonoidIso.instEquivLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Units.instPreorder",
            "Int.instLinearOrderedCommRing",
            "WithZero.monoidWithZero",
            "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "OrderedAddCommGroup.toPartialOrder",
            "MonoidWithZero.toMonoid",
            "Int.instLEInt",
            "Eq.trans",
            "EquivLike.toFunLike",
            "Int.instSemiring",
            "instHMul"
          ],
          "tactic": "simp only [nsmul_eq_mul, e_apply, Units.val_le_val, OrderIsoClass.map_le_map_iff]",
          "proofState": 83,
          "pos": {
            "line": 186,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 \u2191(e (m \u2022 (a / \u2191m))) \u2264 \u2191(e a)",
          "endPos": {
            "line": 186,
            "column": 85
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Int.instDiv",
            "Equiv.instFunLike",
            "instHDiv",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "congrArg",
            "instLEMultiplicative",
            "id",
            "Equiv",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "CommMagma.toMul",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LE.le",
            "Nat.cast",
            "Multiplicative",
            "Int.instNormedCommRing",
            "Distrib.toMul",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocCommSemiring.toCommMagma",
            "mul_comm",
            "NonUnitalNonAssocSemiring.toDistrib",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "Int.instLEInt",
            "Int.instSemiring",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "instHMul"
          ],
          "tactic": "rw [mul_comm]",
          "proofState": 84,
          "pos": {
            "line": 187,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 Multiplicative.ofAdd (\u2191m * (a / \u2191m)) \u2264 Multiplicative.ofAdd a",
          "endPos": {
            "line": 187,
            "column": 17
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Iff.mpr",
            "zero_le",
            "Nat.instCanonicallyOrderedAdd",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Int.instDiv",
            "Nat.instMulZeroClass",
            "Equiv.instFunLike",
            "Preorder.toLT",
            "instHDiv",
            "Nat.cast_pos",
            "le_rfl",
            "Int.mul_le_of_le_ediv",
            "OrderedAddCommMonoid.toPartialOrder",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "Int.instNontrivial",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Nat.instAddMonoid",
            "inferInstance",
            "PartialOrder",
            "Equiv",
            "HDiv.hDiv",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "LinearOrderedRing.toStrictOrderedRing",
            "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
            "Nat.cast",
            "Multiplicative",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "LT.lt",
            "Nat.instPartialOrder",
            "Zero.toOfNat0",
            "instNatCastInt",
            "Multiplicative.ofAdd",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "instLTNat",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "OrderedAddCommGroup.toPartialOrder",
            "MulZeroClass.toZero",
            "Int.instSemiring",
            "Zero"
          ],
          "tactic": "exact Int.mul_le_of_le_ediv (by positivity) le_rfl",
          "proofState": 85,
          "pos": {
            "line": 188,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 Multiplicative.ofAdd (a / \u2191m * \u2191m) \u2264 Multiplicative.ofAdd a",
          "endPos": {
            "line": 188,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "OrderedSemiring.toOrderedAddCommMonoid",
            "Iff.mpr",
            "zero_le",
            "Nat.instCanonicallyOrderedAdd",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "Nat.instMulZeroClass",
            "Preorder.toLT",
            "Nat.cast_pos",
            "OrderedAddCommMonoid.toPartialOrder",
            "AddMonoid.toAddZeroClass",
            "PartialOrder.toPreorder",
            "Int.instNontrivial",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Nat.instAddMonoid",
            "inferInstance",
            "PartialOrder",
            "AddMonoidWithOne.toNatCast",
            "OrderedSemiring.toSemiring",
            "instOfNatNat",
            "Int",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Mathlib.Meta.Positivity.lt_of_le_of_ne'",
            "Nat.cast",
            "OrderedCommSemiring.toOrderedSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Nat",
            "LT.lt",
            "Nat.instPartialOrder",
            "Zero.toOfNat0",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "instLTNat",
            "StrictOrderedCommSemiring.toOrderedCommSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Semiring.toNonAssocSemiring",
            "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
            "MulZeroClass.toZero",
            "Zero"
          ],
          "tactic": "positivity",
          "proofState": 86,
          "pos": {
            "line": 188,
            "column": 36
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\nthis : UniformSpace K := Valued.toUniformSpace\na : \u2124\nm : \u2115 := Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal\ne : \u2124 \u2243 \u2124\u2098\u2080\u02e3 := Multiplicative.ofAdd.trans OrderMonoidIso.unitsWithZero.symm.toEquiv\ne_apply : \u2200 (a : \u2124), e a = OrderMonoidIso.unitsWithZero.symm (Multiplicative.ofAdd a)\nhm : m \u2260 0\nx : K\nhx : (comap A w).valuation x < \u2191(WithZero.unitsWithZeroEquiv.symm (Multiplicative.ofAdd (a / \u2191m)))\n\u22a2 0 < \u2191m",
          "endPos": {
            "line": 188,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "CommSemiring.toSemiring",
            "SemialgHomClass.toRingHomClass",
            "Algebra",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "sorryAx",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Distrib.toAdd",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Int",
            "Lean.Name.num",
            "Field.toSemifield",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "Multiplicative",
            "Valued.toUniformSpace",
            "Semifield.toDivisionSemiring",
            "IsModuleTopology",
            "RingHomClass.toRingHom",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Lean.Name",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "EuclideanDomain.toCommRing",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Bool.false",
            "SemialgHom",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Field.toEuclideanDomain",
            "RingHom.toAlgebra"
          ],
          "tactic": "sorry\n  -- FLT#326",
          "proofState": 87,
          "pos": {
            "line": 219,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 let inst_alg := (\u2191(adicCompletionComapSemialgHom A K L B v w hvw)).toAlgebra;\n  IsModuleTopology (adicCompletion K v) (adicCompletion L w)",
          "endPos": {
            "line": 219,
            "column": 7
          }
        },
        {
          "usedConstants": [],
          "tactic": "revert x",
          "proofState": 88,
          "pos": {
            "line": 235,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nx : adicCompletion K v\n\u22a2 Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) x) =\n    Valued.v x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal",
          "endPos": {
            "line": 235,
            "column": 10
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "WithZero.pow",
            "CommSemiring.toSemiring",
            "Valued.v",
            "funext_iff",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "Field.toSemifield",
            "Multiplicative",
            "Int.instNormedCommRing",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "HPow.hPow",
            "WithZero",
            "Nat",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "instHPow",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "SemialgHom",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Valuation",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "apply funext_iff.mp",
          "proofState": 89,
          "pos": {
            "line": 236,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 \u2200 (x : adicCompletion K v),\n    Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) x) =\n      Valued.v x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal",
          "endPos": {
            "line": 236,
            "column": 21
          }
        },
        {
          "usedConstants": [
            "Eq.symm"
          ],
          "tactic": "symm",
          "proofState": 90,
          "pos": {
            "line": 237,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 (fun x => Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) x)) = fun x =>\n    Valued.v x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal",
          "endPos": {
            "line": 237,
            "column": 6
          }
        },
        {
          "usedConstants": [
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Field.toDivisionRing",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "DivisionRing.toRing",
            "Int",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "WithZero",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing"
          ],
          "tactic": "letI : UniformSpace K := v.adicValued.toUniformSpace",
          "proofState": 91,
          "pos": {
            "line": 238,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 (fun x => Valued.v x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) = fun x =>\n    Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) x)",
          "endPos": {
            "line": 238,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Field.toDivisionRing",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "DivisionRing.toRing",
            "Int",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "WithZero",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing"
          ],
          "tactic": "letI : UniformSpace L := w.adicValued.toUniformSpace",
          "proofState": 92,
          "pos": {
            "line": 239,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 (fun x => Valued.v x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) = fun x =>\n    Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) x)",
          "endPos": {
            "line": 239,
            "column": 54
          }
        },
        {
          "usedConstants": [
            "UniformSpace.Completion.ext"
          ],
          "tactic": "apply UniformSpace.Completion.ext",
          "proofState": 93,
          "pos": {
            "line": 240,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis\u271d : UniformSpace K := Valued.toUniformSpace\nthis : UniformSpace L := Valued.toUniformSpace\n\u22a2 (fun x => Valued.v x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal) = fun x =>\n    Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) x)",
          "endPos": {
            "line": 240,
            "column": 35
          }
        },
        {
          "usedConstants": [
            "WithZeroTopology.topologicalSpace",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "Valued.topologicalDivisionRing",
            "Multiplicative.monoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "CommSemiring.toSemiring",
            "Valued.continuous_valuation",
            "Valued.v",
            "Continuous.pow",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "CommRing.toCommSemiring",
            "UniformSpace.Completion.instField",
            "WithZeroTopology.instContinuousMul",
            "WithZero",
            "Valued.completable",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "WithZero.monoidWithZero",
            "UniformSpace.toTopologicalSpace",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Valuation",
            "UniformSpace.Completion",
            "MonoidWithZero.toMonoid",
            "Valued.toUniformAddGroup"
          ],
          "tactic": "exact Valued.continuous_valuation.pow _",
          "proofState": 94,
          "pos": {
            "line": 241,
            "column": 4
          },
          "goals": "case hf\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis\u271d : UniformSpace K := Valued.toUniformSpace\nthis : UniformSpace L := Valued.toUniformSpace\n\u22a2 Continuous fun x => Valued.v x ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal",
          "endPos": {
            "line": 241,
            "column": 43
          }
        },
        {
          "usedConstants": [
            "WithZeroTopology.topologicalSpace",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "instFunLike",
            "UniformSpace.Completion.coeRingHom",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion.proof_3",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom.proof_2",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Continuous.comp",
            "Valued.continuous_valuation",
            "Valued.v",
            "RingHom",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion_completeSpace",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "DivisionRing.toRing",
            "Int",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "UniformSpace.Completion.uniformSpace",
            "RingHom.comp",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "UniformSpace.Completion.ring",
            "WithZero",
            "UniformSpace.Completion.continuous_extension",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "EuclideanDomain.toCommRing",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "CommRing.toRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "SemialgHom",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "DFunLike.coe",
            "Valuation",
            "Field.toEuclideanDomain",
            "UniformSpace.Completion"
          ],
          "tactic": "exact Valued.continuous_valuation.comp UniformSpace.Completion.continuous_extension",
          "proofState": 95,
          "pos": {
            "line": 242,
            "column": 4
          },
          "goals": "case hg\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis\u271d : UniformSpace K := Valued.toUniformSpace\nthis : UniformSpace L := Valued.toUniformSpace\n\u22a2 Continuous fun x => Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) x)",
          "endPos": {
            "line": 242,
            "column": 87
          }
        },
        {
          "usedConstants": [],
          "tactic": "intro a",
          "proofState": 96,
          "pos": {
            "line": 243,
            "column": 2
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis\u271d : UniformSpace K := Valued.toUniformSpace\nthis : UniformSpace L := Valued.toUniformSpace\n\u22a2 \u2200 (a : K),\n    Valued.v \u2191a ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n      Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) \u2191a)",
          "endPos": {
            "line": 243,
            "column": 9
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "UniformSpace.Completion.coe'",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom_coe",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "WithZero.pow",
            "congrArg",
            "CommSemiring.toSemiring",
            "Valued.v",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "id",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.adicValued",
            "Multiplicative",
            "Valued.toUniformSpace",
            "Int.instNormedCommRing",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "HPow.hPow",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "instHPow",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Valuation",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "simp_rw [adicCompletionComapSemialgHom_coe, adicCompletion, Valued.valuedCompletion_apply, adicValued_apply]",
          "proofState": 97,
          "pos": {
            "line": 244,
            "column": 2
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis\u271d : UniformSpace K := Valued.toUniformSpace\nthis : UniformSpace L := Valued.toUniformSpace\na : K\n\u22a2 Valued.v \u2191a ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    Valued.v ((adicCompletionComapSemialgHom A K L B v w hvw) \u2191a)",
          "endPos": {
            "line": 245,
            "column": 21
          }
        },
        {
          "usedConstants": [],
          "tactic": "subst hvw",
          "proofState": 98,
          "pos": {
            "line": 246,
            "column": 2
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\nthis\u271d : UniformSpace K := Valued.toUniformSpace\nthis : UniformSpace L := Valued.toUniformSpace\na : K\n\u22a2 v.valuation a ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.valuation ((algebraMap K L) a)",
          "endPos": {
            "line": 246,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NormedCommRing.toSeminormedCommRing",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "WithZero.pow",
            "Multiplicative.linearOrderedCommMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "Field.toDivisionRing",
            "algebraMap",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "id",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "Field.toSemifield",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "Int.instNormedCommRing",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "HPow.hPow",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.valuation",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.valuation_comap",
            "instHPow",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "Eq.symm",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "Valuation",
            "MulZeroClass.toZero",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing"
          ],
          "tactic": "rw [\u2190 valuation_comap A K L B w a]",
          "proofState": 99,
          "pos": {
            "line": 247,
            "column": 2
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nw : HeightOneSpectrum B\nthis\u271d : UniformSpace L := Valued.toUniformSpace\na : K\nthis : UniformSpace K := Valued.toUniformSpace\n\u22a2 (comap A w).valuation a ^ Ideal.ramificationIdx (algebraMap A B) (comap A w).asIdeal w.asIdeal =\n    w.valuation ((algebraMap K L) a)",
          "endPos": {
            "line": 247,
            "column": 36
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Pi.topologicalSpace",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "CommSemiring.toSemiring",
            "SemialgHomClass.toRingHomClass",
            "IsDedekindDomain.HeightOneSpectrum",
            "Algebra",
            "Algebra.toSMul",
            "Int.instLinearOrderedAddCommGroup",
            "Field.toDivisionRing",
            "sorryAx",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Subtype",
            "Distrib.toAdd",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Int",
            "Lean.Name.num",
            "Pi.ringHom",
            "Field.toSemifield",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "Multiplicative",
            "Valued.toUniformSpace",
            "Pi.semiring",
            "Pi.instAdd",
            "Semifield.toDivisionSemiring",
            "IsModuleTopology",
            "RingHomClass.toRingHom",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Lean.Name",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "EuclideanDomain.toCommRing",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "Pi.commSemiring",
            "Bool.false",
            "Subtype.val",
            "SemialgHom",
            "UniformSpace.toTopologicalSpace",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Field.toEuclideanDomain",
            "RingHom.toAlgebra",
            "Subtype.property"
          ],
          "tactic": "sorry\n  -- FLT#327",
          "proofState": 100,
          "pos": {
            "line": 265,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 let inst_alg := (Pi.ringHom fun w => \u2191(adicCompletionComapSemialgHom A K L B v \u2191w \u22ef)).toAlgebra;\n  IsModuleTopology (adicCompletion K v) ((w : { w // v = comap A w }) \u2192 adicCompletion L \u2191w)",
          "endPos": {
            "line": 265,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "AlgHom",
            "AlgHom.funLike",
            "IsDedekindDomain.HeightOneSpectrum",
            "RingHom",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.id",
            "id",
            "Subtype",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Pi.semiring",
            "Pi.algebra",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "Distrib.toMul",
            "Localization.instSMulCommClassOfIsScalarTower",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Algebra.TensorProduct.instSemiring",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "HSMul.hSMul",
            "Algebra.smul_def",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "TensorProduct.tmul",
            "EuclideanDomain.toCommRing",
            "CommRing.toCommMonoid",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Field.toEuclideanDomain",
            "Subtype.property",
            "instHMul"
          ],
          "tactic": "rw [Algebra.smul_def]",
          "proofState": 101,
          "pos": {
            "line": 280,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nx : L\ny : adicCompletion K v\ni : { w // v = comap A w }\n\u22a2 (tensorAdicCompletionComapAlgHom A K L B v) (x \u2297\u209c[K] y) i = x \u2022 (adicCompletionComapSemialgHom A K L B v \u2191i \u22ef) y",
          "endPos": {
            "line": 280,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "AlgHom",
            "AlgHom.funLike",
            "IsDedekindDomain.HeightOneSpectrum",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "Algebra.id",
            "Subtype",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Pi.semiring",
            "Pi.algebra",
            "Semifield.toDivisionSemiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "Algebra.TensorProduct.instSemiring",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "TensorProduct",
            "Eq.refl",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "TensorProduct.tmul",
            "EuclideanDomain.toCommRing",
            "CommRing.toCommMonoid",
            "Subtype.val",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Field.toEuclideanDomain"
          ],
          "tactic": "rfl",
          "proofState": 102,
          "pos": {
            "line": 281,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nx : L\ny : adicCompletion K v\ni : { w // v = comap A w }\n\u22a2 (tensorAdicCompletionComapAlgHom A K L B v) (x \u2297\u209c[K] y) i =\n    (algebraMap L (adicCompletion L \u2191i)) x * (adicCompletionComapSemialgHom A K L B v \u2191i \u22ef) y",
          "endPos": {
            "line": 281,
            "column": 5
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "AlgHom",
            "AlgHom.funLike",
            "IsDedekindDomain.HeightOneSpectrum",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "sorryAx",
            "Algebra.id",
            "Subtype",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "instOfNatNat",
            "Lean.Name.num",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "Lean.Name.str",
            "Lean.Name.anonymous",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Pi.semiring",
            "Pi.algebra",
            "Semifield.toDivisionSemiring",
            "Localization.instSMulCommClassOfIsScalarTower",
            "Nat",
            "Algebra.TensorProduct.instSemiring",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Function.Bijective",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "Lean.Name",
            "TensorProduct",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "EuclideanDomain.toCommRing",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "Bool.false",
            "Subtype.val",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "Field.toEuclideanDomain"
          ],
          "tactic": "sorry\n  -- issue FLT#231",
          "proofState": 103,
          "pos": {
            "line": 285,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\n\u22a2 Function.Bijective \u21d1(tensorAdicCompletionComapAlgHom A K L B v)",
          "endPos": {
            "line": 285,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "Algebra.toSMul",
            "Membership.mem",
            "smul_mul_assoc",
            "Field.toSemifield",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "Distrib.toMul",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion.algebra'",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "EuclideanDomain.toCommRing",
            "Subtype.val",
            "SetLike.instMembership",
            "Field.toEuclideanDomain",
            "ValuationSubring"
          ],
          "tactic": "exact smul_mul_assoc x y.1 z",
          "proofState": 104,
          "pos": {
            "line": 315,
            "column": 18
          },
          "goals": "A : Type u_1\nK\u271d : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2075 : CommRing A\ninst\u271d\u00b2\u2074 : CommRing B\ninst\u271d\u00b2\u00b3 : Algebra A B\ninst\u271d\u00b2\u00b2 : Field K\u271d\ninst\u271d\u00b2\u00b9 : Field L\ninst\u271d\u00b2\u2070 : Algebra A K\u271d\ninst\u271d\u00b9\u2079 : IsFractionRing A K\u271d\ninst\u271d\u00b9\u2078 : Algebra B L\ninst\u271d\u00b9\u2077 : IsDedekindDomain A\ninst\u271d\u00b9\u2076 : Algebra K\u271d L\ninst\u271d\u00b9\u2075 : Algebra A L\ninst\u271d\u00b9\u2074 : IsScalarTower A B L\ninst\u271d\u00b9\u00b3 : IsScalarTower A K\u271d L\ninst\u271d\u00b9\u00b2 : IsIntegralClosure B A L\ninst\u271d\u00b9\u00b9 : FiniteDimensional K\u271d L\ninst\u271d\u00b9\u2070 : Algebra.IsSeparable K\u271d L\ninst\u271d\u2079 : IsDomain B\ninst\u271d\u2078 : Algebra.IsIntegral A B\ninst\u271d\u2077 : Module.Finite A B\ninst\u271d\u2076 : IsDedekindDomain B\ninst\u271d\u2075 : IsFractionRing B L\nR : Type u_5\nK : Type u_6\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : IsDedekindDomain R\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra R K\ninst\u271d : IsFractionRing R K\nv : HeightOneSpectrum R\nx : R\ny : \u21a5(adicCompletionIntegers K v)\nz : adicCompletion K v\n\u22a2 (x \u2022 y) \u2022 z = x \u2022 y \u2022 z",
          "endPos": {
            "line": 315,
            "column": 46
          }
        },
        {
          "usedConstants": [
            "IsDedekindDomain.HeightOneSpectrum",
            "Subtype",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "Subtype.val",
            "Eq"
          ],
          "tactic": "rintro _ \u27e8x, rfl\u27e9 i -",
          "proofState": 105,
          "pos": {
            "line": 340,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\n\u22a2 ((AlgHom.restrictScalars B (tensorAdicCompletionComapAlgHom A K L B v)).comp\n        (tensorAdicCompletionIntegersTo A K L B v)).range \u2264\n    Subalgebra.pi Set.univ fun x => adicCompletionIntegersSubalgebra L \u2191x",
          "endPos": {
            "line": 340,
            "column": 23
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "Subalgebra.instSetLike",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "Submodule",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SMulCommClass.of_commMonoid",
            "CommSemiring.toSemiring",
            "AlgHom",
            "OrderedAddCommMonoid.toPartialOrder",
            "AlgHom.funLike",
            "PartialOrder.toPreorder",
            "IsDedekindDomain.HeightOneSpectrum",
            "Preorder.toLE",
            "RingHom",
            "Algebra.toSMul",
            "Membership.mem",
            "Field.toDivisionRing",
            "Algebra.toModule",
            "Algebra.id",
            "id",
            "Subtype",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraSubtypeAdicCompletionMemValuationSubringAdicCompletionIntegers",
            "LE.le",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionIntegersTo",
            "Algebra.TensorProduct.leftAlgebra",
            "_auxLemma.8",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Pi.semiring",
            "Pi.algebra",
            "CommRing.toCommSemiring",
            "AlgHom.restrictScalars",
            "RingHom.instFunLike",
            "TensorProduct.isScalarTower_left",
            "ValuationSubring.instCommRingSubtypeMem",
            "Semifield.toDivisionSemiring",
            "SetLike.coe",
            "Localization.instSMulCommClassOfIsScalarTower",
            "SetLike.instPartialOrder",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegersSubalgebra",
            "AlgHom.toRingHom",
            "Pi.isScalarTower",
            "ValuationSubring.instSubringClass",
            "Submodule.instOrderedAddCommMonoid",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "Subalgebra.toSubmodule",
            "Algebra.TensorProduct.instSemiring",
            "Submodule.setLike",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion.algebra'",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "TensorProduct",
            "ValuationSubring.instSetLike",
            "Module.toDistribMulAction",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "OrderEmbedding",
            "EuclideanDomain.toCommRing",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Subalgebra",
            "AlgHom.comp",
            "Subtype.val",
            "IsDedekindDomain.HeightOneSpectrum.instIsScalarTowerAdicCompletion",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Set.instMembership",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "SetLike.instMembership",
            "RelEmbedding.instFunLike",
            "Field.toEuclideanDomain",
            "MonoidWithZero.toMonoid",
            "SubsemiringClass.toCommSemiring",
            "SubringClass.toSubsemiringClass",
            "Semiring.toMonoidWithZero",
            "ValuationSubring",
            "Set"
          ],
          "tactic": "simp only [Subalgebra.coe_toSubmodule, AlgEquiv.toAlgHom_eq_coe, AlgHom.toRingHom_eq_coe, RingHom.coe_coe,\n  AlgHom.coe_comp, AlgHom.coe_restrictScalars', AlgHom.coe_coe, Function.comp_apply, SetLike.mem_coe]",
          "proofState": 106,
          "pos": {
            "line": 341,
            "column": 2
          },
          "goals": "case intro\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nx : B \u2297[A] \u21a5(adicCompletionIntegers K v)\ni : { w // v = comap A w }\n\u22a2 ((AlgHom.restrictScalars B (tensorAdicCompletionComapAlgHom A K L B v)).comp\n          (tensorAdicCompletionIntegersTo A K L B v)).toRingHom\n      x i \u2208\n    (fun i => \u2191((fun i => Subalgebra.toSubmodule ((fun x => adicCompletionIntegersSubalgebra L \u2191x) i)) i)) i",
          "endPos": {
            "line": 343,
            "column": 41
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "Membership.mem",
            "Subtype",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraSubtypeAdicCompletionMemValuationSubringAdicCompletionIntegers",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "ValuationSubring.instCommRingSubtypeMem",
            "TensorProduct.induction_on",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "CommRing.toRing",
            "LieAlgebra.ofAssociativeAlgebra",
            "SetLike.instMembership",
            "ValuationSubring"
          ],
          "tactic": "induction' x with x y x y hx hy",
          "proofState": 107,
          "pos": {
            "line": 344,
            "column": 2
          },
          "goals": "case intro\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nx : B \u2297[A] \u21a5(adicCompletionIntegers K v)\ni : { w // v = comap A w }\n\u22a2 (tensorAdicCompletionComapAlgHom A K L B v) ((tensorAdicCompletionIntegersTo A K L B v) x) i \u2208\n    adicCompletionIntegersSubalgebra L \u2191i",
          "endPos": {
            "line": 344,
            "column": 33
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "Subalgebra.instSetLike",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "AlgHom.algHomClass",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SMulCommClass.of_commMonoid",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AlgHom",
            "SubsemiringClass.toAddSubmonoidClass",
            "AlgHom.funLike",
            "AddMonoid.toAddZeroClass",
            "Subalgebra.SubsemiringClass",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Algebra.toSMul",
            "Membership.mem",
            "Field.toDivisionRing",
            "map_zero",
            "Algebra.id",
            "Subtype",
            "RingHomClass.toMonoidWithZeroHomClass",
            "Pi.instZero",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraSubtypeAdicCompletionMemValuationSubringAdicCompletionIntegers",
            "NonAssocSemiring.toMulZeroOneClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionIntegersTo",
            "TensorProduct.zero",
            "Field.toCommRing",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Pi.semiring",
            "Pi.algebra",
            "CommRing.toCommSemiring",
            "ValuationSubring.instCommRingSubtypeMem",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Localization.instSMulCommClassOfIsScalarTower",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegersSubalgebra",
            "congrFun",
            "ValuationSubring.instSubringClass",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "MulZeroClass.toSMulWithZero",
            "AddZeroClass.toZero",
            "Algebra.TensorProduct.instSemiring",
            "True",
            "Pi.nonAssocSemiring",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "_auxLemma.9",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion.algebra'",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "Zero.toOfNat0",
            "TensorProduct",
            "ValuationSubring.instSetLike",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "Algebra.TensorProduct.instNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "AlgHomClass.toRingHomClass",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "EuclideanDomain.toCommRing",
            "MonoidWithZeroHomClass.toZeroHomClass",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Subalgebra",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "SetLike.instMembership",
            "Field.toEuclideanDomain",
            "SubsemiringClass.toCommSemiring",
            "SubringClass.toSubsemiringClass",
            "Eq.trans",
            "MulZeroClass.toZero",
            "AddSubmonoidClass.toZeroMemClass",
            "Semiring.toMonoidWithZero",
            "ValuationSubring"
          ],
          "tactic": "simp [map_zero, Pi.zero_apply, zero_mem]",
          "proofState": 108,
          "pos": {
            "line": 345,
            "column": 4
          },
          "goals": "case intro.zero\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\n\u22a2 (tensorAdicCompletionComapAlgHom A K L B v) ((tensorAdicCompletionIntegersTo A K L B v) 0) i \u2208\n    adicCompletionIntegersSubalgebra L \u2191i",
          "endPos": {
            "line": 345,
            "column": 44
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "Subalgebra.instSetLike",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "LieRing.toAddCommGroup",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionIntegersTo.proof_3",
            "AddCommGroup.toAddCommMonoid",
            "AlgHom",
            "AlgHom.funLike",
            "AddMonoid.toAddZeroClass",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "RingHom",
            "Algebra.toSMul",
            "Membership.mem",
            "Field.toDivisionRing",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "Algebra.id",
            "id",
            "Subtype",
            "algebraMap_smul",
            "Algebra.TensorProduct.includeLeft",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "NonAssocSemiring.toMulZeroOneClass",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "MulZeroOneClass.toMulOneClass",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "Pi.semiring",
            "Pi.algebra",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "Localization.instSMulCommClassOfIsScalarTower",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegersSubalgebra",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "congr",
            "AddZeroClass.toZero",
            "Algebra.TensorProduct.instSemiring",
            "MulOneClass.toOne",
            "AlgHom.commutes",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion.algebra'",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "ValuationSubring.instSetLike",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "TensorProduct.tmul",
            "MulZeroOneClass.toMulZeroClass",
            "EuclideanDomain.toCommRing",
            "mul_one",
            "CommRing.toCommMonoid",
            "Subalgebra",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "IsDedekindDomain.HeightOneSpectrum.instIsScalarTowerAdicCompletion",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "SetLike.instMembership",
            "Field.toEuclideanDomain",
            "one_mul",
            "Eq.trans",
            "MulZeroClass.toZero",
            "Subtype.property",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom_tmul_apply",
            "Semiring.toMonoidWithZero",
            "instHMul",
            "ValuationSubring"
          ],
          "tactic": "simp only [tensorAdicCompletionIntegersTo, Algebra.TensorProduct.lift_tmul, AlgHom.coe_comp, Function.comp_apply,\n  Algebra.ofId_apply, AlgHom.commutes, Algebra.TensorProduct.algebraMap_apply, AlgHom.coe_restrictScalars',\n  IsScalarTower.coe_toAlgHom', ValuationSubring.algebraMap_apply, Algebra.TensorProduct.includeRight_apply,\n  Algebra.TensorProduct.tmul_mul_tmul, mul_one, one_mul, tensorAdicCompletionComapAlgHom_tmul_apply, algebraMap_smul]",
          "proofState": 109,
          "pos": {
            "line": 346,
            "column": 4
          },
          "goals": "case intro.tmul\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 (tensorAdicCompletionComapAlgHom A K L B v) ((tensorAdicCompletionIntegersTo A K L B v) (x \u2297\u209c[A] y)) i \u2208\n    adicCompletionIntegersSubalgebra L \u2191i",
          "endPos": {
            "line": 351,
            "column": 66
          }
        },
        {
          "usedConstants": [
            "Subalgebra.smul_mem"
          ],
          "tactic": "apply Subalgebra.smul_mem",
          "proofState": 110,
          "pos": {
            "line": 352,
            "column": 4
          },
          "goals": "case intro.tmul\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 x \u2022 (adicCompletionComapSemialgHom A K L B v \u2191i \u22ef) \u2191y \u2208 adicCompletionIntegersSubalgebra L \u2191i",
          "endPos": {
            "line": 352,
            "column": 29
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Valued.v",
            "PartialOrder.toPreorder",
            "IsDedekindDomain.HeightOneSpectrum",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Membership.mem",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "Field.toSemifield",
            "WithZero.preorder",
            "WithZero.one",
            "Multiplicative",
            "Int.instNormedCommRing",
            "Semifield.toDivisionSemiring",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Multiplicative.preorder",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Subtype.val",
            "SemialgHom",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "OrderedAddCommGroup.toPartialOrder",
            "SetLike.instMembership",
            "letFun",
            "Valuation",
            "MulZeroClass.toZero",
            "Subtype.property",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "ValuationSubring"
          ],
          "tactic": "show _ \u2264 (1 : \u2124\u2098\u2080)",
          "proofState": 111,
          "pos": {
            "line": 353,
            "column": 4
          },
          "goals": "case intro.tmul.hx\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 (adicCompletionComapSemialgHom A K L B v \u2191i \u22ef) \u2191y \u2208 adicCompletionIntegersSubalgebra L \u2191i",
          "endPos": {
            "line": 353,
            "column": 22
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.v_adicCompletionComapSemialgHom",
            "Eq.mpr",
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "NormedCommRing.toSeminormedCommRing",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "Multiplicative.monoid",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "WithZero.pow",
            "congrArg",
            "CommSemiring.toSemiring",
            "StrictOrderedRing.toOrderedAddCommGroup",
            "Valued.v",
            "PartialOrder.toPreorder",
            "IsDedekindDomain.HeightOneSpectrum",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Preorder.toLE",
            "Membership.mem",
            "Field.toDivisionRing",
            "algebraMap",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "Monoid.toNatPow",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "id",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "Int",
            "Int.instAddMonoid",
            "LE.le",
            "LinearOrderedRing.toStrictOrderedRing",
            "Field.toSemifield",
            "WithZero.preorder",
            "WithZero.one",
            "Multiplicative",
            "Int.instNormedCommRing",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "HPow.hPow",
            "WithZero",
            "Nat",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "Multiplicative.preorder",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "instHPow",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "SeminormedCommRing.toNonUnitalSeminormedCommRing",
            "OfNat.ofNat",
            "Subtype.val",
            "SemialgHom",
            "Eq",
            "instOneMultiplicativeOfZero",
            "DFunLike.coe",
            "Ideal.ramificationIdx",
            "OrderedAddCommGroup.toPartialOrder",
            "SetLike.instMembership",
            "Valuation",
            "MulZeroClass.toZero",
            "Subtype.property",
            "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
            "ValuationSubring"
          ],
          "tactic": "rw [v_adicCompletionComapSemialgHom A K (L := L) (B := B) v i.1 i.2 y.1, \u2190\n  one_pow (Ideal.ramificationIdx (algebraMap A B) (comap A i.1).asIdeal i.1.asIdeal), pow_le_pow_iff_left\u2080]",
          "proofState": 112,
          "pos": {
            "line": 354,
            "column": 4
          },
          "goals": "case intro.tmul.hx\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 Valued.v ((adicCompletionComapSemialgHom A K L B v \u2191i \u22ef) \u2191y) \u2264 1",
          "endPos": {
            "line": 356,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "Membership.mem",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "SetLike.instMembership",
            "Subtype.property",
            "ValuationSubring"
          ],
          "tactic": "exact y.2",
          "proofState": 113,
          "pos": {
            "line": 357,
            "column": 6
          },
          "goals": "case intro.tmul.hx\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 Valued.v \u2191y \u2264 1",
          "endPos": {
            "line": 357,
            "column": 15
          }
        },
        {
          "usedConstants": [
            "LinearOrderedCommGroupWithZero.toLinearOrderedCommMonoidWithZero",
            "LinearOrderedRing.toLinearOrderedAddCommGroup",
            "Multiplicative.linearOrderedCommMonoid",
            "Valued.v",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Membership.mem",
            "Field.toDivisionRing",
            "WithZero.instLinearOrderedCommGroupWithZero",
            "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion",
            "DivisionRing.toRing",
            "Int",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "WithZero",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "zero_le'",
            "ValuationSubring.instSetLike",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Valuation.instFunLike",
            "LinearOrderedCommRing.toLinearOrderedRing",
            "Multiplicative.linearOrderedCommGroup",
            "Int.instLinearOrderedCommRing",
            "Subtype.val",
            "DFunLike.coe",
            "SetLike.instMembership",
            "Valuation",
            "ValuationSubring"
          ],
          "tactic": "exact zero_le'",
          "proofState": 114,
          "pos": {
            "line": 358,
            "column": 6
          },
          "goals": "case intro.tmul.hx.ha\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 0 \u2264 Valued.v \u2191y",
          "endPos": {
            "line": 358,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "Multiplicative.monoid",
            "Monoid.toMulOneClass",
            "Multiplicative.linearOrderedCommMonoid",
            "LinearOrderedCommSemiring.toLinearOrderedSemiring",
            "Int",
            "Int.instAddMonoid",
            "WithZero.instLinearOrderedCommMonoidWithZero",
            "Multiplicative",
            "WithZero",
            "MulOneClass.toOne",
            "zero_le'",
            "One.toOfNat1",
            "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
            "LinearOrderedCommRing.toLinearOrderedCommSemiring",
            "Int.instLinearOrderedCommRing",
            "OfNat.ofNat",
            "WithZero.monoidWithZero",
            "MonoidWithZero.toMonoid"
          ],
          "tactic": "exact zero_le'",
          "proofState": 115,
          "pos": {
            "line": 359,
            "column": 6
          },
          "goals": "case intro.tmul.hx.hb\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 0 \u2264 1",
          "endPos": {
            "line": 359,
            "column": 20
          }
        },
        {
          "usedConstants": [
            "Iff.mpr",
            "RingHom.instRingHomClass",
            "Semiring.toModule",
            "CommSemiring.toSemiring",
            "HenselianLocalRing.toIsLocalRing",
            "IsDedekindDomain.HeightOneSpectrum",
            "RingHom",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.asIdeal",
            "Ideal.map",
            "Iff.not",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Ideal.map_eq_bot_iff_of_injective",
            "Field.henselian",
            "Bot.bot",
            "Ideal",
            "Field.toSemifield",
            "Field.toCommRing",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Submodule.instBot",
            "algebraMap_injective_of_field_isFractionRing",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "IsLocalRing.toNontrivial",
            "IsDedekindDomain.HeightOneSpectrum.ne_bot",
            "Ideal.IsDedekindDomain.ramificationIdx_ne_zero",
            "DivisionSemiring.toSemiring",
            "Ideal.map_comap_le",
            "IsDedekindDomain.HeightOneSpectrum.isPrime",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "Not"
          ],
          "tactic": "exact\n  Ideal.IsDedekindDomain.ramificationIdx_ne_zero\n    ((Ideal.map_eq_bot_iff_of_injective (algebraMap_injective_of_field_isFractionRing A B K L)).not.mpr (comap A i.1).3)\n    i.1.2 Ideal.map_comap_le",
          "proofState": 116,
          "pos": {
            "line": 360,
            "column": 6
          },
          "goals": "case intro.tmul.hx.hn\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx : B\ny : \u21a5(adicCompletionIntegers K v)\n\u22a2 Ideal.ramificationIdx (algebraMap A B) (comap A \u2191i).asIdeal (\u2191i).asIdeal \u2260 0",
          "endPos": {
            "line": 362,
            "column": 49
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "Subalgebra.instSetLike",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionComapAlgHom",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "AddSubmonoidClass.toAddMemClass",
            "TensorProduct.add",
            "AlgHom.algHomClass",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "SMulCommClass.of_commMonoid",
            "NonUnitalAlgHomClass.instLinearMapClass",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "AlgHom",
            "SubsemiringClass.toAddSubmonoidClass",
            "AlgHom.funLike",
            "Pi.module",
            "AddMonoid.toAddZeroClass",
            "Subalgebra.SubsemiringClass",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "Algebra.toSMul",
            "Membership.mem",
            "Field.toDivisionRing",
            "Algebra.id",
            "map_add",
            "Subtype",
            "Distrib.toAdd",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "DivisionRing.toRing",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraSubtypeAdicCompletionMemValuationSubringAdicCompletionIntegers",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Field.toSemifield",
            "IsDedekindDomain.HeightOneSpectrum.tensorAdicCompletionIntegersTo",
            "Field.toCommRing",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AlgHom.instNonUnitalAlgHomClassOfAlgHomClass",
            "Pi.semiring",
            "instHAdd",
            "Pi.algebra",
            "CommRing.toCommSemiring",
            "Pi.instAdd",
            "ValuationSubring.instCommRingSubtypeMem",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "Localization.instSMulCommClassOfIsScalarTower",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegersSubalgebra",
            "congrFun",
            "Algebra.TensorProduct.instNonUnitalNonAssocSemiring",
            "ValuationSubring.instSubringClass",
            "MulZeroClass.toSMulWithZero",
            "AddZeroClass.toZero",
            "Algebra.TensorProduct.instSemiring",
            "True",
            "Pi.nonUnitalNonAssocSemiring",
            "LieRing.ofAssociativeRing",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "eq_true",
            "AddMemClass.add_mem",
            "DivisionSemiring.toSemiring",
            "of_eq_true",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion.algebra'",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "TensorProduct",
            "ValuationSubring.instSetLike",
            "SMulZeroClass.toSMul",
            "TensorProduct.leftModule",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers",
            "AddMonoidWithOne.toAddMonoid",
            "MulZeroOneClass.toMulZeroClass",
            "EuclideanDomain.toCommRing",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "Subalgebra",
            "MulActionWithZero.toSMulWithZero",
            "Subtype.val",
            "RingHom.id",
            "AddZeroClass.toAdd",
            "Semiring.toNonAssocSemiring",
            "Ring.toSemiring",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "SetLike.instMembership",
            "Field.toEuclideanDomain",
            "SubsemiringClass.toCommSemiring",
            "SubringClass.toSubsemiringClass",
            "Eq.trans",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "Semiring.toMonoidWithZero",
            "ValuationSubring"
          ],
          "tactic": "simp [map_add, Pi.add_apply, add_mem hx hy]",
          "proofState": 117,
          "pos": {
            "line": 363,
            "column": 4
          },
          "goals": "case intro.add\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b9\u2076 : CommRing A\ninst\u271d\u00b9\u2075 : CommRing B\ninst\u271d\u00b9\u2074 : Algebra A B\ninst\u271d\u00b9\u00b3 : Field K\ninst\u271d\u00b9\u00b2 : Field L\ninst\u271d\u00b9\u00b9 : Algebra A K\ninst\u271d\u00b9\u2070 : IsFractionRing A K\ninst\u271d\u2079 : Algebra B L\ninst\u271d\u2078 : IsDedekindDomain A\ninst\u271d\u2077 : Algebra K L\ninst\u271d\u2076 : Algebra A L\ninst\u271d\u2075 : IsScalarTower A B L\ninst\u271d\u2074 : IsScalarTower A K L\ninst\u271d\u00b3 : IsDomain B\ninst\u271d\u00b2 : Algebra.IsIntegral A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\ni : { w // v = comap A w }\nx y : B \u2297[A] \u21a5(adicCompletionIntegers K v)\nhx :\n  (tensorAdicCompletionComapAlgHom A K L B v) ((tensorAdicCompletionIntegersTo A K L B v) x) i \u2208\n    adicCompletionIntegersSubalgebra L \u2191i\nhy :\n  (tensorAdicCompletionComapAlgHom A K L B v) ((tensorAdicCompletionIntegersTo A K L B v) y) i \u2208\n    adicCompletionIntegersSubalgebra L \u2191i\n\u22a2 (tensorAdicCompletionComapAlgHom A K L B v) ((tensorAdicCompletionIntegersTo A K L B v) (x + y)) i \u2208\n    adicCompletionIntegersSubalgebra L \u2191i",
          "endPos": {
            "line": 363,
            "column": 47
          }
        },
        {
          "usedConstants": [
            "Iff.intro"
          ],
          "tactic": "constructor",
          "proofState": 118,
          "pos": {
            "line": 410,
            "column": 2
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\n\u22a2 x.IsFiniteAdele \u2194 \u2200 (l : L), ((baseChangeEquiv A K L B) (l \u2297\u209c[K] x)).IsFiniteAdele",
          "endPos": {
            "line": 410,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "Algebra.id",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "id",
            "DivisionRing.toRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "AlgEquiv",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "implies_congr",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "Algebra.TensorProduct.instSemiring",
            "propext",
            "LieRing.ofAssociativeRing",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Eq.refl",
            "Semifield.toCommSemiring",
            "TensorProduct.tmul",
            "EuclideanDomain.toCommRing",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "AlgEquiv.instFunLike",
            "Ring.toAddGroupWithOne",
            "DedekindDomain.ProdAdicCompletions.baseChangeEquiv",
            "DedekindDomain.ProdAdicCompletions.baseChangeEquiv_isFiniteAdele_iff",
            "Field.toEuclideanDomain"
          ],
          "tactic": "simp_rw [ProdAdicCompletions.baseChangeEquiv_isFiniteAdele_iff A K L B, baseChangeEquiv, AlgEquiv.coe_ofBijective,\n  SemialgHom.baseChange_of_algebraMap, Algebra.TensorProduct.lift_tmul, map_one, one_mul]",
          "proofState": 119,
          "pos": {
            "line": 411,
            "column": 4
          },
          "goals": "case mp\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\n\u22a2 x.IsFiniteAdele \u2192 \u2200 (l : L), ((baseChangeEquiv A K L B) (l \u2297\u209c[K] x)).IsFiniteAdele",
          "endPos": {
            "line": 413,
            "column": 56
          }
        },
        {
          "usedConstants": [
            "SemialgHom.baseChange_of_algebraMap.proof_3",
            "CommSemiring.toSemiring",
            "AlgHom",
            "DedekindDomain.ProdAdicCompletions",
            "AlgHom.funLike",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "algebraMap",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "Field.toSemifield",
            "CommRing.toCommSemiring",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHom.toRingHom",
            "AlgHom.mk",
            "Semifield.toCommSemiring",
            "DFunLike.coe",
            "Algebra.compHom"
          ],
          "tactic": "intro h l",
          "proofState": 120,
          "pos": {
            "line": 414,
            "column": 4
          },
          "goals": "case mp\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\n\u22a2 ({ toRingHom := (baseChange A K L B).toRingHom, commutes' := \u22ef } x).IsFiniteAdele \u2192\n    \u2200 (l : L),\n      ((Algebra.ofId L (ProdAdicCompletions B L)) l *\n          { toRingHom := (baseChange A K L B).toRingHom, commutes' := \u22ef } x).IsFiniteAdele",
          "endPos": {
            "line": 414,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "SemialgHom.baseChange_of_algebraMap.proof_3",
            "CommSemiring.toSemiring",
            "AlgHom",
            "DedekindDomain.ProdAdicCompletions",
            "AlgHom.funLike",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele.mul",
            "algebraMap",
            "Algebra.id",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "Field.toSemifield",
            "Algebra.ofId",
            "CommRing.toCommSemiring",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "SemialgHom.toRingHom",
            "AlgHom.mk",
            "Semifield.toCommSemiring",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele.algebraMap'",
            "DFunLike.coe",
            "Algebra.compHom"
          ],
          "tactic": "exact ProdAdicCompletions.IsFiniteAdele.mul (ProdAdicCompletions.IsFiniteAdele.algebraMap' l) h",
          "proofState": 121,
          "pos": {
            "line": 415,
            "column": 4
          },
          "goals": "case mp\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\nh : ({ toRingHom := (baseChange A K L B).toRingHom, commutes' := \u22ef } x).IsFiniteAdele\nl : L\n\u22a2 ((Algebra.ofId L (ProdAdicCompletions B L)) l *\n      { toRingHom := (baseChange A K L B).toRingHom, commutes' := \u22ef } x).IsFiniteAdele",
          "endPos": {
            "line": 415,
            "column": 99
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "Algebra.id",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "DivisionRing.toRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "AlgEquiv",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "Algebra.TensorProduct.instSemiring",
            "LieRing.ofAssociativeRing",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Semifield.toCommSemiring",
            "TensorProduct.tmul",
            "EuclideanDomain.toCommRing",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "AlgEquiv.instFunLike",
            "DedekindDomain.ProdAdicCompletions.baseChangeEquiv",
            "Field.toEuclideanDomain"
          ],
          "tactic": "intro h",
          "proofState": 122,
          "pos": {
            "line": 416,
            "column": 4
          },
          "goals": "case mpr\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\n\u22a2 (\u2200 (l : L), ((baseChangeEquiv A K L B) (l \u2297\u209c[K] x)).IsFiniteAdele) \u2192 x.IsFiniteAdele",
          "endPos": {
            "line": 416,
            "column": 11
          }
        },
        {
          "usedConstants": [
            "LieAlgebra.toModule",
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "IsScalarTower.right",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Algebra.toSMul",
            "Field.toDivisionRing",
            "Algebra.id",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "id",
            "DivisionRing.toRing",
            "Field.toSemifield",
            "Algebra.TensorProduct.leftAlgebra",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "AlgEquiv",
            "Localization.instSMulCommClassOfIsScalarTower",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "Algebra.TensorProduct.instSemiring",
            "propext",
            "LieRing.ofAssociativeRing",
            "DivisionSemiring.toSemiring",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "TensorProduct",
            "Semifield.toCommSemiring",
            "TensorProduct.tmul",
            "EuclideanDomain.toCommRing",
            "CommRing.toRing",
            "CommRing.toCommMonoid",
            "OfNat.ofNat",
            "Eq",
            "DFunLike.coe",
            "LieAlgebra.ofAssociativeAlgebra",
            "AlgEquiv.instFunLike",
            "Ring.toAddGroupWithOne",
            "DedekindDomain.ProdAdicCompletions.baseChangeEquiv",
            "DedekindDomain.ProdAdicCompletions.baseChangeEquiv_isFiniteAdele_iff",
            "Field.toEuclideanDomain"
          ],
          "tactic": "rw [ProdAdicCompletions.baseChangeEquiv_isFiniteAdele_iff A K L B]",
          "proofState": 123,
          "pos": {
            "line": 417,
            "column": 4
          },
          "goals": "case mpr\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\nh : \u2200 (l : L), ((baseChangeEquiv A K L B) (l \u2297\u209c[K] x)).IsFiniteAdele\n\u22a2 x.IsFiniteAdele",
          "endPos": {
            "line": 417,
            "column": 70
          }
        },
        {
          "usedConstants": [
            "AddGroupWithOne.toAddMonoidWithOne",
            "Field.toDivisionRing",
            "DivisionRing.toRing",
            "AddMonoidWithOne.toOne",
            "One.toOfNat1",
            "OfNat.ofNat",
            "Ring.toAddGroupWithOne"
          ],
          "tactic": "exact\n  h\n    1\n      -- Restriction of an algebra map is an algebra map; these should be easy. #242",
          "proofState": 124,
          "pos": {
            "line": 418,
            "column": 4
          },
          "goals": "case mpr\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\nh : \u2200 (l : L), ((baseChangeEquiv A K L B) (l \u2297\u209c[K] x)).IsFiniteAdele\n\u22a2 ((baseChangeEquiv A K L B) (1 \u2297\u209c[K] x)).IsFiniteAdele",
          "endPos": {
            "line": 418,
            "column": 13
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "Distrib.toAdd",
            "Field.toSemifield",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "Iff.mp",
            "DivisionSemiring.toSemiring",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "rfl",
            "AddCommMagma.toAdd",
            "Subtype.property"
          ],
          "tactic": "have h : (x + y : FiniteAdeleRing A K) = (x : ProdAdicCompletions A K) + (y : ProdAdicCompletions A K) := rfl",
          "proofState": 125,
          "pos": {
            "line": 441,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx y : FiniteAdeleRing A K\n\u22a2 (fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9) (x + y) =\n    (fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9) x +\n      (fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9) y",
          "endPos": {
            "line": 442,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "instFunLike",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "id",
            "Field.toSemifield",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "Iff.mp",
            "DivisionSemiring.toSemiring",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "AddCommMagma.toAdd",
            "Subtype.property"
          ],
          "tactic": "simp_rw [h, map_add]",
          "proofState": 126,
          "pos": {
            "line": 443,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx y : FiniteAdeleRing A K\nh : \u2191(x + y) = \u2191x + \u2191y\n\u22a2 (fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9) (x + y) =\n    (fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9) x +\n      (fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9) y",
          "endPos": {
            "line": 443,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "Distrib.toAdd",
            "Field.toSemifield",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "instHAdd",
            "CommRing.toCommSemiring",
            "Semifield.toDivisionSemiring",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "Iff.mp",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property"
          ],
          "tactic": "rfl",
          "proofState": 127,
          "pos": {
            "line": 444,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx y : FiniteAdeleRing A K\nh : \u2191(x + y) = \u2191x + \u2191y\n\u22a2 \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191x + (ProdAdicCompletions.baseChange A K L B) \u2191y, \u22ef\u27e9 =\n    \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191x, \u22ef\u27e9 + \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191y, \u22ef\u27e9",
          "endPos": {
            "line": 444,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "Field.toSemifield",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "HSMul.hSMul",
            "SMulZeroClass.toSMul",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "refine ext B L <| funext fun w \u21a6 ?_",
          "proofState": 128,
          "pos": {
            "line": 446,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nk : K\nxv : FiniteAdeleRing A K\n\u22a2 { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef }.toFun (k \u2022 xv) =\n    (algebraMap K L) k \u2022\n      { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef }.toFun xv",
          "endPos": {
            "line": 446,
            "column": 39
          }
        },
        {
          "usedConstants": [
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "IsDedekindDomain.HeightOneSpectrum",
            "algebraMap",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "Field.toSemifield",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "Semifield.toDivisionSemiring",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "LinearMap.map_smul'",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "Semifield.toCommSemiring",
            "Subtype.val",
            "Semiring.toNonAssocSemiring",
            "rfl"
          ],
          "tactic": "exact (adicCompletionComapSemialgHom A K L B _ w rfl).map_smul' k (xv (comap A w))",
          "proofState": 129,
          "pos": {
            "line": 447,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nk : K\nxv : FiniteAdeleRing A K\nw : HeightOneSpectrum B\n\u22a2 \u2191({ toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef }.toFun (k \u2022 xv)) w =\n    \u2191((algebraMap K L) k \u2022\n          { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef }.toFun xv)\n      w",
          "endPos": {
            "line": 447,
            "column": 86
          }
        },
        {
          "usedConstants": [
            "DedekindDomain.FiniteAdeleRing.ext"
          ],
          "tactic": "ext",
          "proofState": 130,
          "pos": {
            "line": 426,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 1 = 1",
          "endPos": {
            "line": 426,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Module.toMulActionWithZero",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "NonAssocSemiring.toMulZeroOneClass",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "MulOneClass.toOne",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "Ring.toAddGroupWithOne",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have h : (1 : FiniteAdeleRing A K) = (1 : ProdAdicCompletions A K) := rfl",
          "proofState": 131,
          "pos": {
            "line": 427,
            "column": 4
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 \u2191({ toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 1) =\n    \u21911",
          "endPos": {
            "line": 427,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "AddGroupWithOne.toAddMonoidWithOne",
            "Module.toMulActionWithZero",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "NonAssocSemiring.toMulZeroOneClass",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "AddMonoidWithOne.toOne",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "MulOneClass.toOne",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "CommRing.toRing",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "Ring.toAddGroupWithOne",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have t : (1 : FiniteAdeleRing B L) = (1 : ProdAdicCompletions B L) := rfl",
          "proofState": 132,
          "pos": {
            "line": 428,
            "column": 4
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nh : \u21911 = 1\n\u22a2 \u2191({ toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 1) =\n    \u21911",
          "endPos": {
            "line": 428,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "NonAssocSemiring.toMulZeroOneClass",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "MulOneClass.toOne",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "One.toOfNat1",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_rw [h, t, map_one]",
          "proofState": 133,
          "pos": {
            "line": 429,
            "column": 4
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nh : \u21911 = 1\nt : \u21911 = 1\n\u22a2 \u2191({ toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 1) =\n    \u21911",
          "endPos": {
            "line": 429,
            "column": 27
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "NonAssocSemiring.toMulZeroOneClass",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "Distrib.toMul",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "have h : (x * y : FiniteAdeleRing A K) = (x : ProdAdicCompletions A K) * (y : ProdAdicCompletions A K) := rfl",
          "proofState": 134,
          "pos": {
            "line": 431,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx y : FiniteAdeleRing A K\n\u22a2 { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun\n      (x * y) =\n    { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun x *\n      { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun y",
          "endPos": {
            "line": 432,
            "column": 74
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "NonAssocSemiring.toMulZeroOneClass",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero",
            "instHMul"
          ],
          "tactic": "simp_rw [h, map_mul]",
          "proofState": 135,
          "pos": {
            "line": 433,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx y : FiniteAdeleRing A K\nh : \u2191(x * y) = \u2191x * \u2191y\n\u22a2 { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun\n      (x * y) =\n    { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun x *\n      { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun y",
          "endPos": {
            "line": 433,
            "column": 24
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "HMul.hMul",
            "CommRing.toNonUnitalCommRing",
            "MulOneClass.toMul",
            "congrArg",
            "CommSemiring.toSemiring",
            "DedekindDomain.ProdAdicCompletions",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "SemialgHomClass.toRingHomClass",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "NonAssocSemiring.toMulZeroOneClass",
            "Field.toSemifield",
            "MulZeroOneClass.toMulOneClass",
            "Subtype.mk",
            "map_mul",
            "CommRing.toCommSemiring",
            "RingHomClass.toNonUnitalRingHomClass",
            "Semifield.toDivisionSemiring",
            "Distrib.toMul",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "Iff.mp",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Eq.refl",
            "Semifield.toCommSemiring",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "DFunLike.coe",
            "NonUnitalRingHomClass.toMulHomClass",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "Subtype.property",
            "instHMul"
          ],
          "tactic": "rfl",
          "proofState": 136,
          "pos": {
            "line": 434,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx y : FiniteAdeleRing A K\nh : \u2191(x * y) = \u2191x * \u2191y\n\u22a2 \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191x * (ProdAdicCompletions.baseChange A K L B) \u2191y, \u22ef\u27e9 =\n    \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191x, \u22ef\u27e9 * \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191y, \u22ef\u27e9",
          "endPos": {
            "line": 434,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "DedekindDomain.FiniteAdeleRing.ext"
          ],
          "tactic": "ext",
          "proofState": 137,
          "pos": {
            "line": 436,
            "column": 4
          },
          "goals": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 { toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 0 = 0",
          "endPos": {
            "line": 436,
            "column": 7
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Field.toSemifield",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddMonoidWithOne.toAddMonoid",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have h : (0 : FiniteAdeleRing A K) = (0 : ProdAdicCompletions A K) := rfl",
          "proofState": 138,
          "pos": {
            "line": 437,
            "column": 4
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 \u2191({ toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 0) =\n    \u21910",
          "endPos": {
            "line": 437,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "NonUnitalNonAssocSemiring.toMulZeroClass",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Field.toSemifield",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddMonoidWithOne.toAddMonoid",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "have t : (0 : FiniteAdeleRing B L) = (0 : ProdAdicCompletions B L) := rfl",
          "proofState": 139,
          "pos": {
            "line": 438,
            "column": 4
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nh : \u21910 = 0\n\u22a2 \u2191({ toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 0) =\n    \u21910",
          "endPos": {
            "line": 438,
            "column": 77
          }
        },
        {
          "usedConstants": [
            "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
            "Eq.mpr",
            "DedekindDomain.FiniteAdeleRing.instAlgebra",
            "NonAssocSemiring.toAddCommMonoidWithOne",
            "instHSMul",
            "instFunLike",
            "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
            "CommRing.toNonUnitalCommRing",
            "congrArg",
            "CommSemiring.toSemiring",
            "SMulWithZero.toSMulZeroClass",
            "DedekindDomain.ProdAdicCompletions",
            "AddMonoid.toAddZeroClass",
            "DedekindDomain.ProdAdicCompletions.baseChange",
            "IsDedekindDomain.HeightOneSpectrum",
            "Module.toMulActionWithZero",
            "RingHom",
            "DedekindDomain.FiniteAdeleRing.instCommRing",
            "algebraMap",
            "Eq.rec",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletionComapSemialgHom",
            "Algebra.toModule",
            "DedekindDomain.instCommRingProdAdicCompletions",
            "map_add",
            "id",
            "Subtype",
            "Distrib.toAdd",
            "LinearMap.toAddHom",
            "IsDedekindDomain.HeightOneSpectrum.comap",
            "AddCommMonoidWithOne.toAddMonoidWithOne",
            "Field.toSemifield",
            "Subtype.mk",
            "NonUnitalNonAssocSemiring.toAddCommMonoid",
            "funext",
            "instHAdd",
            "CommRing.toCommSemiring",
            "RingHom.instFunLike",
            "Semifield.toDivisionSemiring",
            "MonoidWithZero.toMulZeroOneClass",
            "HAdd.hAdd",
            "DedekindDomain.instAlgebraProdAdicCompletions",
            "NonAssocSemiring.toNonUnitalNonAssocSemiring",
            "DedekindDomain.FiniteAdeleRing",
            "AddZeroClass.toZero",
            "DedekindDomain.ProdAdicCompletions.IsFiniteAdele",
            "SemialgHomClass.toSemilinearMapClass",
            "LinearMap.mk",
            "Iff.mp",
            "IsDedekindDomain.HeightOneSpectrum.adicCompletion",
            "DivisionSemiring.toSemiring",
            "Eq.ndrec",
            "SemialgHomClass.instSemialgHom",
            "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
            "IsDedekindDomain.HeightOneSpectrum.instAlgebraAdicCompletion_1",
            "NonUnitalNonAssocSemiring.toDistrib",
            "Zero.toOfNat0",
            "Eq.refl",
            "HSMul.hSMul",
            "LinearMap.map_smul'",
            "SMulZeroClass.toSMul",
            "IsDedekindDomain.HeightOneSpectrum.instFieldAdicCompletion",
            "SemialgHom.toLinearMap",
            "AddCommMonoid.toAddMonoid",
            "Semifield.toCommSemiring",
            "AddCommSemigroup.toAddCommMagma",
            "AddMonoidWithOne.toAddMonoid",
            "AddHom.mk",
            "MulZeroOneClass.toMulZeroClass",
            "OfNat.ofNat",
            "MulActionWithZero.toSMulWithZero",
            "AddCommMonoid.toAddCommSemigroup",
            "Subtype.val",
            "SemialgHom",
            "Semiring.toNonAssocSemiring",
            "Eq",
            "DFunLike.coe",
            "AddHom.toFun",
            "letFun",
            "DedekindDomain.ProdAdicCompletions.baseChange_isFiniteAdele_iff",
            "DedekindDomain.FiniteAdeleRing.ext",
            "rfl",
            "MulZeroClass.toZero",
            "SemilinearMapClass.toAddHomClass",
            "AddCommMagma.toAdd",
            "Subtype.property",
            "Semiring.toMonoidWithZero"
          ],
          "tactic": "simp_rw [h, t, map_zero]",
          "proofState": 140,
          "pos": {
            "line": 439,
            "column": 4
          },
          "goals": "case h\nA : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nh : \u21910 = 0\nt : \u21910 = 0\n\u22a2 \u2191({ toFun := fun ak => \u27e8(ProdAdicCompletions.baseChange A K L B) \u2191ak, \u22ef\u27e9, map_add' := \u22ef, map_smul' := \u22ef }.toFun 0) =\n    \u21910",
          "endPos": {
            "line": 439,
            "column": 28
          }
        }
      ],
      "sorries": [
        {
          "proofState": 0,
          "pos": {
            "line": 219,
            "column": 2
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 let inst_alg := (\u2191(adicCompletionComapSemialgHom A K L B v w hvw)).toAlgebra;\n  IsModuleTopology (adicCompletion K v) (adicCompletion L w)",
          "endPos": {
            "line": 219,
            "column": 7
          }
        },
        {
          "proofState": 1,
          "pos": {
            "line": 265,
            "column": 2
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\nw : HeightOneSpectrum B\nhvw : v = comap A w\n\u22a2 let inst_alg := (Pi.ringHom fun w => \u2191(adicCompletionComapSemialgHom A K L B v \u2191w \u22ef)).toAlgebra;\n  IsModuleTopology (adicCompletion K v) ((w : { w // v = comap A w }) \u2192 adicCompletion L \u2191w)",
          "endPos": {
            "line": 265,
            "column": 7
          }
        },
        {
          "proofState": 2,
          "pos": {
            "line": 285,
            "column": 2
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\n\u22a2 Function.Bijective \u21d1(tensorAdicCompletionComapAlgHom A K L B v)",
          "endPos": {
            "line": 285,
            "column": 7
          }
        },
        {
          "proofState": 3,
          "pos": {
            "line": 307,
            "column": 24
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\n\u22a2 Continuous (adicCompletionComapAlgEquiv A K L B v).toFun",
          "endPos": {
            "line": 307,
            "column": 29
          }
        },
        {
          "proofState": 4,
          "pos": {
            "line": 308,
            "column": 25
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nv : HeightOneSpectrum A\n\u22a2 Continuous (adicCompletionComapAlgEquiv A K L B v).invFun",
          "endPos": {
            "line": 308,
            "column": 30
          }
        },
        {
          "proofState": 5,
          "pos": {
            "line": 368,
            "column": 77
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 \u2203 S,\n    \u2200 v \u2209 S,\n      ((AlgHom.restrictScalars B (tensorAdicCompletionComapAlgHom A K L B v)).comp\n            (tensorAdicCompletionIntegersTo A K L B v)).range =\n        Subalgebra.pi Set.univ fun x => adicCompletionIntegersSubalgebra L \u2191x",
          "endPos": {
            "line": 368,
            "column": 82
          }
        },
        {
          "proofState": 6,
          "pos": {
            "line": 388,
            "column": 4
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 Function.Bijective \u21d1(baseChange A K L B).baseChange_of_algebraMap",
          "endPos": {
            "line": 388,
            "column": 9
          }
        },
        {
          "proofState": 7,
          "pos": {
            "line": 397,
            "column": 84
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\n\u22a2 x.IsFiniteAdele \u2194 ((baseChange A K L B) x).IsFiniteAdele",
          "endPos": {
            "line": 397,
            "column": 89
          }
        },
        {
          "proofState": 8,
          "pos": {
            "line": 405,
            "column": 2
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\nx : ProdAdicCompletions A K\n\u22a2 x.IsFiniteAdele \u2194 ((baseChangeEquiv A K L B) (1 \u2297\u209c[K] x)).IsFiniteAdele",
          "endPos": {
            "line": 405,
            "column": 7
          }
        },
        {
          "proofState": 9,
          "pos": {
            "line": 457,
            "column": 2
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 IsModuleTopology (FiniteAdeleRing A K) (FiniteAdeleRing B L)",
          "endPos": {
            "line": 457,
            "column": 7
          }
        },
        {
          "proofState": 10,
          "pos": {
            "line": 468,
            "column": 4
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 Function.Bijective \u21d1(baseChange A K L B).baseChange_of_algebraMap",
          "endPos": {
            "line": 468,
            "column": 9
          }
        },
        {
          "proofState": 11,
          "pos": {
            "line": 473,
            "column": 22
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 Continuous __spread\u271d\u207b\u2070.toFun",
          "endPos": {
            "line": 473,
            "column": 27
          }
        },
        {
          "proofState": 12,
          "pos": {
            "line": 474,
            "column": 23
          },
          "goal": "A : Type u_1\nK : Type u_2\nL : Type u_3\nB : Type u_4\ninst\u271d\u00b2\u2070 : CommRing A\ninst\u271d\u00b9\u2079 : CommRing B\ninst\u271d\u00b9\u2078 : Algebra A B\ninst\u271d\u00b9\u2077 : Field K\ninst\u271d\u00b9\u2076 : Field L\ninst\u271d\u00b9\u2075 : Algebra A K\ninst\u271d\u00b9\u2074 : IsFractionRing A K\ninst\u271d\u00b9\u00b3 : Algebra B L\ninst\u271d\u00b9\u00b2 : IsDedekindDomain A\ninst\u271d\u00b9\u00b9 : Algebra K L\ninst\u271d\u00b9\u2070 : Algebra A L\ninst\u271d\u2079 : IsScalarTower A B L\ninst\u271d\u2078 : IsScalarTower A K L\ninst\u271d\u2077 : IsIntegralClosure B A L\ninst\u271d\u2076 : FiniteDimensional K L\ninst\u271d\u2075 : Algebra.IsSeparable K L\ninst\u271d\u2074 : IsDomain B\ninst\u271d\u00b3 : Algebra.IsIntegral A B\ninst\u271d\u00b2 : Module.Finite A B\ninst\u271d\u00b9 : IsDedekindDomain B\ninst\u271d : IsFractionRing B L\n\u22a2 Continuous __spread\u271d\u207b\u2070.invFun",
          "endPos": {
            "line": 474,
            "column": 28
          }
        }
      ],
      "messages": [
        {
          "severity": "warning",
          "pos": {
            "line": 210,
            "column": 6
          },
          "endPos": {
            "line": 210,
            "column": 42
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 255,
            "column": 6
          },
          "endPos": {
            "line": 255,
            "column": 46
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 283,
            "column": 8
          },
          "endPos": {
            "line": 283,
            "column": 49
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 302,
            "column": 18
          },
          "endPos": {
            "line": 302,
            "column": 55
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 302,
            "column": 18
          },
          "endPos": {
            "line": 302,
            "column": 55
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 365,
            "column": 8
          },
          "endPos": {
            "line": 365,
            "column": 44
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 384,
            "column": 18
          },
          "endPos": {
            "line": 384,
            "column": 53
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 394,
            "column": 8
          },
          "endPos": {
            "line": 394,
            "column": 56
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 401,
            "column": 8
          },
          "endPos": {
            "line": 401,
            "column": 61
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 456,
            "column": 6
          },
          "endPos": {
            "line": 456,
            "column": 33
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 463,
            "column": 18
          },
          "endPos": {
            "line": 463,
            "column": 52
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 470,
            "column": 18
          },
          "endPos": {
            "line": 470,
            "column": 62
          },
          "data": "declaration uses 'sorry'"
        },
        {
          "severity": "warning",
          "pos": {
            "line": 470,
            "column": 18
          },
          "endPos": {
            "line": 470,
            "column": 62
          },
          "data": "declaration uses 'sorry'"
        }
      ],
      "env": 0
    }
  }
]